function _testCSS(a) {
    return a in document.documentElement.style
}
function _triggerEvent(a, b) {
    if (window.CustomEvent)var c = new CustomEvent(b); else {
        var c = document.createEvent("CustomEvent");
        c.initCustomEvent(b, !0, !0)
    }
    a.dispatchEvent(c)
}
function _extend(a) {
    a = a || {};
    for (var b = 1; b < arguments.length; b++)if (arguments[b])for (var c in arguments[b])arguments[b].hasOwnProperty(c) && (a[c] = arguments[b][c]);
    return a
}
function OrderedMap() {
    this.map = {}, this._karray = [], this._zarray = []
}
function PostcardObject(a, b, c) {
    var d = {x: 0, y: 0, w: 50, h: 50, opacity: 1, fill: "steelblue", rotation: 0};
    this.ctx = b, this.type = a, this.opts = _extend({}, d, c), this.x = parseInt(this.opts.x, 10), this.y = parseInt(this.opts.y, 10), this.w = parseInt(this.opts.w, 10), this.h = parseInt(this.opts.h, 10)
}
function PostcardImageObject(a, b, c) {
    function d(a) {
        var b = /(ftp|http|https):\/\/(\w+:{0,1}\w*@)?(\S+)(:[0-9]+)?(\/|\/([\w#!:.?+=&%@!\-\/]))?/;
        if (!a)throw new Error("no URL specified");
        if (-1 === a.indexOf("http://") && -1 === a.indexOf("https://")) h.url = a, e(a); else {
            var c = "https:" === location.protocol, d = h.proxyURL + "?callback=?";
            if (!d || !b.test(d) || c && 0 == d.indexOf("http:"))throw new Error("bad or insecure server url combination.");
            JSONP.get(d, {url: escape(a)}, function (b) {
                h.url = a, h.cache[h.url] = b.data, e(h.cache[h.url])
            })
        }
    }

    function e(a) {
        var b = new Image;
        b.onload = function () {
            h._canvas.width = this.width, h._canvas.height = this.height, h.imgElm = this, h._ctx.drawImage(h.imgElm, 0, 0, h._canvas.width, h._canvas.height), h.opts.keepOriginal && (h.origImgData = h._ctx.getImageData(0, 0, h._canvas.width, h._canvas.height)), h.imageloaded = !0, h.userImageLoaded.apply(h), _triggerEvent(h.ctx.canvas, "forcerender"), this.onload = f
        }, b.src = a
    }

    function f() {
        _triggerEvent(h.ctx.canvas, "forcerender")
    }

    var g = {keepOriginal: !0, crop: !1, cropX: 0, cropY: 0, cropW: 0, cropH: 0};
    this.opts = _extend({}, g, c), PostcardObject.apply(this, ["image", b, this.opts]), this.imageloaded = !1, this.userImageLoaded = function () {
    }, this.cache = {}, this._canvas = document.createElement("canvas"), this._ctx = this._canvas.getContext("2d");
    var h = this;
    a.length && d(a), this.changeURL = function (a) {
        return a === this.url ? void this.userImageLoaded.apply(this) : (this.imageloaded = !1, void(a in this.cache ? (this.url = a, e(this.cache[a])) : d(a)))
    }
}
function PostcardTextObject(a, b, c) {
    var d = {
        fill: "#ffffff",
        style: "normal",
        weight: "normal",
        size: "16px",
        family: "sans-serif",
        fontString: "",
        centered: !1
    };
    this.opts = _extend({}, d, c), PostcardObject.apply(this, ["text", b, this.opts]), this.text = a;
    var e = this;
    this._canvas = document.createElement("canvas"), this._ctx = this._canvas.getContext("2d");
    var f = function () {
        e._ctx.font = e.getFont(), e.w = e.opts.w = e._ctx.measureText(e.text).width, e.h = e.opts.h = parseInt(e.opts.size, 10)
    };
    this.opts.fontString.length ? this.setFont(this.opts.fontString) : f()
}
function Postcard(a, b) {
    var c = {
        height: "",
        width: "",
        proxyURL: SERVER_URL + "image_proxy.php",
        filename: "yourpostcard.png",
        renderInterval: "30",
        allowSelections: !1,
        backgroundColor: "#ffffff",
        fontFamily: "sans-serif",
        fontSize: "16px",
        fontColor: "#fff",
        fontStyle: "normal",
        fontWeight: "normal"
    }, d = {isOpera: !1, isFirefox: !1, isSafari: !1, isChrome: !1, isIE: !1};
    this.elm = a, this.opts = _extend({}, c, b), this.height = this.opts.height = this.elm.height, this.width = this.opts.width = this.elm.width, this.startingZindex = 1, this.ctx = this.elm.getContext("2d"), this.browser = d, this.browser.isOpera = !(!window.opera || !window.opera.version), this.browser.isFirefox = _testCSS("MozBoxSizing"), this.browser.isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf("Constructor") > 0, this.browser.isChrome = !this.browser.isSafari && _testCSS("WebkitTransform"), this.browser.isIE = _testCSS("msTransform"), document.defaultView && document.defaultView.getComputedStyle && (this.stylePaddingLeft = parseInt(document.defaultView.getComputedStyle(this.elm, null).paddingLeft, 10) || 0, this.stylePaddingTop = parseInt(document.defaultView.getComputedStyle(this.elm, null).paddingTop, 10) || 0, this.styleBorderLeft = parseInt(document.defaultView.getComputedStyle(this.elm, null).borderLeftWidth, 10) || 0, this.styleBorderTop = parseInt(document.defaultView.getComputedStyle(this.elm, null).borderTopWidth, 10) || 0);
    var e = document.body.parentNode;
    this.htmlTop = e.offsetTop, this.htmlLeft = e.offsetLeft, this.valid = !1, this.dragging = !1, this.selection = null, this.dragoffx = 0, this.dragoffy = 0;
    var f = this;
    PostcardImageObject.prototype.proxyURL = this.opts.proxyURL, JSONP.init({
        error: function (a) {
            console.error("Failed to load : " + a.url)
        }
    }), this.renderingStack = new OrderedMap, setInterval(function () {
        f.render()
    }, f.opts.renderInterval), this.background = this.addObject("__background__", 0, {
        w: this.width,
        h: this.height,
        fill: this.opts.backgroundColor
    }), this.elm.addEventListener("forcerender", function (a) {
        f.triggerRefresh()
    }), this.elm.addEventListener("selectstart", function (a) {
        return a.preventDefault(), !1
    }, !1), this.elm.addEventListener("mousedown", function (a) {
        f.dragging = !0, f.opts.allowSelections && h(a)
    }, !1), this.elm.addEventListener("mousemove", function (a) {
        f.opts.allowSelections && i(a)
    }, !0), this.elm.addEventListener("mouseup", function (a) {
        f.dragging = !1
    }, !0);
    var g = function (a) {
        var b, c, d = f.elm, e = 0, g = 0;
        if (void 0 !== d.offsetParent)do e += d.offsetLeft, g += d.offsetTop; while (d = d.offsetParent);
        return e += f.stylePaddingLeft + f.styleBorderLeft + f.htmlLeft, g += f.stylePaddingTop + f.styleBorderTop + f.htmlTop, b = a.pageX - e, c = a.pageY - g, {
            x: b,
            y: c
        }
    }, h = function (a) {
        var b = g(a), c = b.x, d = b.y, e = 0, h = null;
        return f.renderingStack.forEach(function (a, b, f) {
            f.contains(c, d) && b >= e && (h = f)
        }), h ? (f.dragoffx = b.x - h.x, f.dragoffy = b.y - h.y, f.selection = h, void(f.valid = !1)) : void(f.selection && (f.selection = null, f.valid = !1))
    }, i = function (a) {
        if (f.dragging) {
            var b = g(a);
            f.selection.x = b.x - f.dragoffx, f.selection.y = b.y - f.dragoffy, f.valid = !1
        }
    };
    this.onMouseDown = function (a) {
        this.userMouseDown = function (b) {
            var c = g(b);
            a(c.x, c.y)
        }, this.elm.addEventListener("mousedown", this.userMouseDown, !1)
    }, this.onMouseMove = function (a) {
        this.userMouseMove = function (b) {
            var c = g(b);
            a(c.x, c.y)
        }, this.elm.addEventListener("mousemove", this.userMouseMove, !0)
    }, this.onMouseUp = function (a) {
        this.userMouseUp = function (b) {
            var c = g(b);
            a(c.x, c.y)
        }, this.elm.addEventListener("mouseup", this.userMouseUp, !0)
    }, this.clearMouseEvents = function () {
        this.userMouseDown && this.elm.removeEventListener("mousedown", this.userMouseDown, !1), this.userMouseMove && this.elm.removeEventListener("mousemove", this.userMouseMove, !0), this.userMouseUp && this.elm.removeEventListener("mouseup", this.userMouseUp, !0)
    }
}
if (function (global, factory) {
        "use strict";
        "object" == typeof module && "object" == typeof module.exports ? module.exports = global.document ? factory(global, !0) : function (w) {
                    if (!w.document)throw new Error("jQuery requires a window with a document");
                    return factory(w)
                } : factory(global)
    }("undefined" != typeof window ? window : this, function (window, noGlobal) {
        "use strict";
        function DOMEval(code, doc) {
            doc = doc || document;
            var script = doc.createElement("script");
            script.text = code, doc.head.appendChild(script).parentNode.removeChild(script)
        }

        function isArrayLike(obj) {
            var length = !!obj && "length" in obj && obj.length, type = jQuery.type(obj);
            return "function" === type || jQuery.isWindow(obj) ? !1 : "array" === type || 0 === length || "number" == typeof length && length > 0 && length - 1 in obj
        }

        function winnow(elements, qualifier, not) {
            if (jQuery.isFunction(qualifier))return jQuery.grep(elements, function (elem, i) {
                return !!qualifier.call(elem, i, elem) !== not
            });
            if (qualifier.nodeType)return jQuery.grep(elements, function (elem) {
                return elem === qualifier !== not
            });
            if ("string" == typeof qualifier) {
                if (risSimple.test(qualifier))return jQuery.filter(qualifier, elements, not);
                qualifier = jQuery.filter(qualifier, elements)
            }
            return jQuery.grep(elements, function (elem) {
                return indexOf.call(qualifier, elem) > -1 !== not && 1 === elem.nodeType
            })
        }

        function sibling(cur, dir) {
            for (; (cur = cur[dir]) && 1 !== cur.nodeType;);
            return cur
        }

        function createOptions(options) {
            var object = {};
            return jQuery.each(options.match(rnotwhite) || [], function (_, flag) {
                object[flag] = !0
            }), object
        }

        function Identity(v) {
            return v
        }

        function Thrower(ex) {
            throw ex
        }

        function adoptValue(value, resolve, reject) {
            var method;
            try {
                value && jQuery.isFunction(method = value.promise) ? method.call(value).done(resolve).fail(reject) : value && jQuery.isFunction(method = value.then) ? method.call(value, resolve, reject) : resolve.call(void 0, value)
            } catch (value) {
                reject.call(void 0, value)
            }
        }

        function completed() {
            document.removeEventListener("DOMContentLoaded", completed), window.removeEventListener("load", completed), jQuery.ready()
        }

        function Data() {
            this.expando = jQuery.expando + Data.uid++
        }

        function dataAttr(elem, key, data) {
            var name;
            if (void 0 === data && 1 === elem.nodeType)if (name = "data-" + key.replace(rmultiDash, "-$&").toLowerCase(), data = elem.getAttribute(name), "string" == typeof data) {
                try {
                    data = "true" === data ? !0 : "false" === data ? !1 : "null" === data ? null : +data + "" === data ? +data : rbrace.test(data) ? JSON.parse(data) : data
                } catch (e) {
                }
                dataUser.set(elem, key, data)
            } else data = void 0;
            return data
        }

        function adjustCSS(elem, prop, valueParts, tween) {
            var adjusted, scale = 1, maxIterations = 20, currentValue = tween ? function () {
                    return tween.cur()
                } : function () {
                    return jQuery.css(elem, prop, "")
                }, initial = currentValue(), unit = valueParts && valueParts[3] || (jQuery.cssNumber[prop] ? "" : "px"), initialInUnit = (jQuery.cssNumber[prop] || "px" !== unit && +initial) && rcssNum.exec(jQuery.css(elem, prop));
            if (initialInUnit && initialInUnit[3] !== unit) {
                unit = unit || initialInUnit[3], valueParts = valueParts || [], initialInUnit = +initial || 1;
                do scale = scale || ".5", initialInUnit /= scale, jQuery.style(elem, prop, initialInUnit + unit); while (scale !== (scale = currentValue() / initial) && 1 !== scale && --maxIterations)
            }
            return valueParts && (initialInUnit = +initialInUnit || +initial || 0, adjusted = valueParts[1] ? initialInUnit + (valueParts[1] + 1) * valueParts[2] : +valueParts[2], tween && (tween.unit = unit, tween.start = initialInUnit, tween.end = adjusted)), adjusted
        }

        function getDefaultDisplay(elem) {
            var temp, doc = elem.ownerDocument, nodeName = elem.nodeName, display = defaultDisplayMap[nodeName];
            return display ? display : (temp = doc.body.appendChild(doc.createElement(nodeName)), display = jQuery.css(temp, "display"), temp.parentNode.removeChild(temp), "none" === display && (display = "block"), defaultDisplayMap[nodeName] = display, display)
        }

        function showHide(elements, show) {
            for (var display, elem, values = [], index = 0, length = elements.length; length > index; index++)elem = elements[index], elem.style && (display = elem.style.display, show ? ("none" === display && (values[index] = dataPriv.get(elem, "display") || null, values[index] || (elem.style.display = "")), "" === elem.style.display && isHiddenWithinTree(elem) && (values[index] = getDefaultDisplay(elem))) : "none" !== display && (values[index] = "none", dataPriv.set(elem, "display", display)));
            for (index = 0; length > index; index++)null != values[index] && (elements[index].style.display = values[index]);
            return elements
        }

        function getAll(context, tag) {
            var ret = "undefined" != typeof context.getElementsByTagName ? context.getElementsByTagName(tag || "*") : "undefined" != typeof context.querySelectorAll ? context.querySelectorAll(tag || "*") : [];
            return void 0 === tag || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], ret) : ret
        }

        function setGlobalEval(elems, refElements) {
            for (var i = 0, l = elems.length; l > i; i++)dataPriv.set(elems[i], "globalEval", !refElements || dataPriv.get(refElements[i], "globalEval"))
        }

        function buildFragment(elems, context, scripts, selection, ignored) {
            for (var elem, tmp, tag, wrap, contains, j, fragment = context.createDocumentFragment(), nodes = [], i = 0, l = elems.length; l > i; i++)if (elem = elems[i], elem || 0 === elem)if ("object" === jQuery.type(elem)) jQuery.merge(nodes, elem.nodeType ? [elem] : elem); else if (rhtml.test(elem)) {
                for (tmp = tmp || fragment.appendChild(context.createElement("div")), tag = (rtagName.exec(elem) || ["", ""])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + jQuery.htmlPrefilter(elem) + wrap[2], j = wrap[0]; j--;)tmp = tmp.lastChild;
                jQuery.merge(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = ""
            } else nodes.push(context.createTextNode(elem));
            for (fragment.textContent = "", i = 0; elem = nodes[i++];)if (selection && jQuery.inArray(elem, selection) > -1) ignored && ignored.push(elem); else if (contains = jQuery.contains(elem.ownerDocument, elem), tmp = getAll(fragment.appendChild(elem), "script"), contains && setGlobalEval(tmp), scripts)for (j = 0; elem = tmp[j++];)rscriptType.test(elem.type || "") && scripts.push(elem);
            return fragment
        }

        function returnTrue() {
            return !0
        }

        function returnFalse() {
            return !1
        }

        function safeActiveElement() {
            try {
                return document.activeElement
            } catch (err) {
            }
        }

        function on(elem, types, selector, data, fn, one) {
            var origFn, type;
            if ("object" == typeof types) {
                "string" != typeof selector && (data = data || selector, selector = void 0);
                for (type in types)on(elem, type, selector, data, types[type], one);
                return elem
            }
            if (null == data && null == fn ? (fn = selector, data = selector = void 0) : null == fn && ("string" == typeof selector ? (fn = data, data = void 0) : (fn = data, data = selector, selector = void 0)), fn === !1) fn = returnFalse; else if (!fn)return elem;
            return 1 === one && (origFn = fn, fn = function (event) {
                return jQuery().off(event), origFn.apply(this, arguments)
            }, fn.guid = origFn.guid || (origFn.guid = jQuery.guid++)), elem.each(function () {
                jQuery.event.add(this, types, fn, data, selector)
            })
        }

        function manipulationTarget(elem, content) {
            return jQuery.nodeName(elem, "table") && jQuery.nodeName(11 !== content.nodeType ? content : content.firstChild, "tr") ? elem.getElementsByTagName("tbody")[0] || elem : elem
        }

        function disableScript(elem) {
            return elem.type = (null !== elem.getAttribute("type")) + "/" + elem.type, elem
        }

        function restoreScript(elem) {
            var match = rscriptTypeMasked.exec(elem.type);
            return match ? elem.type = match[1] : elem.removeAttribute("type"), elem
        }

        function cloneCopyEvent(src, dest) {
            var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;
            if (1 === dest.nodeType) {
                if (dataPriv.hasData(src) && (pdataOld = dataPriv.access(src), pdataCur = dataPriv.set(dest, pdataOld), events = pdataOld.events)) {
                    delete pdataCur.handle, pdataCur.events = {};
                    for (type in events)for (i = 0, l = events[type].length; l > i; i++)jQuery.event.add(dest, type, events[type][i])
                }
                dataUser.hasData(src) && (udataOld = dataUser.access(src), udataCur = jQuery.extend({}, udataOld), dataUser.set(dest, udataCur))
            }
        }

        function fixInput(src, dest) {
            var nodeName = dest.nodeName.toLowerCase();
            "input" === nodeName && rcheckableType.test(src.type) ? dest.checked = src.checked : ("input" === nodeName || "textarea" === nodeName) && (dest.defaultValue = src.defaultValue)
        }

        function domManip(collection, args, callback, ignored) {
            args = concat.apply([], args);
            var fragment, first, scripts, hasScripts, node, doc, i = 0, l = collection.length, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
            if (isFunction || l > 1 && "string" == typeof value && !support.checkClone && rchecked.test(value))return collection.each(function (index) {
                var self = collection.eq(index);
                isFunction && (args[0] = value.call(this, index, self.html())), domManip(self, args, callback, ignored)
            });
            if (l && (fragment = buildFragment(args, collection[0].ownerDocument, !1, collection, ignored), first = fragment.firstChild, 1 === fragment.childNodes.length && (fragment = first), first || ignored)) {
                for (scripts = jQuery.map(getAll(fragment, "script"), disableScript), hasScripts = scripts.length; l > i; i++)node = fragment, i !== iNoClone && (node = jQuery.clone(node, !0, !0), hasScripts && jQuery.merge(scripts, getAll(node, "script"))), callback.call(collection[i], node, i);
                if (hasScripts)for (doc = scripts[scripts.length - 1].ownerDocument, jQuery.map(scripts, restoreScript), i = 0; hasScripts > i; i++)node = scripts[i], rscriptType.test(node.type || "") && !dataPriv.access(node, "globalEval") && jQuery.contains(doc, node) && (node.src ? jQuery._evalUrl && jQuery._evalUrl(node.src) : DOMEval(node.textContent.replace(rcleanScript, ""), doc))
            }
            return collection
        }

        function remove(elem, selector, keepData) {
            for (var node, nodes = selector ? jQuery.filter(selector, elem) : elem, i = 0; null != (node = nodes[i]); i++)keepData || 1 !== node.nodeType || jQuery.cleanData(getAll(node)), node.parentNode && (keepData && jQuery.contains(node.ownerDocument, node) && setGlobalEval(getAll(node, "script")), node.parentNode.removeChild(node));
            return elem
        }

        function curCSS(elem, name, computed) {
            var width, minWidth, maxWidth, ret, style = elem.style;
            return computed = computed || getStyles(elem), computed && (ret = computed.getPropertyValue(name) || computed[name], "" !== ret || jQuery.contains(elem.ownerDocument, elem) || (ret = jQuery.style(elem, name)), !support.pixelMarginRight() && rnumnonpx.test(ret) && rmargin.test(name) && (width = style.width, minWidth = style.minWidth, maxWidth = style.maxWidth, style.minWidth = style.maxWidth = style.width = ret, ret = computed.width, style.width = width, style.minWidth = minWidth, style.maxWidth = maxWidth)), void 0 !== ret ? ret + "" : ret
        }

        function addGetHookIf(conditionFn, hookFn) {
            return {
                get: function () {
                    return conditionFn() ? void delete this.get : (this.get = hookFn).apply(this, arguments)
                }
            }
        }

        function vendorPropName(name) {
            if (name in emptyStyle)return name;
            for (var capName = name[0].toUpperCase() + name.slice(1), i = cssPrefixes.length; i--;)if (name = cssPrefixes[i] + capName, name in emptyStyle)return name
        }

        function setPositiveNumber(elem, value, subtract) {
            var matches = rcssNum.exec(value);
            return matches ? Math.max(0, matches[2] - (subtract || 0)) + (matches[3] || "px") : value
        }

        function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
            for (var i = extra === (isBorderBox ? "border" : "content") ? 4 : "width" === name ? 1 : 0, val = 0; 4 > i; i += 2)"margin" === extra && (val += jQuery.css(elem, extra + cssExpand[i], !0, styles)), isBorderBox ? ("content" === extra && (val -= jQuery.css(elem, "padding" + cssExpand[i], !0, styles)), "margin" !== extra && (val -= jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles))) : (val += jQuery.css(elem, "padding" + cssExpand[i], !0, styles), "padding" !== extra && (val += jQuery.css(elem, "border" + cssExpand[i] + "Width", !0, styles)));
            return val
        }

        function getWidthOrHeight(elem, name, extra) {
            var val, valueIsBorderBox = !0, styles = getStyles(elem), isBorderBox = "border-box" === jQuery.css(elem, "boxSizing", !1, styles);
            if (elem.getClientRects().length && (val = elem.getBoundingClientRect()[name]), 0 >= val || null == val) {
                if (val = curCSS(elem, name, styles), (0 > val || null == val) && (val = elem.style[name]), rnumnonpx.test(val))return val;
                valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]), val = parseFloat(val) || 0
            }
            return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? "border" : "content"), valueIsBorderBox, styles) + "px"
        }

        function Tween(elem, options, prop, end, easing) {
            return new Tween.prototype.init(elem, options, prop, end, easing)
        }

        function raf() {
            timerId && (window.requestAnimationFrame(raf), jQuery.fx.tick())
        }

        function createFxNow() {
            return window.setTimeout(function () {
                fxNow = void 0
            }), fxNow = jQuery.now()
        }

        function genFx(type, includeWidth) {
            var which, i = 0, attrs = {height: type};
            for (includeWidth = includeWidth ? 1 : 0; 4 > i; i += 2 - includeWidth)which = cssExpand[i], attrs["margin" + which] = attrs["padding" + which] = type;
            return includeWidth && (attrs.opacity = attrs.width = type), attrs
        }

        function createTween(value, prop, animation) {
            for (var tween, collection = (Animation.tweeners[prop] || []).concat(Animation.tweeners["*"]), index = 0, length = collection.length; length > index; index++)if (tween = collection[index].call(animation, prop, value))return tween
        }

        function defaultPrefilter(elem, props, opts) {
            var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display, isBox = "width" in props || "height" in props, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHiddenWithinTree(elem), dataShow = dataPriv.get(elem, "fxshow");
            opts.queue || (hooks = jQuery._queueHooks(elem, "fx"), null == hooks.unqueued && (hooks.unqueued = 0, oldfire = hooks.empty.fire, hooks.empty.fire = function () {
                hooks.unqueued || oldfire()
            }), hooks.unqueued++, anim.always(function () {
                anim.always(function () {
                    hooks.unqueued--, jQuery.queue(elem, "fx").length || hooks.empty.fire()
                })
            }));
            for (prop in props)if (value = props[prop], rfxtypes.test(value)) {
                if (delete props[prop], toggle = toggle || "toggle" === value, value === (hidden ? "hide" : "show")) {
                    if ("show" !== value || !dataShow || void 0 === dataShow[prop])continue;
                    hidden = !0
                }
                orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop)
            }
            if (propTween = !jQuery.isEmptyObject(props), propTween || !jQuery.isEmptyObject(orig)) {
                isBox && 1 === elem.nodeType && (opts.overflow = [style.overflow, style.overflowX, style.overflowY], restoreDisplay = dataShow && dataShow.display, null == restoreDisplay && (restoreDisplay = dataPriv.get(elem, "display")), display = jQuery.css(elem, "display"), "none" === display && (restoreDisplay ? display = restoreDisplay : (showHide([elem], !0), restoreDisplay = elem.style.display || restoreDisplay, display = jQuery.css(elem, "display"), showHide([elem]))), ("inline" === display || "inline-block" === display && null != restoreDisplay) && "none" === jQuery.css(elem, "float") && (propTween || (anim.done(function () {
                    style.display = restoreDisplay
                }), null == restoreDisplay && (display = style.display, restoreDisplay = "none" === display ? "" : display)), style.display = "inline-block")), opts.overflow && (style.overflow = "hidden", anim.always(function () {
                    style.overflow = opts.overflow[0], style.overflowX = opts.overflow[1], style.overflowY = opts.overflow[2]
                })), propTween = !1;
                for (prop in orig)propTween || (dataShow ? "hidden" in dataShow && (hidden = dataShow.hidden) : dataShow = dataPriv.access(elem, "fxshow", {display: restoreDisplay}), toggle && (dataShow.hidden = !hidden), hidden && showHide([elem], !0), anim.done(function () {
                    hidden || showHide([elem]), dataPriv.remove(elem, "fxshow");
                    for (prop in orig)jQuery.style(elem, prop, orig[prop])
                })), propTween = createTween(hidden ? dataShow[prop] : 0, prop, anim), prop in dataShow || (dataShow[prop] = propTween.start, hidden && (propTween.end = propTween.start, propTween.start = 0))
            }
        }

        function propFilter(props, specialEasing) {
            var index, name, easing, value, hooks;
            for (index in props)if (name = jQuery.camelCase(index), easing = specialEasing[name], value = props[index], jQuery.isArray(value) && (easing = value[1], value = props[index] = value[0]), index !== name && (props[name] = value, delete props[index]), hooks = jQuery.cssHooks[name], hooks && "expand" in hooks) {
                value = hooks.expand(value), delete props[name];
                for (index in value)index in props || (props[index] = value[index], specialEasing[index] = easing)
            } else specialEasing[name] = easing
        }

        function Animation(elem, properties, options) {
            var result, stopped, index = 0, length = Animation.prefilters.length, deferred = jQuery.Deferred().always(function () {
                delete tick.elem
            }), tick = function () {
                if (stopped)return !1;
                for (var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length; length > index; index++)animation.tweens[index].run(percent);
                return deferred.notifyWith(elem, [animation, percent, remaining]), 1 > percent && length ? remaining : (deferred.resolveWith(elem, [animation]), !1)
            }, animation = deferred.promise({
                elem: elem,
                props: jQuery.extend({}, properties),
                opts: jQuery.extend(!0, {specialEasing: {}, easing: jQuery.easing._default}, options),
                originalProperties: properties,
                originalOptions: options,
                startTime: fxNow || createFxNow(),
                duration: options.duration,
                tweens: [],
                createTween: function (prop, end) {
                    var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
                    return animation.tweens.push(tween), tween
                },
                stop: function (gotoEnd) {
                    var index = 0, length = gotoEnd ? animation.tweens.length : 0;
                    if (stopped)return this;
                    for (stopped = !0; length > index; index++)animation.tweens[index].run(1);
                    return gotoEnd ? (deferred.notifyWith(elem, [animation, 1, 0]), deferred.resolveWith(elem, [animation, gotoEnd])) : deferred.rejectWith(elem, [animation, gotoEnd]), this
                }
            }), props = animation.props;
            for (propFilter(props, animation.opts.specialEasing); length > index; index++)if (result = Animation.prefilters[index].call(animation, elem, props, animation.opts))return jQuery.isFunction(result.stop) && (jQuery._queueHooks(animation.elem, animation.opts.queue).stop = jQuery.proxy(result.stop, result)), result;
            return jQuery.map(props, createTween, animation), jQuery.isFunction(animation.opts.start) && animation.opts.start.call(elem, animation), jQuery.fx.timer(jQuery.extend(tick, {
                elem: elem,
                anim: animation,
                queue: animation.opts.queue
            })), animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always)
        }

        function getClass(elem) {
            return elem.getAttribute && elem.getAttribute("class") || ""
        }

        function buildParams(prefix, obj, traditional, add) {
            var name;
            if (jQuery.isArray(obj)) jQuery.each(obj, function (i, v) {
                traditional || rbracket.test(prefix) ? add(prefix, v) : buildParams(prefix + "[" + ("object" == typeof v && null != v ? i : "") + "]", v, traditional, add)
            }); else if (traditional || "object" !== jQuery.type(obj)) add(prefix, obj); else for (name in obj)buildParams(prefix + "[" + name + "]", obj[name], traditional, add)
        }

        function addToPrefiltersOrTransports(structure) {
            return function (dataTypeExpression, func) {
                "string" != typeof dataTypeExpression && (func = dataTypeExpression, dataTypeExpression = "*");
                var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
                if (jQuery.isFunction(func))for (; dataType = dataTypes[i++];)"+" === dataType[0] ? (dataType = dataType.slice(1) || "*", (structure[dataType] = structure[dataType] || []).unshift(func)) : (structure[dataType] = structure[dataType] || []).push(func)
            }
        }

        function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
            function inspect(dataType) {
                var selected;
                return inspected[dataType] = !0, jQuery.each(structure[dataType] || [], function (_, prefilterOrFactory) {
                    var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
                    return "string" != typeof dataTypeOrTransport || seekingTransport || inspected[dataTypeOrTransport] ? seekingTransport ? !(selected = dataTypeOrTransport) : void 0 : (options.dataTypes.unshift(dataTypeOrTransport), inspect(dataTypeOrTransport), !1)
                }), selected
            }

            var inspected = {}, seekingTransport = structure === transports;
            return inspect(options.dataTypes[0]) || !inspected["*"] && inspect("*")
        }

        function ajaxExtend(target, src) {
            var key, deep, flatOptions = jQuery.ajaxSettings.flatOptions || {};
            for (key in src)void 0 !== src[key] && ((flatOptions[key] ? target : deep || (deep = {}))[key] = src[key]);
            return deep && jQuery.extend(!0, target, deep), target
        }

        function ajaxHandleResponses(s, jqXHR, responses) {
            for (var ct, type, finalDataType, firstDataType, contents = s.contents, dataTypes = s.dataTypes; "*" === dataTypes[0];)dataTypes.shift(), void 0 === ct && (ct = s.mimeType || jqXHR.getResponseHeader("Content-Type"));
            if (ct)for (type in contents)if (contents[type] && contents[type].test(ct)) {
                dataTypes.unshift(type);
                break
            }
            if (dataTypes[0] in responses) finalDataType = dataTypes[0]; else {
                for (type in responses) {
                    if (!dataTypes[0] || s.converters[type + " " + dataTypes[0]]) {
                        finalDataType = type;
                        break
                    }
                    firstDataType || (firstDataType = type)
                }
                finalDataType = finalDataType || firstDataType
            }
            return finalDataType ? (finalDataType !== dataTypes[0] && dataTypes.unshift(finalDataType), responses[finalDataType]) : void 0
        }

        function ajaxConvert(s, response, jqXHR, isSuccess) {
            var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
            if (dataTypes[1])for (conv in s.converters)converters[conv.toLowerCase()] = s.converters[conv];
            for (current = dataTypes.shift(); current;)if (s.responseFields[current] && (jqXHR[s.responseFields[current]] = response), !prev && isSuccess && s.dataFilter && (response = s.dataFilter(response, s.dataType)), prev = current, current = dataTypes.shift())if ("*" === current) current = prev; else if ("*" !== prev && prev !== current) {
                if (conv = converters[prev + " " + current] || converters["* " + current], !conv)for (conv2 in converters)if (tmp = conv2.split(" "), tmp[1] === current && (conv = converters[prev + " " + tmp[0]] || converters["* " + tmp[0]])) {
                    conv === !0 ? conv = converters[conv2] : converters[conv2] !== !0 && (current = tmp[0], dataTypes.unshift(tmp[1]));
                    break
                }
                if (conv !== !0)if (conv && s["throws"]) response = conv(response); else try {
                    response = conv(response)
                } catch (e) {
                    return {state: "parsererror", error: conv ? e : "No conversion from " + prev + " to " + current}
                }
            }
            return {state: "success", data: response}
        }

        function getWindow(elem) {
            return jQuery.isWindow(elem) ? elem : 9 === elem.nodeType && elem.defaultView
        }

        var arr = [], document = window.document, getProto = Object.getPrototypeOf, slice = arr.slice, concat = arr.concat, push = arr.push, indexOf = arr.indexOf, class2type = {}, toString = class2type.toString, hasOwn = class2type.hasOwnProperty, fnToString = hasOwn.toString, ObjectFunctionString = fnToString.call(Object), support = {}, version = "3.1.0", jQuery = function (selector, context) {
            return new jQuery.fn.init(selector, context)
        }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([a-z])/g, fcamelCase = function (all, letter) {
            return letter.toUpperCase()
        };
        jQuery.fn = jQuery.prototype = {
            jquery: version, constructor: jQuery, length: 0, toArray: function () {
                return slice.call(this)
            }, get: function (num) {
                return null != num ? 0 > num ? this[num + this.length] : this[num] : slice.call(this)
            }, pushStack: function (elems) {
                var ret = jQuery.merge(this.constructor(), elems);
                return ret.prevObject = this, ret
            }, each: function (callback) {
                return jQuery.each(this, callback)
            }, map: function (callback) {
                return this.pushStack(jQuery.map(this, function (elem, i) {
                    return callback.call(elem, i, elem)
                }))
            }, slice: function () {
                return this.pushStack(slice.apply(this, arguments))
            }, first: function () {
                return this.eq(0)
            }, last: function () {
                return this.eq(-1)
            }, eq: function (i) {
                var len = this.length, j = +i + (0 > i ? len : 0);
                return this.pushStack(j >= 0 && len > j ? [this[j]] : [])
            }, end: function () {
                return this.prevObject || this.constructor()
            }, push: push, sort: arr.sort, splice: arr.splice
        }, jQuery.extend = jQuery.fn.extend = function () {
            var options, name, src, copy, copyIsArray, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = !1;
            for ("boolean" == typeof target && (deep = target, target = arguments[i] || {}, i++), "object" == typeof target || jQuery.isFunction(target) || (target = {}), i === length && (target = this, i--); length > i; i++)if (null != (options = arguments[i]))for (name in options)src = target[name], copy = options[name], target !== copy && (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy))) ? (copyIsArray ? (copyIsArray = !1, clone = src && jQuery.isArray(src) ? src : []) : clone = src && jQuery.isPlainObject(src) ? src : {}, target[name] = jQuery.extend(deep, clone, copy)) : void 0 !== copy && (target[name] = copy));
            return target
        }, jQuery.extend({
            expando: "jQuery" + (version + Math.random()).replace(/\D/g, ""),
            isReady: !0,
            error: function (msg) {
                throw new Error(msg)
            },
            noop: function () {
            },
            isFunction: function (obj) {
                return "function" === jQuery.type(obj)
            },
            isArray: Array.isArray,
            isWindow: function (obj) {
                return null != obj && obj === obj.window
            },
            isNumeric: function (obj) {
                var type = jQuery.type(obj);
                return ("number" === type || "string" === type) && !isNaN(obj - parseFloat(obj))
            },
            isPlainObject: function (obj) {
                var proto, Ctor;
                return obj && "[object Object]" === toString.call(obj) ? (proto = getProto(obj)) ? (Ctor = hasOwn.call(proto, "constructor") && proto.constructor, "function" == typeof Ctor && fnToString.call(Ctor) === ObjectFunctionString) : !0 : !1
            },
            isEmptyObject: function (obj) {
                var name;
                for (name in obj)return !1;
                return !0
            },
            type: function (obj) {
                return null == obj ? obj + "" : "object" == typeof obj || "function" == typeof obj ? class2type[toString.call(obj)] || "object" : typeof obj
            },
            globalEval: function (code) {
                DOMEval(code)
            },
            camelCase: function (string) {
                return string.replace(rmsPrefix, "ms-").replace(rdashAlpha, fcamelCase)
            },
            nodeName: function (elem, name) {
                return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase()
            },
            each: function (obj, callback) {
                var length, i = 0;
                if (isArrayLike(obj))for (length = obj.length; length > i && callback.call(obj[i], i, obj[i]) !== !1; i++); else for (i in obj)if (callback.call(obj[i], i, obj[i]) === !1)break;
                return obj
            },
            trim: function (text) {
                return null == text ? "" : (text + "").replace(rtrim, "")
            },
            makeArray: function (arr, results) {
                var ret = results || [];
                return null != arr && (isArrayLike(Object(arr)) ? jQuery.merge(ret, "string" == typeof arr ? [arr] : arr) : push.call(ret, arr)), ret
            },
            inArray: function (elem, arr, i) {
                return null == arr ? -1 : indexOf.call(arr, elem, i)
            },
            merge: function (first, second) {
                for (var len = +second.length, j = 0, i = first.length; len > j; j++)first[i++] = second[j];
                return first.length = i, first
            },
            grep: function (elems, callback, invert) {
                for (var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert; length > i; i++)callbackInverse = !callback(elems[i], i), callbackInverse !== callbackExpect && matches.push(elems[i]);
                return matches
            },
            map: function (elems, callback, arg) {
                var length, value, i = 0, ret = [];
                if (isArrayLike(elems))for (length = elems.length; length > i; i++)value = callback(elems[i], i, arg), null != value && ret.push(value); else for (i in elems)value = callback(elems[i], i, arg), null != value && ret.push(value);
                return concat.apply([], ret)
            },
            guid: 1,
            proxy: function (fn, context) {
                var tmp, args, proxy;
                return "string" == typeof context && (tmp = fn[context], context = fn, fn = tmp), jQuery.isFunction(fn) ? (args = slice.call(arguments, 2), proxy = function () {
                        return fn.apply(context || this, args.concat(slice.call(arguments)))
                    }, proxy.guid = fn.guid = fn.guid || jQuery.guid++, proxy) : void 0
            },
            now: Date.now,
            support: support
        }), "function" == typeof Symbol && (jQuery.fn[Symbol.iterator] = arr[Symbol.iterator]), jQuery.each("Boolean Number String Function Array Date RegExp Object Error Symbol".split(" "), function (i, name) {
            class2type["[object " + name + "]"] = name.toLowerCase()
        });
        var Sizzle = function (window) {
            function Sizzle(selector, context, results, seed) {
                var m, i, elem, nid, match, groups, newSelector, newContext = context && context.ownerDocument, nodeType = context ? context.nodeType : 9;
                if (results = results || [], "string" != typeof selector || !selector || 1 !== nodeType && 9 !== nodeType && 11 !== nodeType)return results;
                if (!seed && ((context ? context.ownerDocument || context : preferredDoc) !== document && setDocument(context), context = context || document, documentIsHTML)) {
                    if (11 !== nodeType && (match = rquickExpr.exec(selector)))if (m = match[1]) {
                        if (9 === nodeType) {
                            if (!(elem = context.getElementById(m)))return results;
                            if (elem.id === m)return results.push(elem), results
                        } else if (newContext && (elem = newContext.getElementById(m)) && contains(context, elem) && elem.id === m)return results.push(elem), results
                    } else {
                        if (match[2])return push.apply(results, context.getElementsByTagName(selector)), results;
                        if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName)return push.apply(results, context.getElementsByClassName(m)), results
                    }
                    if (support.qsa && !compilerCache[selector + " "] && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
                        if (1 !== nodeType) newContext = context, newSelector = selector; else if ("object" !== context.nodeName.toLowerCase()) {
                            for ((nid = context.getAttribute("id")) ? nid = nid.replace(rcssescape, fcssescape) : context.setAttribute("id", nid = expando), groups = tokenize(selector), i = groups.length; i--;)groups[i] = "#" + nid + " " + toSelector(groups[i]);
                            newSelector = groups.join(","), newContext = rsibling.test(selector) && testContext(context.parentNode) || context
                        }
                        if (newSelector)try {
                            return push.apply(results, newContext.querySelectorAll(newSelector)), results
                        } catch (qsaError) {
                        } finally {
                            nid === expando && context.removeAttribute("id")
                        }
                    }
                }
                return select(selector.replace(rtrim, "$1"), context, results, seed)
            }

            function createCache() {
                function cache(key, value) {
                    return keys.push(key + " ") > Expr.cacheLength && delete cache[keys.shift()], cache[key + " "] = value
                }

                var keys = [];
                return cache
            }

            function markFunction(fn) {
                return fn[expando] = !0, fn
            }

            function assert(fn) {
                var el = document.createElement("fieldset");
                try {
                    return !!fn(el)
                } catch (e) {
                    return !1
                } finally {
                    el.parentNode && el.parentNode.removeChild(el), el = null
                }
            }

            function addHandle(attrs, handler) {
                for (var arr = attrs.split("|"), i = arr.length; i--;)Expr.attrHandle[arr[i]] = handler
            }

            function siblingCheck(a, b) {
                var cur = b && a, diff = cur && 1 === a.nodeType && 1 === b.nodeType && a.sourceIndex - b.sourceIndex;
                if (diff)return diff;
                if (cur)for (; cur = cur.nextSibling;)if (cur === b)return -1;
                return a ? 1 : -1
            }

            function createInputPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return "input" === name && elem.type === type
                }
            }

            function createButtonPseudo(type) {
                return function (elem) {
                    var name = elem.nodeName.toLowerCase();
                    return ("input" === name || "button" === name) && elem.type === type
                }
            }

            function createDisabledPseudo(disabled) {
                return function (elem) {
                    return "label" in elem && elem.disabled === disabled || "form" in elem && elem.disabled === disabled || "form" in elem && elem.disabled === !1 && (elem.isDisabled === disabled || elem.isDisabled !== !disabled && ("label" in elem || !disabledAncestor(elem)) !== disabled)
                }
            }

            function createPositionalPseudo(fn) {
                return markFunction(function (argument) {
                    return argument = +argument, markFunction(function (seed, matches) {
                        for (var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length; i--;)seed[j = matchIndexes[i]] && (seed[j] = !(matches[j] = seed[j]))
                    })
                })
            }

            function testContext(context) {
                return context && "undefined" != typeof context.getElementsByTagName && context
            }

            function setFilters() {
            }

            function toSelector(tokens) {
                for (var i = 0, len = tokens.length, selector = ""; len > i; i++)selector += tokens[i].value;
                return selector
            }

            function addCombinator(matcher, combinator, base) {
                var dir = combinator.dir, skip = combinator.next, key = skip || dir, checkNonElements = base && "parentNode" === key, doneName = done++;
                return combinator.first ? function (elem, context, xml) {
                        for (; elem = elem[dir];)if (1 === elem.nodeType || checkNonElements)return matcher(elem, context, xml)
                    } : function (elem, context, xml) {
                        var oldCache, uniqueCache, outerCache, newCache = [dirruns, doneName];
                        if (xml) {
                            for (; elem = elem[dir];)if ((1 === elem.nodeType || checkNonElements) && matcher(elem, context, xml))return !0
                        } else for (; elem = elem[dir];)if (1 === elem.nodeType || checkNonElements)if (outerCache = elem[expando] || (elem[expando] = {}), uniqueCache = outerCache[elem.uniqueID] || (outerCache[elem.uniqueID] = {}), skip && skip === elem.nodeName.toLowerCase()) elem = elem[dir] || elem; else {
                            if ((oldCache = uniqueCache[key]) && oldCache[0] === dirruns && oldCache[1] === doneName)return newCache[2] = oldCache[2];
                            if (uniqueCache[key] = newCache, newCache[2] = matcher(elem, context, xml))return !0
                        }
                    }
            }

            function elementMatcher(matchers) {
                return matchers.length > 1 ? function (elem, context, xml) {
                        for (var i = matchers.length; i--;)if (!matchers[i](elem, context, xml))return !1;
                        return !0
                    } : matchers[0]
            }

            function multipleContexts(selector, contexts, results) {
                for (var i = 0, len = contexts.length; len > i; i++)Sizzle(selector, contexts[i], results);
                return results
            }

            function condense(unmatched, map, filter, context, xml) {
                for (var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = null != map; len > i; i++)(elem = unmatched[i]) && (!filter || filter(elem, context, xml)) && (newUnmatched.push(elem), mapped && map.push(i));
                return newUnmatched
            }

            function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
                return postFilter && !postFilter[expando] && (postFilter = setMatcher(postFilter)), postFinder && !postFinder[expando] && (postFinder = setMatcher(postFinder, postSelector)), markFunction(function (seed, results, context, xml) {
                    var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || "*", context.nodeType ? [context] : context, []), matcherIn = !preFilter || !seed && selector ? elems : condense(elems, preMap, preFilter, context, xml), matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
                    if (matcher && matcher(matcherIn, matcherOut, context, xml), postFilter)for (temp = condense(matcherOut, postMap), postFilter(temp, [], context, xml), i = temp.length; i--;)(elem = temp[i]) && (matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem));
                    if (seed) {
                        if (postFinder || preFilter) {
                            if (postFinder) {
                                for (temp = [], i = matcherOut.length; i--;)(elem = matcherOut[i]) && temp.push(matcherIn[i] = elem);
                                postFinder(null, matcherOut = [], temp, xml)
                            }
                            for (i = matcherOut.length; i--;)(elem = matcherOut[i]) && (temp = postFinder ? indexOf(seed, elem) : preMap[i]) > -1 && (seed[temp] = !(results[temp] = elem))
                        }
                    } else matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut), postFinder ? postFinder(null, results, matcherOut, xml) : push.apply(results, matcherOut)
                })
            }

            function matcherFromTokens(tokens) {
                for (var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[" "], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function (elem) {
                    return elem === checkContext
                }, implicitRelative, !0), matchAnyContext = addCombinator(function (elem) {
                    return indexOf(checkContext, elem) > -1
                }, implicitRelative, !0), matchers = [function (elem, context, xml) {
                    var ret = !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
                    return checkContext = null, ret
                }]; len > i; i++)if (matcher = Expr.relative[tokens[i].type]) matchers = [addCombinator(elementMatcher(matchers), matcher)]; else {
                    if (matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches), matcher[expando]) {
                        for (j = ++i; len > j && !Expr.relative[tokens[j].type]; j++);
                        return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value: " " === tokens[i - 2].type ? "*" : ""})).replace(rtrim, "$1"), matcher, j > i && matcherFromTokens(tokens.slice(i, j)), len > j && matcherFromTokens(tokens = tokens.slice(j)), len > j && toSelector(tokens))
                    }
                    matchers.push(matcher)
                }
                return elementMatcher(matchers)
            }

            function matcherFromGroupMatchers(elementMatchers, setMatchers) {
                var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function (seed, context, xml, results, outermost) {
                    var elem, j, matcher, matchedCount = 0, i = "0", unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find.TAG("*", outermost), dirrunsUnique = dirruns += null == contextBackup ? 1 : Math.random() || .1, len = elems.length;
                    for (outermost && (outermostContext = context === document || context || outermost); i !== len && null != (elem = elems[i]); i++) {
                        if (byElement && elem) {
                            for (j = 0, context || elem.ownerDocument === document || (setDocument(elem), xml = !documentIsHTML); matcher = elementMatchers[j++];)if (matcher(elem, context || document, xml)) {
                                results.push(elem);
                                break
                            }
                            outermost && (dirruns = dirrunsUnique)
                        }
                        bySet && ((elem = !matcher && elem) && matchedCount--, seed && unmatched.push(elem))
                    }
                    if (matchedCount += i, bySet && i !== matchedCount) {
                        for (j = 0; matcher = setMatchers[j++];)matcher(unmatched, setMatched, context, xml);
                        if (seed) {
                            if (matchedCount > 0)for (; i--;)unmatched[i] || setMatched[i] || (setMatched[i] = pop.call(results));
                            setMatched = condense(setMatched)
                        }
                        push.apply(results, setMatched), outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1 && Sizzle.uniqueSort(results)
                    }
                    return outermost && (dirruns = dirrunsUnique, outermostContext = contextBackup), unmatched
                };
                return bySet ? markFunction(superMatcher) : superMatcher
            }

            var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = "sizzle" + 1 * new Date, preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function (a, b) {
                return a === b && (hasDuplicate = !0), 0
            }, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = function (list, elem) {
                for (var i = 0, len = list.length; len > i; i++)if (list[i] === elem)return i;
                return -1
            }, booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped", whitespace = "[\\x20\\t\\r\\n\\f]", identifier = "(?:\\\\.|[\\w-]|[^\x00-\\xa0])+", attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace + "*([*^$|!~]?=)" + whitespace + "*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace + "*\\]", pseudos = ":(" + identifier + ")(?:\\((('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|.*)\\)|)", rwhitespace = new RegExp(whitespace + "+", "g"), rtrim = new RegExp("^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g"), rcomma = new RegExp("^" + whitespace + "*," + whitespace + "*"), rcombinators = new RegExp("^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*"), rattributeQuotes = new RegExp("=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g"), rpseudo = new RegExp(pseudos), ridentifier = new RegExp("^" + identifier + "$"), matchExpr = {
                ID: new RegExp("^#(" + identifier + ")"),
                CLASS: new RegExp("^\\.(" + identifier + ")"),
                TAG: new RegExp("^(" + identifier + "|[*])"),
                ATTR: new RegExp("^" + attributes),
                PSEUDO: new RegExp("^" + pseudos),
                CHILD: new RegExp("^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i"),
                bool: new RegExp("^(?:" + booleans + ")$", "i"),
                needsContext: new RegExp("^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i")
            }, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, runescape = new RegExp("\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig"), funescape = function (_, escaped, escapedWhitespace) {
                var high = "0x" + escaped - 65536;
                return high !== high || escapedWhitespace ? escaped : 0 > high ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, 1023 & high | 56320)
            }, rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\x80-\uFFFF\w-]/g, fcssescape = function (ch, asCodePoint) {
                return asCodePoint ? "\x00" === ch ? "�" : ch.slice(0, -1) + "\\" + ch.charCodeAt(ch.length - 1).toString(16) + " " : "\\" + ch
            }, unloadHandler = function () {
                setDocument()
            }, disabledAncestor = addCombinator(function (elem) {
                return elem.disabled === !0
            }, {dir: "parentNode", next: "legend"});
            try {
                push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes), arr[preferredDoc.childNodes.length].nodeType
            } catch (e) {
                push = {
                    apply: arr.length ? function (target, els) {
                            push_native.apply(target, slice.call(els))
                        } : function (target, els) {
                            for (var j = target.length, i = 0; target[j++] = els[i++];);
                            target.length = j - 1
                        }
                }
            }
            support = Sizzle.support = {}, isXML = Sizzle.isXML = function (elem) {
                var documentElement = elem && (elem.ownerDocument || elem).documentElement;
                return documentElement ? "HTML" !== documentElement.nodeName : !1
            }, setDocument = Sizzle.setDocument = function (node) {
                var hasCompare, subWindow, doc = node ? node.ownerDocument || node : preferredDoc;
                return doc !== document && 9 === doc.nodeType && doc.documentElement ? (document = doc, docElem = document.documentElement, documentIsHTML = !isXML(document), preferredDoc !== document && (subWindow = document.defaultView) && subWindow.top !== subWindow && (subWindow.addEventListener ? subWindow.addEventListener("unload", unloadHandler, !1) : subWindow.attachEvent && subWindow.attachEvent("onunload", unloadHandler)), support.attributes = assert(function (el) {
                        return el.className = "i", !el.getAttribute("className")
                    }), support.getElementsByTagName = assert(function (el) {
                        return el.appendChild(document.createComment("")), !el.getElementsByTagName("*").length
                    }), support.getElementsByClassName = rnative.test(document.getElementsByClassName), support.getById = assert(function (el) {
                        return docElem.appendChild(el).id = expando, !document.getElementsByName || !document.getElementsByName(expando).length
                    }), support.getById ? (Expr.find.ID = function (id, context) {
                            if ("undefined" != typeof context.getElementById && documentIsHTML) {
                                var m = context.getElementById(id);
                                return m ? [m] : []
                            }
                        }, Expr.filter.ID = function (id) {
                            var attrId = id.replace(runescape, funescape);
                            return function (elem) {
                                return elem.getAttribute("id") === attrId
                            }
                        }) : (delete Expr.find.ID, Expr.filter.ID = function (id) {
                            var attrId = id.replace(runescape, funescape);
                            return function (elem) {
                                var node = "undefined" != typeof elem.getAttributeNode && elem.getAttributeNode("id");
                                return node && node.value === attrId
                            }
                        }), Expr.find.TAG = support.getElementsByTagName ? function (tag, context) {
                            return "undefined" != typeof context.getElementsByTagName ? context.getElementsByTagName(tag) : support.qsa ? context.querySelectorAll(tag) : void 0
                        } : function (tag, context) {
                            var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
                            if ("*" === tag) {
                                for (; elem = results[i++];)1 === elem.nodeType && tmp.push(elem);
                                return tmp
                            }
                            return results
                        }, Expr.find.CLASS = support.getElementsByClassName && function (className, context) {
                            return "undefined" != typeof context.getElementsByClassName && documentIsHTML ? context.getElementsByClassName(className) : void 0
                        }, rbuggyMatches = [], rbuggyQSA = [], (support.qsa = rnative.test(document.querySelectorAll)) && (assert(function (el) {
                        docElem.appendChild(el).innerHTML = "<a id='" + expando + "'></a><select id='" + expando + "-\r\\' msallowcapture=''><option selected=''></option></select>", el.querySelectorAll("[msallowcapture^='']").length && rbuggyQSA.push("[*^$]=" + whitespace + "*(?:''|\"\")"), el.querySelectorAll("[selected]").length || rbuggyQSA.push("\\[" + whitespace + "*(?:value|" + booleans + ")"), el.querySelectorAll("[id~=" + expando + "-]").length || rbuggyQSA.push("~="), el.querySelectorAll(":checked").length || rbuggyQSA.push(":checked"), el.querySelectorAll("a#" + expando + "+*").length || rbuggyQSA.push(".#.+[+~]")
                    }), assert(function (el) {
                        el.innerHTML = "<a href='' disabled='disabled'></a><select disabled='disabled'><option/></select>";
                        var input = document.createElement("input");
                        input.setAttribute("type", "hidden"), el.appendChild(input).setAttribute("name", "D"), el.querySelectorAll("[name=d]").length && rbuggyQSA.push("name" + whitespace + "*[*^$|!~]?="), 2 !== el.querySelectorAll(":enabled").length && rbuggyQSA.push(":enabled", ":disabled"), docElem.appendChild(el).disabled = !0, 2 !== el.querySelectorAll(":disabled").length && rbuggyQSA.push(":enabled", ":disabled"), el.querySelectorAll("*,:x"), rbuggyQSA.push(",.*:")
                    })), (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) && assert(function (el) {
                        support.disconnectedMatch = matches.call(el, "*"), matches.call(el, "[s!='']:x"), rbuggyMatches.push("!=", pseudos)
                    }), rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join("|")), rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join("|")), hasCompare = rnative.test(docElem.compareDocumentPosition), contains = hasCompare || rnative.test(docElem.contains) ? function (a, b) {
                            var adown = 9 === a.nodeType ? a.documentElement : a, bup = b && b.parentNode;
                            return a === bup || !(!bup || 1 !== bup.nodeType || !(adown.contains ? adown.contains(bup) : a.compareDocumentPosition && 16 & a.compareDocumentPosition(bup)))
                        } : function (a, b) {
                            if (b)for (; b = b.parentNode;)if (b === a)return !0;
                            return !1
                        }, sortOrder = hasCompare ? function (a, b) {
                            if (a === b)return hasDuplicate = !0, 0;
                            var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
                            return compare ? compare : (compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1, 1 & compare || !support.sortDetached && b.compareDocumentPosition(a) === compare ? a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ? -1 : b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0 : 4 & compare ? -1 : 1)
                        } : function (a, b) {
                            if (a === b)return hasDuplicate = !0, 0;
                            var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
                            if (!aup || !bup)return a === document ? -1 : b === document ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf(sortInput, a) - indexOf(sortInput, b) : 0;
                            if (aup === bup)return siblingCheck(a, b);
                            for (cur = a; cur = cur.parentNode;)ap.unshift(cur);
                            for (cur = b; cur = cur.parentNode;)bp.unshift(cur);
                            for (; ap[i] === bp[i];)i++;
                            return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0
                        }, document) : document
            }, Sizzle.matches = function (expr, elements) {
                return Sizzle(expr, null, null, elements)
            }, Sizzle.matchesSelector = function (elem, expr) {
                if ((elem.ownerDocument || elem) !== document && setDocument(elem), expr = expr.replace(rattributeQuotes, "='$1']"), support.matchesSelector && documentIsHTML && !compilerCache[expr + " "] && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr)))try {
                    var ret = matches.call(elem, expr);
                    if (ret || support.disconnectedMatch || elem.document && 11 !== elem.document.nodeType)return ret
                } catch (e) {
                }
                return Sizzle(expr, document, null, [elem]).length > 0
            }, Sizzle.contains = function (context, elem) {
                return (context.ownerDocument || context) !== document && setDocument(context), contains(context, elem)
            }, Sizzle.attr = function (elem, name) {
                (elem.ownerDocument || elem) !== document && setDocument(elem);
                var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : void 0;
                return void 0 !== val ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
            }, Sizzle.escape = function (sel) {
                return (sel + "").replace(rcssescape, fcssescape)
            }, Sizzle.error = function (msg) {
                throw new Error("Syntax error, unrecognized expression: " + msg)
            }, Sizzle.uniqueSort = function (results) {
                var elem, duplicates = [], j = 0, i = 0;
                if (hasDuplicate = !support.detectDuplicates, sortInput = !support.sortStable && results.slice(0), results.sort(sortOrder), hasDuplicate) {
                    for (; elem = results[i++];)elem === results[i] && (j = duplicates.push(i));
                    for (; j--;)results.splice(duplicates[j], 1)
                }
                return sortInput = null, results
            }, getText = Sizzle.getText = function (elem) {
                var node, ret = "", i = 0, nodeType = elem.nodeType;
                if (nodeType) {
                    if (1 === nodeType || 9 === nodeType || 11 === nodeType) {
                        if ("string" == typeof elem.textContent)return elem.textContent;
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling)ret += getText(elem)
                    } else if (3 === nodeType || 4 === nodeType)return elem.nodeValue
                } else for (; node = elem[i++];)ret += getText(node);
                return ret
            }, Expr = Sizzle.selectors = {
                cacheLength: 50,
                createPseudo: markFunction,
                match: matchExpr,
                attrHandle: {},
                find: {},
                relative: {
                    ">": {dir: "parentNode", first: !0},
                    " ": {dir: "parentNode"},
                    "+": {dir: "previousSibling", first: !0},
                    "~": {dir: "previousSibling"}
                },
                preFilter: {
                    ATTR: function (match) {
                        return match[1] = match[1].replace(runescape, funescape), match[3] = (match[3] || match[4] || match[5] || "").replace(runescape, funescape), "~=" === match[2] && (match[3] = " " + match[3] + " "), match.slice(0, 4)
                    }, CHILD: function (match) {
                        return match[1] = match[1].toLowerCase(), "nth" === match[1].slice(0, 3) ? (match[3] || Sizzle.error(match[0]), match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * ("even" === match[3] || "odd" === match[3])), match[5] = +(match[7] + match[8] || "odd" === match[3])) : match[3] && Sizzle.error(match[0]), match
                    }, PSEUDO: function (match) {
                        var excess, unquoted = !match[6] && match[2];
                        return matchExpr.CHILD.test(match[0]) ? null : (match[3] ? match[2] = match[4] || match[5] || "" : unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, !0)) && (excess = unquoted.indexOf(")", unquoted.length - excess) - unquoted.length) && (match[0] = match[0].slice(0, excess), match[2] = unquoted.slice(0, excess)), match.slice(0, 3))
                    }
                },
                filter: {
                    TAG: function (nodeNameSelector) {
                        var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
                        return "*" === nodeNameSelector ? function () {
                                return !0
                            } : function (elem) {
                                return elem.nodeName && elem.nodeName.toLowerCase() === nodeName
                            }
                    }, CLASS: function (className) {
                        var pattern = classCache[className + " "];
                        return pattern || (pattern = new RegExp("(^|" + whitespace + ")" + className + "(" + whitespace + "|$)")) && classCache(className, function (elem) {
                                return pattern.test("string" == typeof elem.className && elem.className || "undefined" != typeof elem.getAttribute && elem.getAttribute("class") || "")
                            })
                    }, ATTR: function (name, operator, check) {
                        return function (elem) {
                            var result = Sizzle.attr(elem, name);
                            return null == result ? "!=" === operator : operator ? (result += "", "=" === operator ? result === check : "!=" === operator ? result !== check : "^=" === operator ? check && 0 === result.indexOf(check) : "*=" === operator ? check && result.indexOf(check) > -1 : "$=" === operator ? check && result.slice(-check.length) === check : "~=" === operator ? (" " + result.replace(rwhitespace, " ") + " ").indexOf(check) > -1 : "|=" === operator ? result === check || result.slice(0, check.length + 1) === check + "-" : !1) : !0
                        }
                    }, CHILD: function (type, what, argument, first, last) {
                        var simple = "nth" !== type.slice(0, 3), forward = "last" !== type.slice(-4), ofType = "of-type" === what;
                        return 1 === first && 0 === last ? function (elem) {
                                return !!elem.parentNode
                            } : function (elem, context, xml) {
                                var cache, uniqueCache, outerCache, node, nodeIndex, start, dir = simple !== forward ? "nextSibling" : "previousSibling", parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType, diff = !1;
                                if (parent) {
                                    if (simple) {
                                        for (; dir;) {
                                            for (node = elem; node = node[dir];)if (ofType ? node.nodeName.toLowerCase() === name : 1 === node.nodeType)return !1;
                                            start = dir = "only" === type && !start && "nextSibling"
                                        }
                                        return !0
                                    }
                                    if (start = [forward ? parent.firstChild : parent.lastChild], forward && useCache) {
                                        for (node = parent, outerCache = node[expando] || (node[expando] = {}), uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), cache = uniqueCache[type] || [], nodeIndex = cache[0] === dirruns && cache[1], diff = nodeIndex && cache[2], node = nodeIndex && parent.childNodes[nodeIndex]; node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop();)if (1 === node.nodeType && ++diff && node === elem) {
                                            uniqueCache[type] = [dirruns, nodeIndex, diff];
                                            break
                                        }
                                    } else if (useCache && (node = elem, outerCache = node[expando] || (node[expando] = {}), uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), cache = uniqueCache[type] || [], nodeIndex = cache[0] === dirruns && cache[1], diff = nodeIndex), diff === !1)for (; (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) && ((ofType ? node.nodeName.toLowerCase() !== name : 1 !== node.nodeType) || !++diff || (useCache && (outerCache = node[expando] || (node[expando] = {}), uniqueCache = outerCache[node.uniqueID] || (outerCache[node.uniqueID] = {}), uniqueCache[type] = [dirruns, diff]), node !== elem)););
                                    return diff -= last, diff === first || diff % first === 0 && diff / first >= 0
                                }
                            }
                    }, PSEUDO: function (pseudo, argument) {
                        var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error("unsupported pseudo: " + pseudo);
                        return fn[expando] ? fn(argument) : fn.length > 1 ? (args = [pseudo, pseudo, "", argument], Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function (seed, matches) {
                                        for (var idx, matched = fn(seed, argument), i = matched.length; i--;)idx = indexOf(seed, matched[i]), seed[idx] = !(matches[idx] = matched[i])
                                    }) : function (elem) {
                                        return fn(elem, 0, args)
                                    }) : fn
                    }
                },
                pseudos: {
                    not: markFunction(function (selector) {
                        var input = [], results = [], matcher = compile(selector.replace(rtrim, "$1"));
                        return matcher[expando] ? markFunction(function (seed, matches, context, xml) {
                                for (var elem, unmatched = matcher(seed, null, xml, []), i = seed.length; i--;)(elem = unmatched[i]) && (seed[i] = !(matches[i] = elem))
                            }) : function (elem, context, xml) {
                                return input[0] = elem, matcher(input, null, xml, results), input[0] = null, !results.pop()
                            }
                    }), has: markFunction(function (selector) {
                        return function (elem) {
                            return Sizzle(selector, elem).length > 0
                        }
                    }), contains: markFunction(function (text) {
                        return text = text.replace(runescape, funescape), function (elem) {
                            return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1
                        }
                    }), lang: markFunction(function (lang) {
                        return ridentifier.test(lang || "") || Sizzle.error("unsupported lang: " + lang), lang = lang.replace(runescape, funescape).toLowerCase(), function (elem) {
                            var elemLang;
                            do if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute("xml:lang") || elem.getAttribute("lang"))return elemLang = elemLang.toLowerCase(), elemLang === lang || 0 === elemLang.indexOf(lang + "-"); while ((elem = elem.parentNode) && 1 === elem.nodeType);
                            return !1
                        }
                    }), target: function (elem) {
                        var hash = window.location && window.location.hash;
                        return hash && hash.slice(1) === elem.id
                    }, root: function (elem) {
                        return elem === docElem
                    }, focus: function (elem) {
                        return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex)
                    }, enabled: createDisabledPseudo(!1), disabled: createDisabledPseudo(!0), checked: function (elem) {
                        var nodeName = elem.nodeName.toLowerCase();
                        return "input" === nodeName && !!elem.checked || "option" === nodeName && !!elem.selected
                    }, selected: function (elem) {
                        return elem.parentNode && elem.parentNode.selectedIndex, elem.selected === !0
                    }, empty: function (elem) {
                        for (elem = elem.firstChild; elem; elem = elem.nextSibling)if (elem.nodeType < 6)return !1;
                        return !0
                    }, parent: function (elem) {
                        return !Expr.pseudos.empty(elem)
                    }, header: function (elem) {
                        return rheader.test(elem.nodeName)
                    }, input: function (elem) {
                        return rinputs.test(elem.nodeName)
                    }, button: function (elem) {
                        var name = elem.nodeName.toLowerCase();
                        return "input" === name && "button" === elem.type || "button" === name
                    }, text: function (elem) {
                        var attr;
                        return "input" === elem.nodeName.toLowerCase() && "text" === elem.type && (null == (attr = elem.getAttribute("type")) || "text" === attr.toLowerCase())
                    }, first: createPositionalPseudo(function () {
                        return [0]
                    }), last: createPositionalPseudo(function (matchIndexes, length) {
                        return [length - 1]
                    }), eq: createPositionalPseudo(function (matchIndexes, length, argument) {
                        return [0 > argument ? argument + length : argument]
                    }), even: createPositionalPseudo(function (matchIndexes, length) {
                        for (var i = 0; length > i; i += 2)matchIndexes.push(i);
                        return matchIndexes
                    }), odd: createPositionalPseudo(function (matchIndexes, length) {
                        for (var i = 1; length > i; i += 2)matchIndexes.push(i);
                        return matchIndexes
                    }), lt: createPositionalPseudo(function (matchIndexes, length, argument) {
                        for (var i = 0 > argument ? argument + length : argument; --i >= 0;)matchIndexes.push(i);
                        return matchIndexes
                    }), gt: createPositionalPseudo(function (matchIndexes, length, argument) {
                        for (var i = 0 > argument ? argument + length : argument; ++i < length;)matchIndexes.push(i);
                        return matchIndexes
                    })
                }
            }, Expr.pseudos.nth = Expr.pseudos.eq;
            for (i in{
                radio: !0,
                checkbox: !0,
                file: !0,
                password: !0,
                image: !0
            })Expr.pseudos[i] = createInputPseudo(i);
            for (i in{submit: !0, reset: !0})Expr.pseudos[i] = createButtonPseudo(i);
            return setFilters.prototype = Expr.filters = Expr.pseudos, Expr.setFilters = new setFilters, tokenize = Sizzle.tokenize = function (selector, parseOnly) {
                var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + " "];
                if (cached)return parseOnly ? 0 : cached.slice(0);
                for (soFar = selector, groups = [], preFilters = Expr.preFilter; soFar;) {
                    (!matched || (match = rcomma.exec(soFar))) && (match && (soFar = soFar.slice(match[0].length) || soFar), groups.push(tokens = [])), matched = !1, (match = rcombinators.exec(soFar)) && (matched = match.shift(), tokens.push({
                        value: matched,
                        type: match[0].replace(rtrim, " ")
                    }), soFar = soFar.slice(matched.length));
                    for (type in Expr.filter)!(match = matchExpr[type].exec(soFar)) || preFilters[type] && !(match = preFilters[type](match)) || (matched = match.shift(), tokens.push({
                        value: matched,
                        type: type,
                        matches: match
                    }), soFar = soFar.slice(matched.length));
                    if (!matched)break
                }
                return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0)
            }, compile = Sizzle.compile = function (selector, match) {
                var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + " "];
                if (!cached) {
                    for (match || (match = tokenize(selector)), i = match.length; i--;)cached = matcherFromTokens(match[i]), cached[expando] ? setMatchers.push(cached) : elementMatchers.push(cached);
                    cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers)), cached.selector = selector
                }
                return cached
            }, select = Sizzle.select = function (selector, context, results, seed) {
                var i, tokens, token, type, find, compiled = "function" == typeof selector && selector, match = !seed && tokenize(selector = compiled.selector || selector);
                if (results = results || [], 1 === match.length) {
                    if (tokens = match[0] = match[0].slice(0), tokens.length > 2 && "ID" === (token = tokens[0]).type && support.getById && 9 === context.nodeType && documentIsHTML && Expr.relative[tokens[1].type]) {
                        if (context = (Expr.find.ID(token.matches[0].replace(runescape, funescape), context) || [])[0], !context)return results;
                        compiled && (context = context.parentNode), selector = selector.slice(tokens.shift().value.length)
                    }
                    for (i = matchExpr.needsContext.test(selector) ? 0 : tokens.length; i-- && (token = tokens[i], !Expr.relative[type = token.type]);)if ((find = Expr.find[type]) && (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context))) {
                        if (tokens.splice(i, 1), selector = seed.length && toSelector(tokens), !selector)return push.apply(results, seed), results;
                        break
                    }
                }
                return (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, !context || rsibling.test(selector) && testContext(context.parentNode) || context), results
            }, support.sortStable = expando.split("").sort(sortOrder).join("") === expando, support.detectDuplicates = !!hasDuplicate, setDocument(), support.sortDetached = assert(function (el) {
                return 1 & el.compareDocumentPosition(document.createElement("fieldset"))
            }), assert(function (el) {
                return el.innerHTML = "<a href='#'></a>", "#" === el.firstChild.getAttribute("href")
            }) || addHandle("type|href|height|width", function (elem, name, isXML) {
                return isXML ? void 0 : elem.getAttribute(name, "type" === name.toLowerCase() ? 1 : 2)
            }), support.attributes && assert(function (el) {
                return el.innerHTML = "<input/>", el.firstChild.setAttribute("value", ""), "" === el.firstChild.getAttribute("value")
            }) || addHandle("value", function (elem, name, isXML) {
                return isXML || "input" !== elem.nodeName.toLowerCase() ? void 0 : elem.defaultValue
            }), assert(function (el) {
                return null == el.getAttribute("disabled")
            }) || addHandle(booleans, function (elem, name, isXML) {
                var val;
                return isXML ? void 0 : elem[name] === !0 ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null
            }), Sizzle
        }(window);
        jQuery.find = Sizzle, jQuery.expr = Sizzle.selectors, jQuery.expr[":"] = jQuery.expr.pseudos, jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort, jQuery.text = Sizzle.getText, jQuery.isXMLDoc = Sizzle.isXML, jQuery.contains = Sizzle.contains, jQuery.escapeSelector = Sizzle.escape;
        var dir = function (elem, dir, until) {
            for (var matched = [], truncate = void 0 !== until; (elem = elem[dir]) && 9 !== elem.nodeType;)if (1 === elem.nodeType) {
                if (truncate && jQuery(elem).is(until))break;
                matched.push(elem)
            }
            return matched
        }, siblings = function (n, elem) {
            for (var matched = []; n; n = n.nextSibling)1 === n.nodeType && n !== elem && matched.push(n);
            return matched
        }, rneedsContext = jQuery.expr.match.needsContext, rsingleTag = /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i, risSimple = /^.[^:#\[\.,]*$/;
        jQuery.filter = function (expr, elems, not) {
            var elem = elems[0];
            return not && (expr = ":not(" + expr + ")"), 1 === elems.length && 1 === elem.nodeType ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function (elem) {
                    return 1 === elem.nodeType
                }))
        }, jQuery.fn.extend({
            find: function (selector) {
                var i, ret, len = this.length, self = this;
                if ("string" != typeof selector)return this.pushStack(jQuery(selector).filter(function () {
                    for (i = 0; len > i; i++)if (jQuery.contains(self[i], this))return !0
                }));
                for (ret = this.pushStack([]), i = 0; len > i; i++)jQuery.find(selector, self[i], ret);
                return len > 1 ? jQuery.uniqueSort(ret) : ret
            }, filter: function (selector) {
                return this.pushStack(winnow(this, selector || [], !1))
            }, not: function (selector) {
                return this.pushStack(winnow(this, selector || [], !0))
            }, is: function (selector) {
                return !!winnow(this, "string" == typeof selector && rneedsContext.test(selector) ? jQuery(selector) : selector || [], !1).length
            }
        });
        var rootjQuery, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/, init = jQuery.fn.init = function (selector, context, root) {
            var match, elem;
            if (!selector)return this;
            if (root = root || rootjQuery, "string" == typeof selector) {
                if (match = "<" === selector[0] && ">" === selector[selector.length - 1] && selector.length >= 3 ? [null, selector, null] : rquickExpr.exec(selector), !match || !match[1] && context)return !context || context.jquery ? (context || root).find(selector) : this.constructor(context).find(selector);
                if (match[1]) {
                    if (context = context instanceof jQuery ? context[0] : context, jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, !0)), rsingleTag.test(match[1]) && jQuery.isPlainObject(context))for (match in context)jQuery.isFunction(this[match]) ? this[match](context[match]) : this.attr(match, context[match]);
                    return this
                }
                return elem = document.getElementById(match[2]), elem && (this[0] = elem, this.length = 1), this
            }
            return selector.nodeType ? (this[0] = selector, this.length = 1, this) : jQuery.isFunction(selector) ? void 0 !== root.ready ? root.ready(selector) : selector(jQuery) : jQuery.makeArray(selector, this)
        };
        init.prototype = jQuery.fn, rootjQuery = jQuery(document);
        var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {
            children: !0,
            contents: !0,
            next: !0,
            prev: !0
        };
        jQuery.fn.extend({
            has: function (target) {
                var targets = jQuery(target, this), l = targets.length;
                return this.filter(function () {
                    for (var i = 0; l > i; i++)if (jQuery.contains(this, targets[i]))return !0
                })
            }, closest: function (selectors, context) {
                var cur, i = 0, l = this.length, matched = [], targets = "string" != typeof selectors && jQuery(selectors);
                if (!rneedsContext.test(selectors))for (; l > i; i++)for (cur = this[i]; cur && cur !== context; cur = cur.parentNode)if (cur.nodeType < 11 && (targets ? targets.index(cur) > -1 : 1 === cur.nodeType && jQuery.find.matchesSelector(cur, selectors))) {
                    matched.push(cur);
                    break
                }
                return this.pushStack(matched.length > 1 ? jQuery.uniqueSort(matched) : matched)
            }, index: function (elem) {
                return elem ? "string" == typeof elem ? indexOf.call(jQuery(elem), this[0]) : indexOf.call(this, elem.jquery ? elem[0] : elem) : this[0] && this[0].parentNode ? this.first().prevAll().length : -1
            }, add: function (selector, context) {
                return this.pushStack(jQuery.uniqueSort(jQuery.merge(this.get(), jQuery(selector, context))))
            }, addBack: function (selector) {
                return this.add(null == selector ? this.prevObject : this.prevObject.filter(selector))
            }
        }), jQuery.each({
            parent: function (elem) {
                var parent = elem.parentNode;
                return parent && 11 !== parent.nodeType ? parent : null
            }, parents: function (elem) {
                return dir(elem, "parentNode")
            }, parentsUntil: function (elem, i, until) {
                return dir(elem, "parentNode", until)
            }, next: function (elem) {
                return sibling(elem, "nextSibling")
            }, prev: function (elem) {
                return sibling(elem, "previousSibling")
            }, nextAll: function (elem) {
                return dir(elem, "nextSibling")
            }, prevAll: function (elem) {
                return dir(elem, "previousSibling")
            }, nextUntil: function (elem, i, until) {
                return dir(elem, "nextSibling", until)
            }, prevUntil: function (elem, i, until) {
                return dir(elem, "previousSibling", until)
            }, siblings: function (elem) {
                return siblings((elem.parentNode || {}).firstChild, elem)
            }, children: function (elem) {
                return siblings(elem.firstChild)
            }, contents: function (elem) {
                return elem.contentDocument || jQuery.merge([], elem.childNodes)
            }
        }, function (name, fn) {
            jQuery.fn[name] = function (until, selector) {
                var matched = jQuery.map(this, fn, until);
                return "Until" !== name.slice(-5) && (selector = until), selector && "string" == typeof selector && (matched = jQuery.filter(selector, matched)), this.length > 1 && (guaranteedUnique[name] || jQuery.uniqueSort(matched), rparentsprev.test(name) && matched.reverse()), this.pushStack(matched)
            }
        });
        var rnotwhite = /\S+/g;
        jQuery.Callbacks = function (options) {
            options = "string" == typeof options ? createOptions(options) : jQuery.extend({}, options);
            var firing, memory, fired, locked, list = [], queue = [], firingIndex = -1, fire = function () {
                for (locked = options.once, fired = firing = !0; queue.length; firingIndex = -1)for (memory = queue.shift(); ++firingIndex < list.length;)list[firingIndex].apply(memory[0], memory[1]) === !1 && options.stopOnFalse && (firingIndex = list.length, memory = !1);
                options.memory || (memory = !1), firing = !1, locked && (list = memory ? [] : "")
            }, self = {
                add: function () {
                    return list && (memory && !firing && (firingIndex = list.length - 1, queue.push(memory)), function add(args) {
                        jQuery.each(args, function (_, arg) {
                            jQuery.isFunction(arg) ? options.unique && self.has(arg) || list.push(arg) : arg && arg.length && "string" !== jQuery.type(arg) && add(arg)
                        })
                    }(arguments), memory && !firing && fire()), this
                }, remove: function () {
                    return jQuery.each(arguments, function (_, arg) {
                        for (var index; (index = jQuery.inArray(arg, list, index)) > -1;)list.splice(index, 1), firingIndex >= index && firingIndex--
                    }), this
                }, has: function (fn) {
                    return fn ? jQuery.inArray(fn, list) > -1 : list.length > 0
                }, empty: function () {
                    return list && (list = []), this
                }, disable: function () {
                    return locked = queue = [], list = memory = "", this
                }, disabled: function () {
                    return !list
                }, lock: function () {
                    return locked = queue = [], memory || firing || (list = memory = ""), this
                }, locked: function () {
                    return !!locked
                }, fireWith: function (context, args) {
                    return locked || (args = args || [], args = [context, args.slice ? args.slice() : args], queue.push(args), firing || fire()), this
                }, fire: function () {
                    return self.fireWith(this, arguments), this
                }, fired: function () {
                    return !!fired
                }
            };
            return self
        }, jQuery.extend({
            Deferred: function (func) {
                var tuples = [["notify", "progress", jQuery.Callbacks("memory"), jQuery.Callbacks("memory"), 2], ["resolve", "done", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 0, "resolved"], ["reject", "fail", jQuery.Callbacks("once memory"), jQuery.Callbacks("once memory"), 1, "rejected"]], state = "pending", promise = {
                    state: function () {
                        return state
                    }, always: function () {
                        return deferred.done(arguments).fail(arguments), this
                    }, "catch": function (fn) {
                        return promise.then(null, fn)
                    }, pipe: function () {
                        var fns = arguments;
                        return jQuery.Deferred(function (newDefer) {
                            jQuery.each(tuples, function (i, tuple) {
                                var fn = jQuery.isFunction(fns[tuple[4]]) && fns[tuple[4]];
                                deferred[tuple[1]](function () {
                                    var returned = fn && fn.apply(this, arguments);
                                    returned && jQuery.isFunction(returned.promise) ? returned.promise().progress(newDefer.notify).done(newDefer.resolve).fail(newDefer.reject) : newDefer[tuple[0] + "With"](this, fn ? [returned] : arguments)
                                })
                            }), fns = null
                        }).promise()
                    }, then: function (onFulfilled, onRejected, onProgress) {
                        function resolve(depth, deferred, handler, special) {
                            return function () {
                                var that = this, args = arguments, mightThrow = function () {
                                    var returned, then;
                                    if (!(maxDepth > depth)) {
                                        if (returned = handler.apply(that, args), returned === deferred.promise())throw new TypeError("Thenable self-resolution");
                                        then = returned && ("object" == typeof returned || "function" == typeof returned) && returned.then, jQuery.isFunction(then) ? special ? then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special)) : (maxDepth++, then.call(returned, resolve(maxDepth, deferred, Identity, special), resolve(maxDepth, deferred, Thrower, special), resolve(maxDepth, deferred, Identity, deferred.notifyWith))) : (handler !== Identity && (that = void 0, args = [returned]), (special || deferred.resolveWith)(that, args))
                                    }
                                }, process = special ? mightThrow : function () {
                                        try {
                                            mightThrow()
                                        } catch (e) {
                                            jQuery.Deferred.exceptionHook && jQuery.Deferred.exceptionHook(e, process.stackTrace), depth + 1 >= maxDepth && (handler !== Thrower && (that = void 0, args = [e]), deferred.rejectWith(that, args))
                                        }
                                    };
                                depth ? process() : (jQuery.Deferred.getStackHook && (process.stackTrace = jQuery.Deferred.getStackHook()), window.setTimeout(process))
                            }
                        }

                        var maxDepth = 0;
                        return jQuery.Deferred(function (newDefer) {
                            tuples[0][3].add(resolve(0, newDefer, jQuery.isFunction(onProgress) ? onProgress : Identity, newDefer.notifyWith)), tuples[1][3].add(resolve(0, newDefer, jQuery.isFunction(onFulfilled) ? onFulfilled : Identity)), tuples[2][3].add(resolve(0, newDefer, jQuery.isFunction(onRejected) ? onRejected : Thrower))
                        }).promise()
                    }, promise: function (obj) {
                        return null != obj ? jQuery.extend(obj, promise) : promise
                    }
                }, deferred = {};
                return jQuery.each(tuples, function (i, tuple) {
                    var list = tuple[2], stateString = tuple[5];
                    promise[tuple[1]] = list.add, stateString && list.add(function () {
                        state = stateString
                    }, tuples[3 - i][2].disable, tuples[0][2].lock), list.add(tuple[3].fire), deferred[tuple[0]] = function () {
                        return deferred[tuple[0] + "With"](this === deferred ? void 0 : this, arguments), this
                    }, deferred[tuple[0] + "With"] = list.fireWith
                }), promise.promise(deferred), func && func.call(deferred, deferred), deferred
            }, when: function (singleValue) {
                var remaining = arguments.length, i = remaining, resolveContexts = Array(i), resolveValues = slice.call(arguments), master = jQuery.Deferred(), updateFunc = function (i) {
                    return function (value) {
                        resolveContexts[i] = this, resolveValues[i] = arguments.length > 1 ? slice.call(arguments) : value, --remaining || master.resolveWith(resolveContexts, resolveValues)
                    }
                };
                if (1 >= remaining && (adoptValue(singleValue, master.done(updateFunc(i)).resolve, master.reject), "pending" === master.state() || jQuery.isFunction(resolveValues[i] && resolveValues[i].then)))return master.then();
                for (; i--;)adoptValue(resolveValues[i], updateFunc(i), master.reject);
                return master.promise()
            }
        });
        var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;
        jQuery.Deferred.exceptionHook = function (error, stack) {
            window.console && window.console.warn && error && rerrorNames.test(error.name) && window.console.warn("jQuery.Deferred exception: " + error.message, error.stack, stack)
        }, jQuery.readyException = function (error) {
            window.setTimeout(function () {
                throw error
            })
        };
        var readyList = jQuery.Deferred();
        jQuery.fn.ready = function (fn) {
            return readyList.then(fn)["catch"](function (error) {
                jQuery.readyException(error)
            }), this
        }, jQuery.extend({
            isReady: !1, readyWait: 1, holdReady: function (hold) {
                hold ? jQuery.readyWait++ : jQuery.ready(!0)
            }, ready: function (wait) {
                (wait === !0 ? --jQuery.readyWait : jQuery.isReady) || (jQuery.isReady = !0, wait !== !0 && --jQuery.readyWait > 0 || readyList.resolveWith(document, [jQuery]))
            }
        }), jQuery.ready.then = readyList.then, "complete" === document.readyState || "loading" !== document.readyState && !document.documentElement.doScroll ? window.setTimeout(jQuery.ready) : (document.addEventListener("DOMContentLoaded", completed), window.addEventListener("load", completed));
        var access = function (elems, fn, key, value, chainable, emptyGet, raw) {
            var i = 0, len = elems.length, bulk = null == key;
            if ("object" === jQuery.type(key)) {
                chainable = !0;
                for (i in key)access(elems, fn, i, key[i], !0, emptyGet, raw)
            } else if (void 0 !== value && (chainable = !0, jQuery.isFunction(value) || (raw = !0), bulk && (raw ? (fn.call(elems, value), fn = null) : (bulk = fn, fn = function (elem, key, value) {
                        return bulk.call(jQuery(elem), value)
                    })), fn))for (; len > i; i++)fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
            return chainable ? elems : bulk ? fn.call(elems) : len ? fn(elems[0], key) : emptyGet
        }, acceptData = function (owner) {
            return 1 === owner.nodeType || 9 === owner.nodeType || !+owner.nodeType
        };
        Data.uid = 1, Data.prototype = {
            cache: function (owner) {
                var value = owner[this.expando];
                return value || (value = {}, acceptData(owner) && (owner.nodeType ? owner[this.expando] = value : Object.defineProperty(owner, this.expando, {
                        value: value,
                        configurable: !0
                    }))), value
            }, set: function (owner, data, value) {
                var prop, cache = this.cache(owner);
                if ("string" == typeof data) cache[jQuery.camelCase(data)] = value; else for (prop in data)cache[jQuery.camelCase(prop)] = data[prop];
                return cache
            }, get: function (owner, key) {
                return void 0 === key ? this.cache(owner) : owner[this.expando] && owner[this.expando][jQuery.camelCase(key)]
            }, access: function (owner, key, value) {
                return void 0 === key || key && "string" == typeof key && void 0 === value ? this.get(owner, key) : (this.set(owner, key, value), void 0 !== value ? value : key)
            }, remove: function (owner, key) {
                var i, cache = owner[this.expando];
                if (void 0 !== cache) {
                    if (void 0 !== key) {
                        jQuery.isArray(key) ? key = key.map(jQuery.camelCase) : (key = jQuery.camelCase(key), key = key in cache ? [key] : key.match(rnotwhite) || []), i = key.length;
                        for (; i--;)delete cache[key[i]]
                    }
                    (void 0 === key || jQuery.isEmptyObject(cache)) && (owner.nodeType ? owner[this.expando] = void 0 : delete owner[this.expando])
                }
            }, hasData: function (owner) {
                var cache = owner[this.expando];
                return void 0 !== cache && !jQuery.isEmptyObject(cache)
            }
        };
        var dataPriv = new Data, dataUser = new Data, rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /[A-Z]/g;
        jQuery.extend({
            hasData: function (elem) {
                return dataUser.hasData(elem) || dataPriv.hasData(elem)
            }, data: function (elem, name, data) {
                return dataUser.access(elem, name, data)
            }, removeData: function (elem, name) {
                dataUser.remove(elem, name)
            }, _data: function (elem, name, data) {
                return dataPriv.access(elem, name, data)
            }, _removeData: function (elem, name) {
                dataPriv.remove(elem, name)
            }
        }), jQuery.fn.extend({
            data: function (key, value) {
                var i, name, data, elem = this[0], attrs = elem && elem.attributes;
                if (void 0 === key) {
                    if (this.length && (data = dataUser.get(elem), 1 === elem.nodeType && !dataPriv.get(elem, "hasDataAttrs"))) {
                        for (i = attrs.length; i--;)attrs[i] && (name = attrs[i].name, 0 === name.indexOf("data-") && (name = jQuery.camelCase(name.slice(5)), dataAttr(elem, name, data[name])));
                        dataPriv.set(elem, "hasDataAttrs", !0)
                    }
                    return data
                }
                return "object" == typeof key ? this.each(function () {
                        dataUser.set(this, key)
                    }) : access(this, function (value) {
                        var data;
                        if (elem && void 0 === value) {
                            if (data = dataUser.get(elem, key), void 0 !== data)return data;
                            if (data = dataAttr(elem, key), void 0 !== data)return data
                        } else this.each(function () {
                            dataUser.set(this, key, value)
                        })
                    }, null, value, arguments.length > 1, null, !0)
            }, removeData: function (key) {
                return this.each(function () {
                    dataUser.remove(this, key)
                })
            }
        }), jQuery.extend({
            queue: function (elem, type, data) {
                var queue;
                return elem ? (type = (type || "fx") + "queue", queue = dataPriv.get(elem, type), data && (!queue || jQuery.isArray(data) ? queue = dataPriv.access(elem, type, jQuery.makeArray(data)) : queue.push(data)), queue || []) : void 0
            }, dequeue: function (elem, type) {
                type = type || "fx";
                var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function () {
                    jQuery.dequeue(elem, type)
                };
                "inprogress" === fn && (fn = queue.shift(), startLength--), fn && ("fx" === type && queue.unshift("inprogress"), delete hooks.stop, fn.call(elem, next, hooks)), !startLength && hooks && hooks.empty.fire()
            }, _queueHooks: function (elem, type) {
                var key = type + "queueHooks";
                return dataPriv.get(elem, key) || dataPriv.access(elem, key, {
                        empty: jQuery.Callbacks("once memory").add(function () {
                            dataPriv.remove(elem, [type + "queue", key])
                        })
                    })
            }
        }), jQuery.fn.extend({
            queue: function (type, data) {
                var setter = 2;
                return "string" != typeof type && (data = type, type = "fx", setter--), arguments.length < setter ? jQuery.queue(this[0], type) : void 0 === data ? this : this.each(function () {
                            var queue = jQuery.queue(this, type, data);
                            jQuery._queueHooks(this, type), "fx" === type && "inprogress" !== queue[0] && jQuery.dequeue(this, type)
                        })
            }, dequeue: function (type) {
                return this.each(function () {
                    jQuery.dequeue(this, type)
                })
            }, clearQueue: function (type) {
                return this.queue(type || "fx", [])
            }, promise: function (type, obj) {
                var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function () {
                    --count || defer.resolveWith(elements, [elements])
                };
                for ("string" != typeof type && (obj = type, type = void 0), type = type || "fx"; i--;)tmp = dataPriv.get(elements[i], type + "queueHooks"), tmp && tmp.empty && (count++, tmp.empty.add(resolve));
                return resolve(), defer.promise(obj)
            }
        });
        var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source, rcssNum = new RegExp("^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i"), cssExpand = ["Top", "Right", "Bottom", "Left"], isHiddenWithinTree = function (elem, el) {
            return elem = el || elem, "none" === elem.style.display || "" === elem.style.display && jQuery.contains(elem.ownerDocument, elem) && "none" === jQuery.css(elem, "display")
        }, swap = function (elem, options, callback, args) {
            var ret, name, old = {};
            for (name in options)old[name] = elem.style[name], elem.style[name] = options[name];
            ret = callback.apply(elem, args || []);
            for (name in options)elem.style[name] = old[name];
            return ret
        }, defaultDisplayMap = {};
        jQuery.fn.extend({
            show: function () {
                return showHide(this, !0)
            }, hide: function () {
                return showHide(this)
            }, toggle: function (state) {
                return "boolean" == typeof state ? state ? this.show() : this.hide() : this.each(function () {
                        isHiddenWithinTree(this) ? jQuery(this).show() : jQuery(this).hide()
                    })
            }
        });
        var rcheckableType = /^(?:checkbox|radio)$/i, rtagName = /<([a-z][^\/\0>\x20\t\r\n\f]+)/i, rscriptType = /^$|\/(?:java|ecma)script/i, wrapMap = {
            option: [1, "<select multiple='multiple'>", "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };
        wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, wrapMap.th = wrapMap.td;
        var rhtml = /<|&#?\w+;/;
        !function () {
            var fragment = document.createDocumentFragment(), div = fragment.appendChild(document.createElement("div")), input = document.createElement("input");
            input.setAttribute("type", "radio"), input.setAttribute("checked", "checked"), input.setAttribute("name", "t"), div.appendChild(input), support.checkClone = div.cloneNode(!0).cloneNode(!0).lastChild.checked, div.innerHTML = "<textarea>x</textarea>", support.noCloneChecked = !!div.cloneNode(!0).lastChild.defaultValue
        }();
        var documentElement = document.documentElement, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, rtypenamespace = /^([^.]*)(?:\.(.+)|)/;
        jQuery.event = {
            global: {}, add: function (elem, types, handler, data, selector) {
                var handleObjIn, eventHandle, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.get(elem);
                if (elemData)for (handler.handler && (handleObjIn = handler, handler = handleObjIn.handler, selector = handleObjIn.selector), selector && jQuery.find.matchesSelector(documentElement, selector), handler.guid || (handler.guid = jQuery.guid++), (events = elemData.events) || (events = elemData.events = {}), (eventHandle = elemData.handle) || (eventHandle = elemData.handle = function (e) {
                    return "undefined" != typeof jQuery && jQuery.event.triggered !== e.type ? jQuery.event.dispatch.apply(elem, arguments) : void 0
                }), types = (types || "").match(rnotwhite) || [""], t = types.length; t--;)tmp = rtypenamespace.exec(types[t]) || [], type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type && (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, special = jQuery.event.special[type] || {}, handleObj = jQuery.extend({
                    type: type,
                    origType: origType,
                    data: data,
                    handler: handler,
                    guid: handler.guid,
                    selector: selector,
                    needsContext: selector && jQuery.expr.match.needsContext.test(selector),
                    namespace: namespaces.join(".")
                }, handleObjIn), (handlers = events[type]) || (handlers = events[type] = [], handlers.delegateCount = 0, special.setup && special.setup.call(elem, data, namespaces, eventHandle) !== !1 || elem.addEventListener && elem.addEventListener(type, eventHandle)), special.add && (special.add.call(elem, handleObj), handleObj.handler.guid || (handleObj.handler.guid = handler.guid)), selector ? handlers.splice(handlers.delegateCount++, 0, handleObj) : handlers.push(handleObj), jQuery.event.global[type] = !0)
            }, remove: function (elem, types, handler, selector, mappedTypes) {
                var j, origCount, tmp, events, t, handleObj, special, handlers, type, namespaces, origType, elemData = dataPriv.hasData(elem) && dataPriv.get(elem);
                if (elemData && (events = elemData.events)) {
                    for (types = (types || "").match(rnotwhite) || [""], t = types.length; t--;)if (tmp = rtypenamespace.exec(types[t]) || [], type = origType = tmp[1], namespaces = (tmp[2] || "").split(".").sort(), type) {
                        for (special = jQuery.event.special[type] || {}, type = (selector ? special.delegateType : special.bindType) || type, handlers = events[type] || [], tmp = tmp[2] && new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)"), origCount = j = handlers.length; j--;)handleObj = handlers[j], !mappedTypes && origType !== handleObj.origType || handler && handler.guid !== handleObj.guid || tmp && !tmp.test(handleObj.namespace) || selector && selector !== handleObj.selector && ("**" !== selector || !handleObj.selector) || (handlers.splice(j, 1), handleObj.selector && handlers.delegateCount--, special.remove && special.remove.call(elem, handleObj));
                        origCount && !handlers.length && (special.teardown && special.teardown.call(elem, namespaces, elemData.handle) !== !1 || jQuery.removeEvent(elem, type, elemData.handle), delete events[type])
                    } else for (type in events)jQuery.event.remove(elem, type + types[t], handler, selector, !0);
                    jQuery.isEmptyObject(events) && dataPriv.remove(elem, "handle events")
                }
            }, dispatch: function (nativeEvent) {
                var i, j, ret, matched, handleObj, handlerQueue, event = jQuery.event.fix(nativeEvent), args = new Array(arguments.length), handlers = (dataPriv.get(this, "events") || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
                for (args[0] = event, i = 1; i < arguments.length; i++)args[i] = arguments[i];
                if (event.delegateTarget = this, !special.preDispatch || special.preDispatch.call(this, event) !== !1) {
                    for (handlerQueue = jQuery.event.handlers.call(this, event, handlers), i = 0; (matched = handlerQueue[i++]) && !event.isPropagationStopped();)for (event.currentTarget = matched.elem, j = 0; (handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped();)(!event.rnamespace || event.rnamespace.test(handleObj.namespace)) && (event.handleObj = handleObj, event.data = handleObj.data, ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args), void 0 !== ret && (event.result = ret) === !1 && (event.preventDefault(), event.stopPropagation()));
                    return special.postDispatch && special.postDispatch.call(this, event), event.result
                }
            }, handlers: function (event, handlers) {
                var i, matches, sel, handleObj, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
                if (delegateCount && cur.nodeType && ("click" !== event.type || isNaN(event.button) || event.button < 1))for (; cur !== this; cur = cur.parentNode || this)if (1 === cur.nodeType && (cur.disabled !== !0 || "click" !== event.type)) {
                    for (matches = [], i = 0; delegateCount > i; i++)handleObj = handlers[i], sel = handleObj.selector + " ", void 0 === matches[sel] && (matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) > -1 : jQuery.find(sel, this, null, [cur]).length), matches[sel] && matches.push(handleObj);
                    matches.length && handlerQueue.push({elem: cur, handlers: matches})
                }
                return delegateCount < handlers.length && handlerQueue.push({
                    elem: this,
                    handlers: handlers.slice(delegateCount)
                }), handlerQueue
            }, addProp: function (name, hook) {
                Object.defineProperty(jQuery.Event.prototype, name, {
                    enumerable: !0,
                    configurable: !0,
                    get: jQuery.isFunction(hook) ? function () {
                            return this.originalEvent ? hook(this.originalEvent) : void 0
                        } : function () {
                            return this.originalEvent ? this.originalEvent[name] : void 0
                        },
                    set: function (value) {
                        Object.defineProperty(this, name, {
                            enumerable: !0,
                            configurable: !0,
                            writable: !0,
                            value: value
                        })
                    }
                })
            }, fix: function (originalEvent) {
                return originalEvent[jQuery.expando] ? originalEvent : new jQuery.Event(originalEvent)
            }, special: {
                load: {noBubble: !0}, focus: {
                    trigger: function () {
                        return this !== safeActiveElement() && this.focus ? (this.focus(), !1) : void 0
                    }, delegateType: "focusin"
                }, blur: {
                    trigger: function () {
                        return this === safeActiveElement() && this.blur ? (this.blur(), !1) : void 0
                    }, delegateType: "focusout"
                }, click: {
                    trigger: function () {
                        return "checkbox" === this.type && this.click && jQuery.nodeName(this, "input") ? (this.click(), !1) : void 0
                    }, _default: function (event) {
                        return jQuery.nodeName(event.target, "a")
                    }
                }, beforeunload: {
                    postDispatch: function (event) {
                        void 0 !== event.result && event.originalEvent && (event.originalEvent.returnValue = event.result)
                    }
                }
            }
        }, jQuery.removeEvent = function (elem, type, handle) {
            elem.removeEventListener && elem.removeEventListener(type, handle)
        }, jQuery.Event = function (src, props) {
            return this instanceof jQuery.Event ? (src && src.type ? (this.originalEvent = src, this.type = src.type, this.isDefaultPrevented = src.defaultPrevented || void 0 === src.defaultPrevented && src.returnValue === !1 ? returnTrue : returnFalse, this.target = src.target && 3 === src.target.nodeType ? src.target.parentNode : src.target, this.currentTarget = src.currentTarget, this.relatedTarget = src.relatedTarget) : this.type = src, props && jQuery.extend(this, props), this.timeStamp = src && src.timeStamp || jQuery.now(), void(this[jQuery.expando] = !0)) : new jQuery.Event(src, props)
        }, jQuery.Event.prototype = {
            constructor: jQuery.Event,
            isDefaultPrevented: returnFalse,
            isPropagationStopped: returnFalse,
            isImmediatePropagationStopped: returnFalse,
            isSimulated: !1,
            preventDefault: function () {
                var e = this.originalEvent;
                this.isDefaultPrevented = returnTrue, e && !this.isSimulated && e.preventDefault()
            },
            stopPropagation: function () {
                var e = this.originalEvent;
                this.isPropagationStopped = returnTrue, e && !this.isSimulated && e.stopPropagation()
            },
            stopImmediatePropagation: function () {
                var e = this.originalEvent;
                this.isImmediatePropagationStopped = returnTrue, e && !this.isSimulated && e.stopImmediatePropagation(), this.stopPropagation()
            }
        }, jQuery.each({
            altKey: !0,
            bubbles: !0,
            cancelable: !0,
            changedTouches: !0,
            ctrlKey: !0,
            detail: !0,
            eventPhase: !0,
            metaKey: !0,
            pageX: !0,
            pageY: !0,
            shiftKey: !0,
            view: !0,
            "char": !0,
            charCode: !0,
            key: !0,
            keyCode: !0,
            button: !0,
            buttons: !0,
            clientX: !0,
            clientY: !0,
            offsetX: !0,
            offsetY: !0,
            pointerId: !0,
            pointerType: !0,
            screenX: !0,
            screenY: !0,
            targetTouches: !0,
            toElement: !0,
            touches: !0,
            which: function (event) {
                var button = event.button;
                return null == event.which && rkeyEvent.test(event.type) ? null != event.charCode ? event.charCode : event.keyCode : !event.which && void 0 !== button && rmouseEvent.test(event.type) ? 1 & button ? 1 : 2 & button ? 3 : 4 & button ? 2 : 0 : event.which
            }
        }, jQuery.event.addProp), jQuery.each({
            mouseenter: "mouseover",
            mouseleave: "mouseout",
            pointerenter: "pointerover",
            pointerleave: "pointerout"
        }, function (orig, fix) {
            jQuery.event.special[orig] = {
                delegateType: fix, bindType: fix, handle: function (event) {
                    var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
                    return (!related || related !== target && !jQuery.contains(target, related)) && (event.type = handleObj.origType, ret = handleObj.handler.apply(this, arguments), event.type = fix), ret
                }
            }
        }), jQuery.fn.extend({
            on: function (types, selector, data, fn) {
                return on(this, types, selector, data, fn)
            }, one: function (types, selector, data, fn) {
                return on(this, types, selector, data, fn, 1)
            }, off: function (types, selector, fn) {
                var handleObj, type;
                if (types && types.preventDefault && types.handleObj)return handleObj = types.handleObj, jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + "." + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler), this;
                if ("object" == typeof types) {
                    for (type in types)this.off(type, selector, types[type]);
                    return this
                }
                return (selector === !1 || "function" == typeof selector) && (fn = selector, selector = void 0), fn === !1 && (fn = returnFalse), this.each(function () {
                    jQuery.event.remove(this, types, fn, selector)
                })
            }
        });
        var rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi, rnoInnerhtml = /<script|<style|<link/i, rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;
        jQuery.extend({
            htmlPrefilter: function (html) {
                return html.replace(rxhtmlTag, "<$1></$2>")
            }, clone: function (elem, dataAndEvents, deepDataAndEvents) {
                var i, l, srcElements, destElements, clone = elem.cloneNode(!0), inPage = jQuery.contains(elem.ownerDocument, elem);
                if (!(support.noCloneChecked || 1 !== elem.nodeType && 11 !== elem.nodeType || jQuery.isXMLDoc(elem)))for (destElements = getAll(clone), srcElements = getAll(elem), i = 0, l = srcElements.length; l > i; i++)fixInput(srcElements[i], destElements[i]);
                if (dataAndEvents)if (deepDataAndEvents)for (srcElements = srcElements || getAll(elem), destElements = destElements || getAll(clone), i = 0, l = srcElements.length; l > i; i++)cloneCopyEvent(srcElements[i], destElements[i]); else cloneCopyEvent(elem, clone);
                return destElements = getAll(clone, "script"), destElements.length > 0 && setGlobalEval(destElements, !inPage && getAll(elem, "script")), clone
            }, cleanData: function (elems) {
                for (var data, elem, type, special = jQuery.event.special, i = 0; void 0 !== (elem = elems[i]); i++)if (acceptData(elem)) {
                    if (data = elem[dataPriv.expando]) {
                        if (data.events)for (type in data.events)special[type] ? jQuery.event.remove(elem, type) : jQuery.removeEvent(elem, type, data.handle);
                        elem[dataPriv.expando] = void 0
                    }
                    elem[dataUser.expando] && (elem[dataUser.expando] = void 0)
                }
            }
        }), jQuery.fn.extend({
            detach: function (selector) {
                return remove(this, selector, !0)
            }, remove: function (selector) {
                return remove(this, selector)
            }, text: function (value) {
                return access(this, function (value) {
                    return void 0 === value ? jQuery.text(this) : this.empty().each(function () {
                            (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) && (this.textContent = value)
                        })
                }, null, value, arguments.length)
            }, append: function () {
                return domManip(this, arguments, function (elem) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var target = manipulationTarget(this, elem);
                        target.appendChild(elem)
                    }
                })
            }, prepend: function () {
                return domManip(this, arguments, function (elem) {
                    if (1 === this.nodeType || 11 === this.nodeType || 9 === this.nodeType) {
                        var target = manipulationTarget(this, elem);
                        target.insertBefore(elem, target.firstChild)
                    }
                })
            }, before: function () {
                return domManip(this, arguments, function (elem) {
                    this.parentNode && this.parentNode.insertBefore(elem, this)
                })
            }, after: function () {
                return domManip(this, arguments, function (elem) {
                    this.parentNode && this.parentNode.insertBefore(elem, this.nextSibling)
                })
            }, empty: function () {
                for (var elem, i = 0; null != (elem = this[i]); i++)1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.textContent = "");
                return this
            }, clone: function (dataAndEvents, deepDataAndEvents) {
                return dataAndEvents = null == dataAndEvents ? !1 : dataAndEvents, deepDataAndEvents = null == deepDataAndEvents ? dataAndEvents : deepDataAndEvents, this.map(function () {
                    return jQuery.clone(this, dataAndEvents, deepDataAndEvents)
                })
            }, html: function (value) {
                return access(this, function (value) {
                    var elem = this[0] || {}, i = 0, l = this.length;
                    if (void 0 === value && 1 === elem.nodeType)return elem.innerHTML;
                    if ("string" == typeof value && !rnoInnerhtml.test(value) && !wrapMap[(rtagName.exec(value) || ["", ""])[1].toLowerCase()]) {
                        value = jQuery.htmlPrefilter(value);
                        try {
                            for (; l > i; i++)elem = this[i] || {}, 1 === elem.nodeType && (jQuery.cleanData(getAll(elem, !1)), elem.innerHTML = value);
                            elem = 0
                        } catch (e) {
                        }
                    }
                    elem && this.empty().append(value)
                }, null, value, arguments.length)
            }, replaceWith: function () {
                var ignored = [];
                return domManip(this, arguments, function (elem) {
                    var parent = this.parentNode;
                    jQuery.inArray(this, ignored) < 0 && (jQuery.cleanData(getAll(this)), parent && parent.replaceChild(elem, this))
                }, ignored)
            }
        }), jQuery.each({
            appendTo: "append",
            prependTo: "prepend",
            insertBefore: "before",
            insertAfter: "after",
            replaceAll: "replaceWith"
        }, function (name, original) {
            jQuery.fn[name] = function (selector) {
                for (var elems, ret = [], insert = jQuery(selector), last = insert.length - 1, i = 0; last >= i; i++)elems = i === last ? this : this.clone(!0), jQuery(insert[i])[original](elems), push.apply(ret, elems.get());
                return this.pushStack(ret)
            }
        });
        var rmargin = /^margin/, rnumnonpx = new RegExp("^(" + pnum + ")(?!px)[a-z%]+$", "i"), getStyles = function (elem) {
            var view = elem.ownerDocument.defaultView;
            return view && view.opener || (view = window), view.getComputedStyle(elem)
        };
        !function () {
            function computeStyleTests() {
                if (div) {
                    div.style.cssText = "box-sizing:border-box;position:relative;display:block;margin:auto;border:1px;padding:1px;top:1%;width:50%", div.innerHTML = "", documentElement.appendChild(container);
                    var divStyle = window.getComputedStyle(div);
                    pixelPositionVal = "1%" !== divStyle.top, reliableMarginLeftVal = "2px" === divStyle.marginLeft, boxSizingReliableVal = "4px" === divStyle.width, div.style.marginRight = "50%", pixelMarginRightVal = "4px" === divStyle.marginRight, documentElement.removeChild(container), div = null
                }
            }

            var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal, container = document.createElement("div"), div = document.createElement("div");
            div.style && (div.style.backgroundClip = "content-box", div.cloneNode(!0).style.backgroundClip = "", support.clearCloneStyle = "content-box" === div.style.backgroundClip, container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;padding:0;margin-top:1px;position:absolute", container.appendChild(div), jQuery.extend(support, {
                pixelPosition: function () {
                    return computeStyleTests(), pixelPositionVal
                }, boxSizingReliable: function () {
                    return computeStyleTests(), boxSizingReliableVal
                }, pixelMarginRight: function () {
                    return computeStyleTests(), pixelMarginRightVal
                }, reliableMarginLeft: function () {
                    return computeStyleTests(), reliableMarginLeftVal
                }
            }))
        }();
        var rdisplayswap = /^(none|table(?!-c[ea]).+)/, cssShow = {
            position: "absolute", visibility: "hidden",
            display: "block"
        }, cssNormalTransform = {
            letterSpacing: "0",
            fontWeight: "400"
        }, cssPrefixes = ["Webkit", "Moz", "ms"], emptyStyle = document.createElement("div").style;
        jQuery.extend({
            cssHooks: {
                opacity: {
                    get: function (elem, computed) {
                        if (computed) {
                            var ret = curCSS(elem, "opacity");
                            return "" === ret ? "1" : ret
                        }
                    }
                }
            },
            cssNumber: {
                animationIterationCount: !0,
                columnCount: !0,
                fillOpacity: !0,
                flexGrow: !0,
                flexShrink: !0,
                fontWeight: !0,
                lineHeight: !0,
                opacity: !0,
                order: !0,
                orphans: !0,
                widows: !0,
                zIndex: !0,
                zoom: !0
            },
            cssProps: {"float": "cssFloat"},
            style: function (elem, name, value, extra) {
                if (elem && 3 !== elem.nodeType && 8 !== elem.nodeType && elem.style) {
                    var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
                    return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], void 0 === value ? hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, !1, extra)) ? ret : style[name] : (type = typeof value, "string" === type && (ret = rcssNum.exec(value)) && ret[1] && (value = adjustCSS(elem, name, ret), type = "number"), null != value && value === value && ("number" === type && (value += ret && ret[3] || (jQuery.cssNumber[origName] ? "" : "px")), support.clearCloneStyle || "" !== value || 0 !== name.indexOf("background") || (style[name] = "inherit"), hooks && "set" in hooks && void 0 === (value = hooks.set(elem, value, extra)) || (style[name] = value)), void 0)
                }
            },
            css: function (elem, name, extra, styles) {
                var val, num, hooks, origName = jQuery.camelCase(name);
                return name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(origName) || origName), hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName], hooks && "get" in hooks && (val = hooks.get(elem, !0, extra)), void 0 === val && (val = curCSS(elem, name, styles)), "normal" === val && name in cssNormalTransform && (val = cssNormalTransform[name]), "" === extra || extra ? (num = parseFloat(val), extra === !0 || isFinite(num) ? num || 0 : val) : val
            }
        }), jQuery.each(["height", "width"], function (i, name) {
            jQuery.cssHooks[name] = {
                get: function (elem, computed, extra) {
                    return computed ? !rdisplayswap.test(jQuery.css(elem, "display")) || elem.getClientRects().length && elem.getBoundingClientRect().width ? getWidthOrHeight(elem, name, extra) : swap(elem, cssShow, function () {
                                return getWidthOrHeight(elem, name, extra)
                            }) : void 0
                }, set: function (elem, value, extra) {
                    var matches, styles = extra && getStyles(elem), subtract = extra && augmentWidthOrHeight(elem, name, extra, "border-box" === jQuery.css(elem, "boxSizing", !1, styles), styles);
                    return subtract && (matches = rcssNum.exec(value)) && "px" !== (matches[3] || "px") && (elem.style[name] = value, value = jQuery.css(elem, name)), setPositiveNumber(elem, value, subtract)
                }
            }
        }), jQuery.cssHooks.marginLeft = addGetHookIf(support.reliableMarginLeft, function (elem, computed) {
            return computed ? (parseFloat(curCSS(elem, "marginLeft")) || elem.getBoundingClientRect().left - swap(elem, {marginLeft: 0}, function () {
                    return elem.getBoundingClientRect().left
                })) + "px" : void 0
        }), jQuery.each({margin: "", padding: "", border: "Width"}, function (prefix, suffix) {
            jQuery.cssHooks[prefix + suffix] = {
                expand: function (value) {
                    for (var i = 0, expanded = {}, parts = "string" == typeof value ? value.split(" ") : [value]; 4 > i; i++)expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
                    return expanded
                }
            }, rmargin.test(prefix) || (jQuery.cssHooks[prefix + suffix].set = setPositiveNumber)
        }), jQuery.fn.extend({
            css: function (name, value) {
                return access(this, function (elem, name, value) {
                    var styles, len, map = {}, i = 0;
                    if (jQuery.isArray(name)) {
                        for (styles = getStyles(elem), len = name.length; len > i; i++)map[name[i]] = jQuery.css(elem, name[i], !1, styles);
                        return map
                    }
                    return void 0 !== value ? jQuery.style(elem, name, value) : jQuery.css(elem, name)
                }, name, value, arguments.length > 1)
            }
        }), jQuery.Tween = Tween, Tween.prototype = {
            constructor: Tween,
            init: function (elem, options, prop, end, easing, unit) {
                this.elem = elem, this.prop = prop, this.easing = easing || jQuery.easing._default, this.options = options, this.start = this.now = this.cur(), this.end = end, this.unit = unit || (jQuery.cssNumber[prop] ? "" : "px")
            },
            cur: function () {
                var hooks = Tween.propHooks[this.prop];
                return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this)
            },
            run: function (percent) {
                var eased, hooks = Tween.propHooks[this.prop];
                return this.options.duration ? this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration) : this.pos = eased = percent, this.now = (this.end - this.start) * eased + this.start, this.options.step && this.options.step.call(this.elem, this.now, this), hooks && hooks.set ? hooks.set(this) : Tween.propHooks._default.set(this), this
            }
        }, Tween.prototype.init.prototype = Tween.prototype, Tween.propHooks = {
            _default: {
                get: function (tween) {
                    var result;
                    return 1 !== tween.elem.nodeType || null != tween.elem[tween.prop] && null == tween.elem.style[tween.prop] ? tween.elem[tween.prop] : (result = jQuery.css(tween.elem, tween.prop, ""), result && "auto" !== result ? result : 0)
                }, set: function (tween) {
                    jQuery.fx.step[tween.prop] ? jQuery.fx.step[tween.prop](tween) : 1 !== tween.elem.nodeType || null == tween.elem.style[jQuery.cssProps[tween.prop]] && !jQuery.cssHooks[tween.prop] ? tween.elem[tween.prop] = tween.now : jQuery.style(tween.elem, tween.prop, tween.now + tween.unit)
                }
            }
        }, Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
            set: function (tween) {
                tween.elem.nodeType && tween.elem.parentNode && (tween.elem[tween.prop] = tween.now)
            }
        }, jQuery.easing = {
            linear: function (p) {
                return p
            }, swing: function (p) {
                return .5 - Math.cos(p * Math.PI) / 2
            }, _default: "swing"
        }, jQuery.fx = Tween.prototype.init, jQuery.fx.step = {};
        var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rrun = /queueHooks$/;
        jQuery.Animation = jQuery.extend(Animation, {
            tweeners: {
                "*": [function (prop, value) {
                    var tween = this.createTween(prop, value);
                    return adjustCSS(tween.elem, prop, rcssNum.exec(value), tween), tween
                }]
            }, tweener: function (props, callback) {
                jQuery.isFunction(props) ? (callback = props, props = ["*"]) : props = props.match(rnotwhite);
                for (var prop, index = 0, length = props.length; length > index; index++)prop = props[index], Animation.tweeners[prop] = Animation.tweeners[prop] || [], Animation.tweeners[prop].unshift(callback)
            }, prefilters: [defaultPrefilter], prefilter: function (callback, prepend) {
                prepend ? Animation.prefilters.unshift(callback) : Animation.prefilters.push(callback)
            }
        }), jQuery.speed = function (speed, easing, fn) {
            var opt = speed && "object" == typeof speed ? jQuery.extend({}, speed) : {
                    complete: fn || !fn && easing || jQuery.isFunction(speed) && speed,
                    duration: speed,
                    easing: fn && easing || easing && !jQuery.isFunction(easing) && easing
                };
            return jQuery.fx.off || document.hidden ? opt.duration = 0 : opt.duration = "number" == typeof opt.duration ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default, (null == opt.queue || opt.queue === !0) && (opt.queue = "fx"), opt.old = opt.complete, opt.complete = function () {
                jQuery.isFunction(opt.old) && opt.old.call(this), opt.queue && jQuery.dequeue(this, opt.queue)
            }, opt
        }, jQuery.fn.extend({
            fadeTo: function (speed, to, easing, callback) {
                return this.filter(isHiddenWithinTree).css("opacity", 0).show().end().animate({opacity: to}, speed, easing, callback)
            }, animate: function (prop, speed, easing, callback) {
                var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function () {
                    var anim = Animation(this, jQuery.extend({}, prop), optall);
                    (empty || dataPriv.get(this, "finish")) && anim.stop(!0)
                };
                return doAnimation.finish = doAnimation, empty || optall.queue === !1 ? this.each(doAnimation) : this.queue(optall.queue, doAnimation)
            }, stop: function (type, clearQueue, gotoEnd) {
                var stopQueue = function (hooks) {
                    var stop = hooks.stop;
                    delete hooks.stop, stop(gotoEnd)
                };
                return "string" != typeof type && (gotoEnd = clearQueue, clearQueue = type, type = void 0), clearQueue && type !== !1 && this.queue(type || "fx", []), this.each(function () {
                    var dequeue = !0, index = null != type && type + "queueHooks", timers = jQuery.timers, data = dataPriv.get(this);
                    if (index) data[index] && data[index].stop && stopQueue(data[index]); else for (index in data)data[index] && data[index].stop && rrun.test(index) && stopQueue(data[index]);
                    for (index = timers.length; index--;)timers[index].elem !== this || null != type && timers[index].queue !== type || (timers[index].anim.stop(gotoEnd), dequeue = !1, timers.splice(index, 1));
                    (dequeue || !gotoEnd) && jQuery.dequeue(this, type)
                })
            }, finish: function (type) {
                return type !== !1 && (type = type || "fx"), this.each(function () {
                    var index, data = dataPriv.get(this), queue = data[type + "queue"], hooks = data[type + "queueHooks"], timers = jQuery.timers, length = queue ? queue.length : 0;
                    for (data.finish = !0, jQuery.queue(this, type, []), hooks && hooks.stop && hooks.stop.call(this, !0), index = timers.length; index--;)timers[index].elem === this && timers[index].queue === type && (timers[index].anim.stop(!0), timers.splice(index, 1));
                    for (index = 0; length > index; index++)queue[index] && queue[index].finish && queue[index].finish.call(this);
                    delete data.finish
                })
            }
        }), jQuery.each(["toggle", "show", "hide"], function (i, name) {
            var cssFn = jQuery.fn[name];
            jQuery.fn[name] = function (speed, easing, callback) {
                return null == speed || "boolean" == typeof speed ? cssFn.apply(this, arguments) : this.animate(genFx(name, !0), speed, easing, callback)
            }
        }), jQuery.each({
            slideDown: genFx("show"),
            slideUp: genFx("hide"),
            slideToggle: genFx("toggle"),
            fadeIn: {opacity: "show"},
            fadeOut: {opacity: "hide"},
            fadeToggle: {opacity: "toggle"}
        }, function (name, props) {
            jQuery.fn[name] = function (speed, easing, callback) {
                return this.animate(props, speed, easing, callback)
            }
        }), jQuery.timers = [], jQuery.fx.tick = function () {
            var timer, i = 0, timers = jQuery.timers;
            for (fxNow = jQuery.now(); i < timers.length; i++)timer = timers[i], timer() || timers[i] !== timer || timers.splice(i--, 1);
            timers.length || jQuery.fx.stop(), fxNow = void 0
        }, jQuery.fx.timer = function (timer) {
            jQuery.timers.push(timer), timer() ? jQuery.fx.start() : jQuery.timers.pop()
        }, jQuery.fx.interval = 13, jQuery.fx.start = function () {
            timerId || (timerId = window.requestAnimationFrame ? window.requestAnimationFrame(raf) : window.setInterval(jQuery.fx.tick, jQuery.fx.interval))
        }, jQuery.fx.stop = function () {
            window.cancelAnimationFrame ? window.cancelAnimationFrame(timerId) : window.clearInterval(timerId), timerId = null
        }, jQuery.fx.speeds = {slow: 600, fast: 200, _default: 400}, jQuery.fn.delay = function (time, type) {
            return time = jQuery.fx ? jQuery.fx.speeds[time] || time : time, type = type || "fx", this.queue(type, function (next, hooks) {
                var timeout = window.setTimeout(next, time);
                hooks.stop = function () {
                    window.clearTimeout(timeout)
                }
            })
        }, function () {
            var input = document.createElement("input"), select = document.createElement("select"), opt = select.appendChild(document.createElement("option"));
            input.type = "checkbox", support.checkOn = "" !== input.value, support.optSelected = opt.selected, input = document.createElement("input"), input.value = "t", input.type = "radio", support.radioValue = "t" === input.value
        }();
        var boolHook, attrHandle = jQuery.expr.attrHandle;
        jQuery.fn.extend({
            attr: function (name, value) {
                return access(this, jQuery.attr, name, value, arguments.length > 1)
            }, removeAttr: function (name) {
                return this.each(function () {
                    jQuery.removeAttr(this, name)
                })
            }
        }), jQuery.extend({
            attr: function (elem, name, value) {
                var ret, hooks, nType = elem.nodeType;
                if (3 !== nType && 8 !== nType && 2 !== nType)return "undefined" == typeof elem.getAttribute ? jQuery.prop(elem, name, value) : (1 === nType && jQuery.isXMLDoc(elem) || (hooks = jQuery.attrHooks[name.toLowerCase()] || (jQuery.expr.match.bool.test(name) ? boolHook : void 0)), void 0 !== value ? null === value ? void jQuery.removeAttr(elem, name) : hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : (elem.setAttribute(name, value + ""), value) : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : (ret = jQuery.find.attr(elem, name), null == ret ? void 0 : ret))
            }, attrHooks: {
                type: {
                    set: function (elem, value) {
                        if (!support.radioValue && "radio" === value && jQuery.nodeName(elem, "input")) {
                            var val = elem.value;
                            return elem.setAttribute("type", value), val && (elem.value = val), value
                        }
                    }
                }
            }, removeAttr: function (elem, value) {
                var name, i = 0, attrNames = value && value.match(rnotwhite);
                if (attrNames && 1 === elem.nodeType)for (; name = attrNames[i++];)elem.removeAttribute(name)
            }
        }), boolHook = {
            set: function (elem, value, name) {
                return value === !1 ? jQuery.removeAttr(elem, name) : elem.setAttribute(name, name), name
            }
        }, jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function (i, name) {
            var getter = attrHandle[name] || jQuery.find.attr;
            attrHandle[name] = function (elem, name, isXML) {
                var ret, handle, lowercaseName = name.toLowerCase();
                return isXML || (handle = attrHandle[lowercaseName], attrHandle[lowercaseName] = ret, ret = null != getter(elem, name, isXML) ? lowercaseName : null, attrHandle[lowercaseName] = handle), ret
            }
        });
        var rfocusable = /^(?:input|select|textarea|button)$/i, rclickable = /^(?:a|area)$/i;
        jQuery.fn.extend({
            prop: function (name, value) {
                return access(this, jQuery.prop, name, value, arguments.length > 1)
            }, removeProp: function (name) {
                return this.each(function () {
                    delete this[jQuery.propFix[name] || name]
                })
            }
        }), jQuery.extend({
            prop: function (elem, name, value) {
                var ret, hooks, nType = elem.nodeType;
                if (3 !== nType && 8 !== nType && 2 !== nType)return 1 === nType && jQuery.isXMLDoc(elem) || (name = jQuery.propFix[name] || name, hooks = jQuery.propHooks[name]), void 0 !== value ? hooks && "set" in hooks && void 0 !== (ret = hooks.set(elem, value, name)) ? ret : elem[name] = value : hooks && "get" in hooks && null !== (ret = hooks.get(elem, name)) ? ret : elem[name]
            }, propHooks: {
                tabIndex: {
                    get: function (elem) {
                        var tabindex = jQuery.find.attr(elem, "tabindex");
                        return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1
                    }
                }
            }, propFix: {"for": "htmlFor", "class": "className"}
        }), support.optSelected || (jQuery.propHooks.selected = {
            get: function (elem) {
                var parent = elem.parentNode;
                return parent && parent.parentNode && parent.parentNode.selectedIndex, null
            }, set: function (elem) {
                var parent = elem.parentNode;
                parent && (parent.selectedIndex, parent.parentNode && parent.parentNode.selectedIndex)
            }
        }), jQuery.each(["tabIndex", "readOnly", "maxLength", "cellSpacing", "cellPadding", "rowSpan", "colSpan", "useMap", "frameBorder", "contentEditable"], function () {
            jQuery.propFix[this.toLowerCase()] = this
        });
        var rclass = /[\t\r\n\f]/g;
        jQuery.fn.extend({
            addClass: function (value) {
                var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
                if (jQuery.isFunction(value))return this.each(function (j) {
                    jQuery(this).addClass(value.call(this, j, getClass(this)))
                });
                if ("string" == typeof value && value)for (classes = value.match(rnotwhite) || []; elem = this[i++];)if (curValue = getClass(elem), cur = 1 === elem.nodeType && (" " + curValue + " ").replace(rclass, " ")) {
                    for (j = 0; clazz = classes[j++];)cur.indexOf(" " + clazz + " ") < 0 && (cur += clazz + " ");
                    finalValue = jQuery.trim(cur), curValue !== finalValue && elem.setAttribute("class", finalValue)
                }
                return this
            }, removeClass: function (value) {
                var classes, elem, cur, curValue, clazz, j, finalValue, i = 0;
                if (jQuery.isFunction(value))return this.each(function (j) {
                    jQuery(this).removeClass(value.call(this, j, getClass(this)))
                });
                if (!arguments.length)return this.attr("class", "");
                if ("string" == typeof value && value)for (classes = value.match(rnotwhite) || []; elem = this[i++];)if (curValue = getClass(elem), cur = 1 === elem.nodeType && (" " + curValue + " ").replace(rclass, " ")) {
                    for (j = 0; clazz = classes[j++];)for (; cur.indexOf(" " + clazz + " ") > -1;)cur = cur.replace(" " + clazz + " ", " ");
                    finalValue = jQuery.trim(cur), curValue !== finalValue && elem.setAttribute("class", finalValue)
                }
                return this
            }, toggleClass: function (value, stateVal) {
                var type = typeof value;
                return "boolean" == typeof stateVal && "string" === type ? stateVal ? this.addClass(value) : this.removeClass(value) : jQuery.isFunction(value) ? this.each(function (i) {
                            jQuery(this).toggleClass(value.call(this, i, getClass(this), stateVal), stateVal)
                        }) : this.each(function () {
                            var className, i, self, classNames;
                            if ("string" === type)for (i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || []; className = classNames[i++];)self.hasClass(className) ? self.removeClass(className) : self.addClass(className); else(void 0 === value || "boolean" === type) && (className = getClass(this), className && dataPriv.set(this, "__className__", className), this.setAttribute && this.setAttribute("class", className || value === !1 ? "" : dataPriv.get(this, "__className__") || ""))
                        })
            }, hasClass: function (selector) {
                var className, elem, i = 0;
                for (className = " " + selector + " "; elem = this[i++];)if (1 === elem.nodeType && (" " + getClass(elem) + " ").replace(rclass, " ").indexOf(className) > -1)return !0;
                return !1
            }
        });
        var rreturn = /\r/g, rspaces = /[\x20\t\r\n\f]+/g;
        jQuery.fn.extend({
            val: function (value) {
                var hooks, ret, isFunction, elem = this[0];
                {
                    if (arguments.length)return isFunction = jQuery.isFunction(value), this.each(function (i) {
                        var val;
                        1 === this.nodeType && (val = isFunction ? value.call(this, i, jQuery(this).val()) : value, null == val ? val = "" : "number" == typeof val ? val += "" : jQuery.isArray(val) && (val = jQuery.map(val, function (value) {
                                    return null == value ? "" : value + ""
                                })), hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()], hooks && "set" in hooks && void 0 !== hooks.set(this, val, "value") || (this.value = val))
                    });
                    if (elem)return hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()], hooks && "get" in hooks && void 0 !== (ret = hooks.get(elem, "value")) ? ret : (ret = elem.value, "string" == typeof ret ? ret.replace(rreturn, "") : null == ret ? "" : ret)
                }
            }
        }), jQuery.extend({
            valHooks: {
                option: {
                    get: function (elem) {
                        var val = jQuery.find.attr(elem, "value");
                        return null != val ? val : jQuery.trim(jQuery.text(elem)).replace(rspaces, " ")
                    }
                }, select: {
                    get: function (elem) {
                        for (var value, option, options = elem.options, index = elem.selectedIndex, one = "select-one" === elem.type, values = one ? null : [], max = one ? index + 1 : options.length, i = 0 > index ? max : one ? index : 0; max > i; i++)if (option = options[i], (option.selected || i === index) && !option.disabled && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, "optgroup"))) {
                            if (value = jQuery(option).val(), one)return value;
                            values.push(value)
                        }
                        return values
                    }, set: function (elem, value) {
                        for (var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length; i--;)option = options[i], (option.selected = jQuery.inArray(jQuery.valHooks.option.get(option), values) > -1) && (optionSet = !0);
                        return optionSet || (elem.selectedIndex = -1), values
                    }
                }
            }
        }), jQuery.each(["radio", "checkbox"], function () {
            jQuery.valHooks[this] = {
                set: function (elem, value) {
                    return jQuery.isArray(value) ? elem.checked = jQuery.inArray(jQuery(elem).val(), value) > -1 : void 0
                }
            }, support.checkOn || (jQuery.valHooks[this].get = function (elem) {
                return null === elem.getAttribute("value") ? "on" : elem.value
            })
        });
        var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;
        jQuery.extend(jQuery.event, {
            trigger: function (event, data, elem, onlyHandlers) {
                var i, cur, tmp, bubbleType, ontype, handle, special, eventPath = [elem || document], type = hasOwn.call(event, "type") ? event.type : event, namespaces = hasOwn.call(event, "namespace") ? event.namespace.split(".") : [];
                if (cur = tmp = elem = elem || document, 3 !== elem.nodeType && 8 !== elem.nodeType && !rfocusMorph.test(type + jQuery.event.triggered) && (type.indexOf(".") > -1 && (namespaces = type.split("."), type = namespaces.shift(), namespaces.sort()), ontype = type.indexOf(":") < 0 && "on" + type, event = event[jQuery.expando] ? event : new jQuery.Event(type, "object" == typeof event && event), event.isTrigger = onlyHandlers ? 2 : 3, event.namespace = namespaces.join("."), event.rnamespace = event.namespace ? new RegExp("(^|\\.)" + namespaces.join("\\.(?:.*\\.|)") + "(\\.|$)") : null, event.result = void 0, event.target || (event.target = elem), data = null == data ? [event] : jQuery.makeArray(data, [event]), special = jQuery.event.special[type] || {}, onlyHandlers || !special.trigger || special.trigger.apply(elem, data) !== !1)) {
                    if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
                        for (bubbleType = special.delegateType || type, rfocusMorph.test(bubbleType + type) || (cur = cur.parentNode); cur; cur = cur.parentNode)eventPath.push(cur), tmp = cur;
                        tmp === (elem.ownerDocument || document) && eventPath.push(tmp.defaultView || tmp.parentWindow || window)
                    }
                    for (i = 0; (cur = eventPath[i++]) && !event.isPropagationStopped();)event.type = i > 1 ? bubbleType : special.bindType || type, handle = (dataPriv.get(cur, "events") || {})[event.type] && dataPriv.get(cur, "handle"), handle && handle.apply(cur, data), handle = ontype && cur[ontype], handle && handle.apply && acceptData(cur) && (event.result = handle.apply(cur, data), event.result === !1 && event.preventDefault());
                    return event.type = type, onlyHandlers || event.isDefaultPrevented() || special._default && special._default.apply(eventPath.pop(), data) !== !1 || !acceptData(elem) || ontype && jQuery.isFunction(elem[type]) && !jQuery.isWindow(elem) && (tmp = elem[ontype], tmp && (elem[ontype] = null), jQuery.event.triggered = type, elem[type](), jQuery.event.triggered = void 0, tmp && (elem[ontype] = tmp)), event.result
                }
            }, simulate: function (type, elem, event) {
                var e = jQuery.extend(new jQuery.Event, event, {type: type, isSimulated: !0});
                jQuery.event.trigger(e, null, elem)
            }
        }), jQuery.fn.extend({
            trigger: function (type, data) {
                return this.each(function () {
                    jQuery.event.trigger(type, data, this)
                })
            }, triggerHandler: function (type, data) {
                var elem = this[0];
                return elem ? jQuery.event.trigger(type, data, elem, !0) : void 0
            }
        }), jQuery.each("blur focus focusin focusout resize scroll click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup contextmenu".split(" "), function (i, name) {
            jQuery.fn[name] = function (data, fn) {
                return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name)
            }
        }), jQuery.fn.extend({
            hover: function (fnOver, fnOut) {
                return this.mouseenter(fnOver).mouseleave(fnOut || fnOver)
            }
        }), support.focusin = "onfocusin" in window, support.focusin || jQuery.each({
            focus: "focusin",
            blur: "focusout"
        }, function (orig, fix) {
            var handler = function (event) {
                jQuery.event.simulate(fix, event.target, jQuery.event.fix(event))
            };
            jQuery.event.special[fix] = {
                setup: function () {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix);
                    attaches || doc.addEventListener(orig, handler, !0), dataPriv.access(doc, fix, (attaches || 0) + 1)
                }, teardown: function () {
                    var doc = this.ownerDocument || this, attaches = dataPriv.access(doc, fix) - 1;
                    attaches ? dataPriv.access(doc, fix, attaches) : (doc.removeEventListener(orig, handler, !0), dataPriv.remove(doc, fix))
                }
            }
        });
        var location = window.location, nonce = jQuery.now(), rquery = /\?/;
        jQuery.parseXML = function (data) {
            var xml;
            if (!data || "string" != typeof data)return null;
            try {
                xml = (new window.DOMParser).parseFromString(data, "text/xml")
            } catch (e) {
                xml = void 0
            }
            return (!xml || xml.getElementsByTagName("parsererror").length) && jQuery.error("Invalid XML: " + data), xml
        };
        var rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
        jQuery.param = function (a, traditional) {
            var prefix, s = [], add = function (key, valueOrFunction) {
                var value = jQuery.isFunction(valueOrFunction) ? valueOrFunction() : valueOrFunction;
                s[s.length] = encodeURIComponent(key) + "=" + encodeURIComponent(null == value ? "" : value)
            };
            if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) jQuery.each(a, function () {
                add(this.name, this.value)
            }); else for (prefix in a)buildParams(prefix, a[prefix], traditional, add);
            return s.join("&")
        }, jQuery.fn.extend({
            serialize: function () {
                return jQuery.param(this.serializeArray())
            }, serializeArray: function () {
                return this.map(function () {
                    var elements = jQuery.prop(this, "elements");
                    return elements ? jQuery.makeArray(elements) : this
                }).filter(function () {
                    var type = this.type;
                    return this.name && !jQuery(this).is(":disabled") && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type))
                }).map(function (i, elem) {
                    var val = jQuery(this).val();
                    return null == val ? null : jQuery.isArray(val) ? jQuery.map(val, function (val) {
                                return {name: elem.name, value: val.replace(rCRLF, "\r\n")}
                            }) : {name: elem.name, value: val.replace(rCRLF, "\r\n")}
                }).get()
            }
        });
        var r20 = /%20/g, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)$/gm, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, prefilters = {}, transports = {}, allTypes = "*/".concat("*"), originAnchor = document.createElement("a");
        originAnchor.href = location.href, jQuery.extend({
            active: 0,
            lastModified: {},
            etag: {},
            ajaxSettings: {
                url: location.href,
                type: "GET",
                isLocal: rlocalProtocol.test(location.protocol),
                global: !0,
                processData: !0,
                async: !0,
                contentType: "application/x-www-form-urlencoded; charset=UTF-8",
                accepts: {
                    "*": allTypes,
                    text: "text/plain",
                    html: "text/html",
                    xml: "application/xml, text/xml",
                    json: "application/json, text/javascript"
                },
                contents: {xml: /\bxml\b/, html: /\bhtml/, json: /\bjson\b/},
                responseFields: {xml: "responseXML", text: "responseText", json: "responseJSON"},
                converters: {"* text": String, "text html": !0, "text json": JSON.parse, "text xml": jQuery.parseXML},
                flatOptions: {url: !0, context: !0}
            },
            ajaxSetup: function (target, settings) {
                return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target)
            },
            ajaxPrefilter: addToPrefiltersOrTransports(prefilters),
            ajaxTransport: addToPrefiltersOrTransports(transports),
            ajax: function (url, options) {
                function done(status, nativeStatusText, responses, headers) {
                    var isSuccess, success, error, response, modified, statusText = nativeStatusText;
                    completed || (completed = !0, timeoutTimer && window.clearTimeout(timeoutTimer), transport = void 0, responseHeadersString = headers || "", jqXHR.readyState = status > 0 ? 4 : 0, isSuccess = status >= 200 && 300 > status || 304 === status, responses && (response = ajaxHandleResponses(s, jqXHR, responses)), response = ajaxConvert(s, response, jqXHR, isSuccess), isSuccess ? (s.ifModified && (modified = jqXHR.getResponseHeader("Last-Modified"), modified && (jQuery.lastModified[cacheURL] = modified), modified = jqXHR.getResponseHeader("etag"), modified && (jQuery.etag[cacheURL] = modified)), 204 === status || "HEAD" === s.type ? statusText = "nocontent" : 304 === status ? statusText = "notmodified" : (statusText = response.state, success = response.data, error = response.error, isSuccess = !error)) : (error = statusText, (status || !statusText) && (statusText = "error", 0 > status && (status = 0))), jqXHR.status = status, jqXHR.statusText = (nativeStatusText || statusText) + "", isSuccess ? deferred.resolveWith(callbackContext, [success, statusText, jqXHR]) : deferred.rejectWith(callbackContext, [jqXHR, statusText, error]), jqXHR.statusCode(statusCode), statusCode = void 0, fireGlobals && globalEventContext.trigger(isSuccess ? "ajaxSuccess" : "ajaxError", [jqXHR, s, isSuccess ? success : error]), completeDeferred.fireWith(callbackContext, [jqXHR, statusText]), fireGlobals && (globalEventContext.trigger("ajaxComplete", [jqXHR, s]), --jQuery.active || jQuery.event.trigger("ajaxStop")))
                }

                "object" == typeof url && (options = url, url = void 0), options = options || {};
                var transport, cacheURL, responseHeadersString, responseHeaders, timeoutTimer, urlAnchor, completed, fireGlobals, i, uncached, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks("once memory"), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, strAbort = "canceled", jqXHR = {
                    readyState: 0,
                    getResponseHeader: function (key) {
                        var match;
                        if (completed) {
                            if (!responseHeaders)for (responseHeaders = {}; match = rheaders.exec(responseHeadersString);)responseHeaders[match[1].toLowerCase()] = match[2];
                            match = responseHeaders[key.toLowerCase()]
                        }
                        return null == match ? null : match
                    },
                    getAllResponseHeaders: function () {
                        return completed ? responseHeadersString : null
                    },
                    setRequestHeader: function (name, value) {
                        return null == completed && (name = requestHeadersNames[name.toLowerCase()] = requestHeadersNames[name.toLowerCase()] || name, requestHeaders[name] = value), this
                    },
                    overrideMimeType: function (type) {
                        return null == completed && (s.mimeType = type), this
                    },
                    statusCode: function (map) {
                        var code;
                        if (map)if (completed) jqXHR.always(map[jqXHR.status]); else for (code in map)statusCode[code] = [statusCode[code], map[code]];
                        return this
                    },
                    abort: function (statusText) {
                        var finalText = statusText || strAbort;
                        return transport && transport.abort(finalText), done(0, finalText), this
                    }
                };
                if (deferred.promise(jqXHR), s.url = ((url || s.url || location.href) + "").replace(rprotocol, location.protocol + "//"), s.type = options.method || options.type || s.method || s.type, s.dataTypes = (s.dataType || "*").toLowerCase().match(rnotwhite) || [""], null == s.crossDomain) {
                    urlAnchor = document.createElement("a");
                    try {
                        urlAnchor.href = s.url, urlAnchor.href = urlAnchor.href, s.crossDomain = originAnchor.protocol + "//" + originAnchor.host != urlAnchor.protocol + "//" + urlAnchor.host
                    } catch (e) {
                        s.crossDomain = !0
                    }
                }
                if (s.data && s.processData && "string" != typeof s.data && (s.data = jQuery.param(s.data, s.traditional)), inspectPrefiltersOrTransports(prefilters, s, options, jqXHR), completed)return jqXHR;
                fireGlobals = jQuery.event && s.global, fireGlobals && 0 === jQuery.active++ && jQuery.event.trigger("ajaxStart"), s.type = s.type.toUpperCase(), s.hasContent = !rnoContent.test(s.type), cacheURL = s.url.replace(rhash, ""), s.hasContent ? s.data && s.processData && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && (s.data = s.data.replace(r20, "+")) : (uncached = s.url.slice(cacheURL.length), s.data && (cacheURL += (rquery.test(cacheURL) ? "&" : "?") + s.data, delete s.data), s.cache === !1 && (cacheURL = cacheURL.replace(rts, ""), uncached = (rquery.test(cacheURL) ? "&" : "?") + "_=" + nonce++ + uncached), s.url = cacheURL + uncached), s.ifModified && (jQuery.lastModified[cacheURL] && jqXHR.setRequestHeader("If-Modified-Since", jQuery.lastModified[cacheURL]), jQuery.etag[cacheURL] && jqXHR.setRequestHeader("If-None-Match", jQuery.etag[cacheURL])), (s.data && s.hasContent && s.contentType !== !1 || options.contentType) && jqXHR.setRequestHeader("Content-Type", s.contentType), jqXHR.setRequestHeader("Accept", s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + ("*" !== s.dataTypes[0] ? ", " + allTypes + "; q=0.01" : "") : s.accepts["*"]);
                for (i in s.headers)jqXHR.setRequestHeader(i, s.headers[i]);
                if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === !1 || completed))return jqXHR.abort();
                if (strAbort = "abort", completeDeferred.add(s.complete), jqXHR.done(s.success), jqXHR.fail(s.error), transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR)) {
                    if (jqXHR.readyState = 1, fireGlobals && globalEventContext.trigger("ajaxSend", [jqXHR, s]), completed)return jqXHR;
                    s.async && s.timeout > 0 && (timeoutTimer = window.setTimeout(function () {
                        jqXHR.abort("timeout")
                    }, s.timeout));
                    try {
                        completed = !1, transport.send(requestHeaders, done)
                    } catch (e) {
                        if (completed)throw e;
                        done(-1, e)
                    }
                } else done(-1, "No Transport");
                return jqXHR
            },
            getJSON: function (url, data, callback) {
                return jQuery.get(url, data, callback, "json")
            },
            getScript: function (url, callback) {
                return jQuery.get(url, void 0, callback, "script")
            }
        }), jQuery.each(["get", "post"], function (i, method) {
            jQuery[method] = function (url, data, callback, type) {
                return jQuery.isFunction(data) && (type = type || callback, callback = data, data = void 0), jQuery.ajax(jQuery.extend({
                    url: url,
                    type: method,
                    dataType: type,
                    data: data,
                    success: callback
                }, jQuery.isPlainObject(url) && url))
            }
        }), jQuery._evalUrl = function (url) {
            return jQuery.ajax({
                url: url,
                type: "GET",
                dataType: "script",
                cache: !0,
                async: !1,
                global: !1,
                "throws": !0
            })
        }, jQuery.fn.extend({
            wrapAll: function (html) {
                var wrap;
                return this[0] && (jQuery.isFunction(html) && (html = html.call(this[0])), wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(!0), this[0].parentNode && wrap.insertBefore(this[0]), wrap.map(function () {
                    for (var elem = this; elem.firstElementChild;)elem = elem.firstElementChild;
                    return elem
                }).append(this)), this
            }, wrapInner: function (html) {
                return jQuery.isFunction(html) ? this.each(function (i) {
                        jQuery(this).wrapInner(html.call(this, i))
                    }) : this.each(function () {
                        var self = jQuery(this), contents = self.contents();
                        contents.length ? contents.wrapAll(html) : self.append(html)
                    })
            }, wrap: function (html) {
                var isFunction = jQuery.isFunction(html);
                return this.each(function (i) {
                    jQuery(this).wrapAll(isFunction ? html.call(this, i) : html)
                })
            }, unwrap: function (selector) {
                return this.parent(selector).not("body").each(function () {
                    jQuery(this).replaceWith(this.childNodes)
                }), this
            }
        }), jQuery.expr.pseudos.hidden = function (elem) {
            return !jQuery.expr.pseudos.visible(elem)
        }, jQuery.expr.pseudos.visible = function (elem) {
            return !!(elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length)
        }, jQuery.ajaxSettings.xhr = function () {
            try {
                return new window.XMLHttpRequest
            } catch (e) {
            }
        };
        var xhrSuccessStatus = {0: 200, 1223: 204}, xhrSupported = jQuery.ajaxSettings.xhr();
        support.cors = !!xhrSupported && "withCredentials" in xhrSupported, support.ajax = xhrSupported = !!xhrSupported, jQuery.ajaxTransport(function (options) {
            var callback, errorCallback;
            return support.cors || xhrSupported && !options.crossDomain ? {
                    send: function (headers, complete) {
                        var i, xhr = options.xhr();
                        if (xhr.open(options.type, options.url, options.async, options.username, options.password), options.xhrFields)for (i in options.xhrFields)xhr[i] = options.xhrFields[i];
                        options.mimeType && xhr.overrideMimeType && xhr.overrideMimeType(options.mimeType), options.crossDomain || headers["X-Requested-With"] || (headers["X-Requested-With"] = "XMLHttpRequest");
                        for (i in headers)xhr.setRequestHeader(i, headers[i]);
                        callback = function (type) {
                            return function () {
                                callback && (callback = errorCallback = xhr.onload = xhr.onerror = xhr.onabort = xhr.onreadystatechange = null,
                                    "abort" === type ? xhr.abort() : "error" === type ? "number" != typeof xhr.status ? complete(0, "error") : complete(xhr.status, xhr.statusText) : complete(xhrSuccessStatus[xhr.status] || xhr.status, xhr.statusText, "text" !== (xhr.responseType || "text") || "string" != typeof xhr.responseText ? {binary: xhr.response} : {text: xhr.responseText}, xhr.getAllResponseHeaders()))
                            }
                        }, xhr.onload = callback(), errorCallback = xhr.onerror = callback("error"), void 0 !== xhr.onabort ? xhr.onabort = errorCallback : xhr.onreadystatechange = function () {
                                4 === xhr.readyState && window.setTimeout(function () {
                                    callback && errorCallback()
                                })
                            }, callback = callback("abort");
                        try {
                            xhr.send(options.hasContent && options.data || null)
                        } catch (e) {
                            if (callback)throw e
                        }
                    }, abort: function () {
                        callback && callback()
                    }
                } : void 0
        }), jQuery.ajaxPrefilter(function (s) {
            s.crossDomain && (s.contents.script = !1)
        }), jQuery.ajaxSetup({
            accepts: {script: "text/javascript, application/javascript, application/ecmascript, application/x-ecmascript"},
            contents: {script: /\b(?:java|ecma)script\b/},
            converters: {
                "text script": function (text) {
                    return jQuery.globalEval(text), text
                }
            }
        }), jQuery.ajaxPrefilter("script", function (s) {
            void 0 === s.cache && (s.cache = !1), s.crossDomain && (s.type = "GET")
        }), jQuery.ajaxTransport("script", function (s) {
            if (s.crossDomain) {
                var script, callback;
                return {
                    send: function (_, complete) {
                        script = jQuery("<script>").prop({
                            charset: s.scriptCharset,
                            src: s.url
                        }).on("load error", callback = function (evt) {
                            script.remove(), callback = null, evt && complete("error" === evt.type ? 404 : 200, evt.type)
                        }), document.head.appendChild(script[0])
                    }, abort: function () {
                        callback && callback()
                    }
                }
            }
        });
        var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
        jQuery.ajaxSetup({
            jsonp: "callback", jsonpCallback: function () {
                var callback = oldCallbacks.pop() || jQuery.expando + "_" + nonce++;
                return this[callback] = !0, callback
            }
        }), jQuery.ajaxPrefilter("json jsonp", function (s, originalSettings, jqXHR) {
            var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== !1 && (rjsonp.test(s.url) ? "url" : "string" == typeof s.data && 0 === (s.contentType || "").indexOf("application/x-www-form-urlencoded") && rjsonp.test(s.data) && "data");
            return jsonProp || "jsonp" === s.dataTypes[0] ? (callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback, jsonProp ? s[jsonProp] = s[jsonProp].replace(rjsonp, "$1" + callbackName) : s.jsonp !== !1 && (s.url += (rquery.test(s.url) ? "&" : "?") + s.jsonp + "=" + callbackName), s.converters["script json"] = function () {
                    return responseContainer || jQuery.error(callbackName + " was not called"), responseContainer[0]
                }, s.dataTypes[0] = "json", overwritten = window[callbackName], window[callbackName] = function () {
                    responseContainer = arguments
                }, jqXHR.always(function () {
                    void 0 === overwritten ? jQuery(window).removeProp(callbackName) : window[callbackName] = overwritten, s[callbackName] && (s.jsonpCallback = originalSettings.jsonpCallback, oldCallbacks.push(callbackName)), responseContainer && jQuery.isFunction(overwritten) && overwritten(responseContainer[0]), responseContainer = overwritten = void 0
                }), "script") : void 0
        }), support.createHTMLDocument = function () {
            var body = document.implementation.createHTMLDocument("").body;
            return body.innerHTML = "<form></form><form></form>", 2 === body.childNodes.length
        }(), jQuery.parseHTML = function (data, context, keepScripts) {
            if ("string" != typeof data)return [];
            "boolean" == typeof context && (keepScripts = context, context = !1);
            var base, parsed, scripts;
            return context || (support.createHTMLDocument ? (context = document.implementation.createHTMLDocument(""), base = context.createElement("base"), base.href = document.location.href, context.head.appendChild(base)) : context = document), parsed = rsingleTag.exec(data), scripts = !keepScripts && [], parsed ? [context.createElement(parsed[1])] : (parsed = buildFragment([data], context, scripts), scripts && scripts.length && jQuery(scripts).remove(), jQuery.merge([], parsed.childNodes))
        }, jQuery.fn.load = function (url, params, callback) {
            var selector, type, response, self = this, off = url.indexOf(" ");
            return off > -1 && (selector = jQuery.trim(url.slice(off)), url = url.slice(0, off)), jQuery.isFunction(params) ? (callback = params, params = void 0) : params && "object" == typeof params && (type = "POST"), self.length > 0 && jQuery.ajax({
                url: url,
                type: type || "GET",
                dataType: "html",
                data: params
            }).done(function (responseText) {
                response = arguments, self.html(selector ? jQuery("<div>").append(jQuery.parseHTML(responseText)).find(selector) : responseText)
            }).always(callback && function (jqXHR, status) {
                    self.each(function () {
                        callback.apply(this, response || [jqXHR.responseText, status, jqXHR])
                    })
                }), this
        }, jQuery.each(["ajaxStart", "ajaxStop", "ajaxComplete", "ajaxError", "ajaxSuccess", "ajaxSend"], function (i, type) {
            jQuery.fn[type] = function (fn) {
                return this.on(type, fn)
            }
        }), jQuery.expr.pseudos.animated = function (elem) {
            return jQuery.grep(jQuery.timers, function (fn) {
                return elem === fn.elem
            }).length
        }, jQuery.offset = {
            setOffset: function (elem, options, i) {
                var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, "position"), curElem = jQuery(elem), props = {};
                "static" === position && (elem.style.position = "relative"), curOffset = curElem.offset(), curCSSTop = jQuery.css(elem, "top"), curCSSLeft = jQuery.css(elem, "left"), calculatePosition = ("absolute" === position || "fixed" === position) && (curCSSTop + curCSSLeft).indexOf("auto") > -1, calculatePosition ? (curPosition = curElem.position(), curTop = curPosition.top, curLeft = curPosition.left) : (curTop = parseFloat(curCSSTop) || 0, curLeft = parseFloat(curCSSLeft) || 0), jQuery.isFunction(options) && (options = options.call(elem, i, jQuery.extend({}, curOffset))), null != options.top && (props.top = options.top - curOffset.top + curTop), null != options.left && (props.left = options.left - curOffset.left + curLeft), "using" in options ? options.using.call(elem, props) : curElem.css(props)
            }
        }, jQuery.fn.extend({
            offset: function (options) {
                if (arguments.length)return void 0 === options ? this : this.each(function (i) {
                        jQuery.offset.setOffset(this, options, i)
                    });
                var docElem, win, rect, doc, elem = this[0];
                if (elem)return elem.getClientRects().length ? (rect = elem.getBoundingClientRect(), rect.width || rect.height ? (doc = elem.ownerDocument, win = getWindow(doc), docElem = doc.documentElement, {
                            top: rect.top + win.pageYOffset - docElem.clientTop,
                            left: rect.left + win.pageXOffset - docElem.clientLeft
                        }) : rect) : {top: 0, left: 0}
            }, position: function () {
                if (this[0]) {
                    var offsetParent, offset, elem = this[0], parentOffset = {top: 0, left: 0};
                    return "fixed" === jQuery.css(elem, "position") ? offset = elem.getBoundingClientRect() : (offsetParent = this.offsetParent(), offset = this.offset(), jQuery.nodeName(offsetParent[0], "html") || (parentOffset = offsetParent.offset()), parentOffset = {
                            top: parentOffset.top + jQuery.css(offsetParent[0], "borderTopWidth", !0),
                            left: parentOffset.left + jQuery.css(offsetParent[0], "borderLeftWidth", !0)
                        }), {
                        top: offset.top - parentOffset.top - jQuery.css(elem, "marginTop", !0),
                        left: offset.left - parentOffset.left - jQuery.css(elem, "marginLeft", !0)
                    }
                }
            }, offsetParent: function () {
                return this.map(function () {
                    for (var offsetParent = this.offsetParent; offsetParent && "static" === jQuery.css(offsetParent, "position");)offsetParent = offsetParent.offsetParent;
                    return offsetParent || documentElement
                })
            }
        }), jQuery.each({scrollLeft: "pageXOffset", scrollTop: "pageYOffset"}, function (method, prop) {
            var top = "pageYOffset" === prop;
            jQuery.fn[method] = function (val) {
                return access(this, function (elem, method, val) {
                    var win = getWindow(elem);
                    return void 0 === val ? win ? win[prop] : elem[method] : void(win ? win.scrollTo(top ? win.pageXOffset : val, top ? val : win.pageYOffset) : elem[method] = val)
                }, method, val, arguments.length)
            }
        }), jQuery.each(["top", "left"], function (i, prop) {
            jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function (elem, computed) {
                return computed ? (computed = curCSS(elem, prop), rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + "px" : computed) : void 0
            })
        }), jQuery.each({Height: "height", Width: "width"}, function (name, type) {
            jQuery.each({
                padding: "inner" + name,
                content: type,
                "": "outer" + name
            }, function (defaultExtra, funcName) {
                jQuery.fn[funcName] = function (margin, value) {
                    var chainable = arguments.length && (defaultExtra || "boolean" != typeof margin), extra = defaultExtra || (margin === !0 || value === !0 ? "margin" : "border");
                    return access(this, function (elem, type, value) {
                        var doc;
                        return jQuery.isWindow(elem) ? 0 === funcName.indexOf("outer") ? elem["inner" + name] : elem.document.documentElement["client" + name] : 9 === elem.nodeType ? (doc = elem.documentElement, Math.max(elem.body["scroll" + name], doc["scroll" + name], elem.body["offset" + name], doc["offset" + name], doc["client" + name])) : void 0 === value ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra)
                    }, type, chainable ? margin : void 0, chainable)
                }
            })
        }), jQuery.fn.extend({
            bind: function (types, data, fn) {
                return this.on(types, null, data, fn)
            }, unbind: function (types, fn) {
                return this.off(types, null, fn)
            }, delegate: function (selector, types, data, fn) {
                return this.on(types, selector, data, fn)
            }, undelegate: function (selector, types, fn) {
                return 1 === arguments.length ? this.off(selector, "**") : this.off(types, selector || "**", fn)
            }
        }), jQuery.parseJSON = JSON.parse, "function" == typeof define && define.amd && define("jquery", [], function () {
            return jQuery
        });
        var _jQuery = window.jQuery, _$ = window.$;
        return jQuery.noConflict = function (deep) {
            return window.$ === jQuery && (window.$ = _$), deep && window.jQuery === jQuery && (window.jQuery = _jQuery), jQuery
        }, noGlobal || (window.jQuery = window.$ = jQuery), jQuery
    }), function (window) {
        "use strict";
        function minErr(module, ErrorConstructor) {
            return ErrorConstructor = ErrorConstructor || Error, function () {
                var paramPrefix, i, SKIP_INDEXES = 2, templateArgs = arguments, code = templateArgs[0], message = "[" + (module ? module + ":" : "") + code + "] ", template = templateArgs[1];
                for (message += template.replace(/\{\d+\}/g, function (match) {
                    var index = +match.slice(1, -1), shiftedIndex = index + SKIP_INDEXES;
                    return shiftedIndex < templateArgs.length ? toDebugString(templateArgs[shiftedIndex]) : match
                }), message += "\nhttp://errors.angularjs.org/1.5.8/" + (module ? module + "/" : "") + code, i = SKIP_INDEXES, paramPrefix = "?"; i < templateArgs.length; i++, paramPrefix = "&")message += paramPrefix + "p" + (i - SKIP_INDEXES) + "=" + encodeURIComponent(toDebugString(templateArgs[i]));
                return new ErrorConstructor(message)
            }
        }

        function isArrayLike(obj) {
            if (null == obj || isWindow(obj))return !1;
            if (isArray(obj) || isString(obj) || jqLite && obj instanceof jqLite)return !0;
            var length = "length" in Object(obj) && obj.length;
            return isNumber(length) && (length >= 0 && (length - 1 in obj || obj instanceof Array) || "function" == typeof obj.item)
        }

        function forEach(obj, iterator, context) {
            var key, length;
            if (obj)if (isFunction(obj))for (key in obj)"prototype" == key || "length" == key || "name" == key || obj.hasOwnProperty && !obj.hasOwnProperty(key) || iterator.call(context, obj[key], key, obj); else if (isArray(obj) || isArrayLike(obj)) {
                var isPrimitive = "object" != typeof obj;
                for (key = 0, length = obj.length; length > key; key++)(isPrimitive || key in obj) && iterator.call(context, obj[key], key, obj)
            } else if (obj.forEach && obj.forEach !== forEach) obj.forEach(iterator, context, obj); else if (isBlankObject(obj))for (key in obj)iterator.call(context, obj[key], key, obj); else if ("function" == typeof obj.hasOwnProperty)for (key in obj)obj.hasOwnProperty(key) && iterator.call(context, obj[key], key, obj); else for (key in obj)hasOwnProperty.call(obj, key) && iterator.call(context, obj[key], key, obj);
            return obj
        }

        function forEachSorted(obj, iterator, context) {
            for (var keys = Object.keys(obj).sort(), i = 0; i < keys.length; i++)iterator.call(context, obj[keys[i]], keys[i]);
            return keys
        }

        function reverseParams(iteratorFn) {
            return function (value, key) {
                iteratorFn(key, value)
            }
        }

        function nextUid() {
            return ++uid
        }

        function setHashKey(obj, h) {
            h ? obj.$$hashKey = h : delete obj.$$hashKey
        }

        function baseExtend(dst, objs, deep) {
            for (var h = dst.$$hashKey, i = 0, ii = objs.length; ii > i; ++i) {
                var obj = objs[i];
                if (isObject(obj) || isFunction(obj))for (var keys = Object.keys(obj), j = 0, jj = keys.length; jj > j; j++) {
                    var key = keys[j], src = obj[key];
                    deep && isObject(src) ? isDate(src) ? dst[key] = new Date(src.valueOf()) : isRegExp(src) ? dst[key] = new RegExp(src) : src.nodeName ? dst[key] = src.cloneNode(!0) : isElement(src) ? dst[key] = src.clone() : (isObject(dst[key]) || (dst[key] = isArray(src) ? [] : {}), baseExtend(dst[key], [src], !0)) : dst[key] = src
                }
            }
            return setHashKey(dst, h), dst
        }

        function extend(dst) {
            return baseExtend(dst, slice.call(arguments, 1), !1)
        }

        function merge(dst) {
            return baseExtend(dst, slice.call(arguments, 1), !0)
        }

        function toInt(str) {
            return parseInt(str, 10)
        }

        function inherit(parent, extra) {
            return extend(Object.create(parent), extra)
        }

        function noop() {
        }

        function identity($) {
            return $
        }

        function valueFn(value) {
            return function () {
                return value
            }
        }

        function hasCustomToString(obj) {
            return isFunction(obj.toString) && obj.toString !== toString
        }

        function isUndefined(value) {
            return "undefined" == typeof value
        }

        function isDefined(value) {
            return "undefined" != typeof value
        }

        function isObject(value) {
            return null !== value && "object" == typeof value
        }

        function isBlankObject(value) {
            return null !== value && "object" == typeof value && !getPrototypeOf(value)
        }

        function isString(value) {
            return "string" == typeof value
        }

        function isNumber(value) {
            return "number" == typeof value
        }

        function isDate(value) {
            return "[object Date]" === toString.call(value)
        }

        function isFunction(value) {
            return "function" == typeof value
        }

        function isRegExp(value) {
            return "[object RegExp]" === toString.call(value)
        }

        function isWindow(obj) {
            return obj && obj.window === obj
        }

        function isScope(obj) {
            return obj && obj.$evalAsync && obj.$watch
        }

        function isFile(obj) {
            return "[object File]" === toString.call(obj)
        }

        function isFormData(obj) {
            return "[object FormData]" === toString.call(obj)
        }

        function isBlob(obj) {
            return "[object Blob]" === toString.call(obj)
        }

        function isBoolean(value) {
            return "boolean" == typeof value
        }

        function isPromiseLike(obj) {
            return obj && isFunction(obj.then)
        }

        function isTypedArray(value) {
            return value && isNumber(value.length) && TYPED_ARRAY_REGEXP.test(toString.call(value))
        }

        function isArrayBuffer(obj) {
            return "[object ArrayBuffer]" === toString.call(obj)
        }

        function isElement(node) {
            return !(!node || !(node.nodeName || node.prop && node.attr && node.find))
        }

        function makeMap(str) {
            var i, obj = {}, items = str.split(",");
            for (i = 0; i < items.length; i++)obj[items[i]] = !0;
            return obj
        }

        function nodeName_(element) {
            return lowercase(element.nodeName || element[0] && element[0].nodeName)
        }

        function arrayRemove(array, value) {
            var index = array.indexOf(value);
            return index >= 0 && array.splice(index, 1), index
        }

        function copy(source, destination) {
            function copyRecurse(source, destination) {
                var key, h = destination.$$hashKey;
                if (isArray(source))for (var i = 0, ii = source.length; ii > i; i++)destination.push(copyElement(source[i])); else if (isBlankObject(source))for (key in source)destination[key] = copyElement(source[key]); else if (source && "function" == typeof source.hasOwnProperty)for (key in source)source.hasOwnProperty(key) && (destination[key] = copyElement(source[key])); else for (key in source)hasOwnProperty.call(source, key) && (destination[key] = copyElement(source[key]));
                return setHashKey(destination, h), destination
            }

            function copyElement(source) {
                if (!isObject(source))return source;
                var index = stackSource.indexOf(source);
                if (-1 !== index)return stackDest[index];
                if (isWindow(source) || isScope(source))throw ngMinErr("cpws", "Can't copy! Making copies of Window or Scope instances is not supported.");
                var needsRecurse = !1, destination = copyType(source);
                return void 0 === destination && (destination = isArray(source) ? [] : Object.create(getPrototypeOf(source)), needsRecurse = !0), stackSource.push(source), stackDest.push(destination), needsRecurse ? copyRecurse(source, destination) : destination
            }

            function copyType(source) {
                switch (toString.call(source)) {
                    case"[object Int8Array]":
                    case"[object Int16Array]":
                    case"[object Int32Array]":
                    case"[object Float32Array]":
                    case"[object Float64Array]":
                    case"[object Uint8Array]":
                    case"[object Uint8ClampedArray]":
                    case"[object Uint16Array]":
                    case"[object Uint32Array]":
                        return new source.constructor(copyElement(source.buffer), source.byteOffset, source.length);
                    case"[object ArrayBuffer]":
                        if (!source.slice) {
                            var copied = new ArrayBuffer(source.byteLength);
                            return new Uint8Array(copied).set(new Uint8Array(source)), copied
                        }
                        return source.slice(0);
                    case"[object Boolean]":
                    case"[object Number]":
                    case"[object String]":
                    case"[object Date]":
                        return new source.constructor(source.valueOf());
                    case"[object RegExp]":
                        var re = new RegExp(source.source, source.toString().match(/[^\/]*$/)[0]);
                        return re.lastIndex = source.lastIndex, re;
                    case"[object Blob]":
                        return new source.constructor([source], {type: source.type})
                }
                return isFunction(source.cloneNode) ? source.cloneNode(!0) : void 0
            }

            var stackSource = [], stackDest = [];
            if (destination) {
                if (isTypedArray(destination) || isArrayBuffer(destination))throw ngMinErr("cpta", "Can't copy! TypedArray destination cannot be mutated.");
                if (source === destination)throw ngMinErr("cpi", "Can't copy! Source and destination are identical.");
                return isArray(destination) ? destination.length = 0 : forEach(destination, function (value, key) {
                        "$$hashKey" !== key && delete destination[key]
                    }), stackSource.push(source), stackDest.push(destination), copyRecurse(source, destination)
            }
            return copyElement(source)
        }

        function equals(o1, o2) {
            if (o1 === o2)return !0;
            if (null === o1 || null === o2)return !1;
            if (o1 !== o1 && o2 !== o2)return !0;
            var length, key, keySet, t1 = typeof o1, t2 = typeof o2;
            if (t1 == t2 && "object" == t1) {
                if (!isArray(o1)) {
                    if (isDate(o1))return isDate(o2) ? equals(o1.getTime(), o2.getTime()) : !1;
                    if (isRegExp(o1))return isRegExp(o2) ? o1.toString() == o2.toString() : !1;
                    if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2) || isDate(o2) || isRegExp(o2))return !1;
                    keySet = createMap();
                    for (key in o1)if ("$" !== key.charAt(0) && !isFunction(o1[key])) {
                        if (!equals(o1[key], o2[key]))return !1;
                        keySet[key] = !0
                    }
                    for (key in o2)if (!(key in keySet) && "$" !== key.charAt(0) && isDefined(o2[key]) && !isFunction(o2[key]))return !1;
                    return !0
                }
                if (!isArray(o2))return !1;
                if ((length = o1.length) == o2.length) {
                    for (key = 0; length > key; key++)if (!equals(o1[key], o2[key]))return !1;
                    return !0
                }
            }
            return !1
        }

        function concat(array1, array2, index) {
            return array1.concat(slice.call(array2, index))
        }

        function sliceArgs(args, startIndex) {
            return slice.call(args, startIndex || 0)
        }

        function bind(self, fn) {
            var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];
            return !isFunction(fn) || fn instanceof RegExp ? fn : curryArgs.length ? function () {
                        return arguments.length ? fn.apply(self, concat(curryArgs, arguments, 0)) : fn.apply(self, curryArgs)
                    } : function () {
                        return arguments.length ? fn.apply(self, arguments) : fn.call(self)
                    }
        }

        function toJsonReplacer(key, value) {
            var val = value;
            return "string" == typeof key && "$" === key.charAt(0) && "$" === key.charAt(1) ? val = void 0 : isWindow(value) ? val = "$WINDOW" : value && window.document === value ? val = "$DOCUMENT" : isScope(value) && (val = "$SCOPE"), val
        }

        function toJson(obj, pretty) {
            return isUndefined(obj) ? void 0 : (isNumber(pretty) || (pretty = pretty ? 2 : null), JSON.stringify(obj, toJsonReplacer, pretty))
        }

        function fromJson(json) {
            return isString(json) ? JSON.parse(json) : json
        }

        function timezoneToOffset(timezone, fallback) {
            timezone = timezone.replace(ALL_COLONS, "");
            var requestedTimezoneOffset = Date.parse("Jan 01, 1970 00:00:00 " + timezone) / 6e4;
            return isNaN(requestedTimezoneOffset) ? fallback : requestedTimezoneOffset
        }

        function addDateMinutes(date, minutes) {
            return date = new Date(date.getTime()), date.setMinutes(date.getMinutes() + minutes), date
        }

        function convertTimezoneToLocal(date, timezone, reverse) {
            reverse = reverse ? -1 : 1;
            var dateTimezoneOffset = date.getTimezoneOffset(), timezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset);
            return addDateMinutes(date, reverse * (timezoneOffset - dateTimezoneOffset))
        }

        function startingTag(element) {
            element = jqLite(element).clone();
            try {
                element.empty()
            } catch (e) {
            }
            var elemHtml = jqLite("<div>").append(element).html();
            try {
                return element[0].nodeType === NODE_TYPE_TEXT ? lowercase(elemHtml) : elemHtml.match(/^(<[^>]+>)/)[1].replace(/^<([\w\-]+)/, function (match, nodeName) {
                        return "<" + lowercase(nodeName)
                    })
            } catch (e) {
                return lowercase(elemHtml)
            }
        }

        function tryDecodeURIComponent(value) {
            try {
                return decodeURIComponent(value)
            } catch (e) {
            }
        }

        function parseKeyValue(keyValue) {
            var obj = {};
            return forEach((keyValue || "").split("&"), function (keyValue) {
                var splitPoint, key, val;
                keyValue && (key = keyValue = keyValue.replace(/\+/g, "%20"), splitPoint = keyValue.indexOf("="), -1 !== splitPoint && (key = keyValue.substring(0, splitPoint), val = keyValue.substring(splitPoint + 1)), key = tryDecodeURIComponent(key), isDefined(key) && (val = isDefined(val) ? tryDecodeURIComponent(val) : !0, hasOwnProperty.call(obj, key) ? isArray(obj[key]) ? obj[key].push(val) : obj[key] = [obj[key], val] : obj[key] = val))
            }), obj
        }

        function toKeyValue(obj) {
            var parts = [];
            return forEach(obj, function (value, key) {
                isArray(value) ? forEach(value, function (arrayValue) {
                        parts.push(encodeUriQuery(key, !0) + (arrayValue === !0 ? "" : "=" + encodeUriQuery(arrayValue, !0)))
                    }) : parts.push(encodeUriQuery(key, !0) + (value === !0 ? "" : "=" + encodeUriQuery(value, !0)))
            }), parts.length ? parts.join("&") : ""
        }

        function encodeUriSegment(val) {
            return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+")
        }

        function encodeUriQuery(val, pctEncodeSpaces) {
            return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%3B/gi, ";").replace(/%20/g, pctEncodeSpaces ? "%20" : "+")
        }

        function getNgAttribute(element, ngAttr) {
            var attr, i, ii = ngAttrPrefixes.length;
            for (i = 0; ii > i; ++i)if (attr = ngAttrPrefixes[i] + ngAttr, isString(attr = element.getAttribute(attr)))return attr;
            return null
        }

        function angularInit(element, bootstrap) {
            var appElement, module, config = {};
            forEach(ngAttrPrefixes, function (prefix) {
                var name = prefix + "app";
                !appElement && element.hasAttribute && element.hasAttribute(name) && (appElement = element, module = element.getAttribute(name))
            }), forEach(ngAttrPrefixes, function (prefix) {
                var candidate, name = prefix + "app";
                !appElement && (candidate = element.querySelector("[" + name.replace(":", "\\:") + "]")) && (appElement = candidate, module = candidate.getAttribute(name))
            }), appElement && (config.strictDi = null !== getNgAttribute(appElement, "strict-di"), bootstrap(appElement, module ? [module] : [], config))
        }

        function bootstrap(element, modules, config) {
            isObject(config) || (config = {});
            var defaultConfig = {strictDi: !1};
            config = extend(defaultConfig, config);
            var doBootstrap = function () {
                if (element = jqLite(element), element.injector()) {
                    var tag = element[0] === window.document ? "document" : startingTag(element);
                    throw ngMinErr("btstrpd", "App already bootstrapped with this element '{0}'", tag.replace(/</, "&lt;").replace(/>/, "&gt;"))
                }
                modules = modules || [], modules.unshift(["$provide", function ($provide) {
                    $provide.value("$rootElement", element)
                }]), config.debugInfoEnabled && modules.push(["$compileProvider", function ($compileProvider) {
                    $compileProvider.debugInfoEnabled(!0)
                }]), modules.unshift("ng");
                var injector = createInjector(modules, config.strictDi);
                return injector.invoke(["$rootScope", "$rootElement", "$compile", "$injector", function (scope, element, compile, injector) {
                    scope.$apply(function () {
                        element.data("$injector", injector), compile(element)(scope)
                    })
                }]), injector
            }, NG_ENABLE_DEBUG_INFO = /^NG_ENABLE_DEBUG_INFO!/, NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;
            return window && NG_ENABLE_DEBUG_INFO.test(window.name) && (config.debugInfoEnabled = !0, window.name = window.name.replace(NG_ENABLE_DEBUG_INFO, "")), window && !NG_DEFER_BOOTSTRAP.test(window.name) ? doBootstrap() : (window.name = window.name.replace(NG_DEFER_BOOTSTRAP, ""), angular.resumeBootstrap = function (extraModules) {
                    return forEach(extraModules, function (module) {
                        modules.push(module)
                    }), doBootstrap()
                }, void(isFunction(angular.resumeDeferredBootstrap) && angular.resumeDeferredBootstrap()))
        }

        function reloadWithDebugInfo() {
            window.name = "NG_ENABLE_DEBUG_INFO!" + window.name, window.location.reload()
        }

        function getTestability(rootElement) {
            var injector = angular.element(rootElement).injector();
            if (!injector)throw ngMinErr("test", "no injector found for element argument to getTestability");
            return injector.get("$$testability")
        }

        function snake_case(name, separator) {
            return separator = separator || "_", name.replace(SNAKE_CASE_REGEXP, function (letter, pos) {
                return (pos ? separator : "") + letter.toLowerCase()
            })
        }

        function bindJQuery() {
            var originalCleanData;
            if (!bindJQueryFired) {
                var jqName = jq();
                jQuery = isUndefined(jqName) ? window.jQuery : jqName ? window[jqName] : void 0, jQuery && jQuery.fn.on ? (jqLite = jQuery, extend(jQuery.fn, {
                        scope: JQLitePrototype.scope,
                        isolateScope: JQLitePrototype.isolateScope,
                        controller: JQLitePrototype.controller,
                        injector: JQLitePrototype.injector,
                        inheritedData: JQLitePrototype.inheritedData
                    }), originalCleanData = jQuery.cleanData, jQuery.cleanData = function (elems) {
                        for (var events, elem, i = 0; null != (elem = elems[i]); i++)events = jQuery._data(elem, "events"), events && events.$destroy && jQuery(elem).triggerHandler("$destroy");
                        originalCleanData(elems)
                    }) : jqLite = JQLite, angular.element = jqLite, bindJQueryFired = !0
            }
        }

        function assertArg(arg, name, reason) {
            if (!arg)throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
            return arg
        }

        function assertArgFn(arg, name, acceptArrayAnnotation) {
            return acceptArrayAnnotation && isArray(arg) && (arg = arg[arg.length - 1]), assertArg(isFunction(arg), name, "not a function, got " + (arg && "object" == typeof arg ? arg.constructor.name || "Object" : typeof arg)), arg
        }

        function assertNotHasOwnProperty(name, context) {
            if ("hasOwnProperty" === name)throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
        }

        function getter(obj, path, bindFnToScope) {
            if (!path)return obj;
            for (var key, keys = path.split("."), lastInstance = obj, len = keys.length, i = 0; len > i; i++)key = keys[i], obj && (obj = (lastInstance = obj)[key]);
            return !bindFnToScope && isFunction(obj) ? bind(lastInstance, obj) : obj
        }

        function getBlockNodes(nodes) {
            for (var blockNodes, node = nodes[0], endNode = nodes[nodes.length - 1], i = 1; node !== endNode && (node = node.nextSibling); i++)(blockNodes || nodes[i] !== node) && (blockNodes || (blockNodes = jqLite(slice.call(nodes, 0, i))), blockNodes.push(node));
            return blockNodes || nodes
        }

        function createMap() {
            return Object.create(null)
        }

        function setupModuleLoader(window) {
            function ensure(obj, name, factory) {
                return obj[name] || (obj[name] = factory())
            }

            var $injectorMinErr = minErr("$injector"), ngMinErr = minErr("ng"), angular = ensure(window, "angular", Object);
            return angular.$$minErr = angular.$$minErr || minErr, ensure(angular, "module", function () {
                var modules = {};
                return function (name, requires, configFn) {
                    var assertNotHasOwnProperty = function (name, context) {
                        if ("hasOwnProperty" === name)throw ngMinErr("badname", "hasOwnProperty is not a valid {0} name", context)
                    };
                    return assertNotHasOwnProperty(name, "module"), requires && modules.hasOwnProperty(name) && (modules[name] = null), ensure(modules, name, function () {
                        function invokeLater(provider, method, insertMethod, queue) {
                            return queue || (queue = invokeQueue), function () {
                                return queue[insertMethod || "push"]([provider, method, arguments]), moduleInstance
                            }
                        }

                        function invokeLaterAndSetModuleName(provider, method) {
                            return function (recipeName, factoryFunction) {
                                return factoryFunction && isFunction(factoryFunction) && (factoryFunction.$$moduleName = name), invokeQueue.push([provider, method, arguments]), moduleInstance
                            }
                        }

                        if (!requires)throw $injectorMinErr("nomod", "Module '{0}' is not available! You either misspelled the module name or forgot to load it. If registering a module ensure that you specify the dependencies as the second argument.", name);
                        var invokeQueue = [], configBlocks = [], runBlocks = [], config = invokeLater("$injector", "invoke", "push", configBlocks), moduleInstance = {
                            _invokeQueue: invokeQueue,
                            _configBlocks: configBlocks,
                            _runBlocks: runBlocks,
                            requires: requires,
                            name: name,
                            provider: invokeLaterAndSetModuleName("$provide", "provider"),
                            factory: invokeLaterAndSetModuleName("$provide", "factory"),
                            service: invokeLaterAndSetModuleName("$provide", "service"),
                            value: invokeLater("$provide", "value"),
                            constant: invokeLater("$provide", "constant", "unshift"),
                            decorator: invokeLaterAndSetModuleName("$provide", "decorator"),
                            animation: invokeLaterAndSetModuleName("$animateProvider", "register"),
                            filter: invokeLaterAndSetModuleName("$filterProvider", "register"),
                            controller: invokeLaterAndSetModuleName("$controllerProvider", "register"),
                            directive: invokeLaterAndSetModuleName("$compileProvider", "directive"),
                            component: invokeLaterAndSetModuleName("$compileProvider", "component"),
                            config: config,
                            run: function (block) {
                                return runBlocks.push(block), this
                            }
                        };
                        return configFn && config(configFn), moduleInstance
                    })
                }
            })
        }

        function shallowCopy(src, dst) {
            if (isArray(src)) {
                dst = dst || [];
                for (var i = 0, ii = src.length; ii > i; i++)dst[i] = src[i]
            } else if (isObject(src)) {
                dst = dst || {};
                for (var key in src)("$" !== key.charAt(0) || "$" !== key.charAt(1)) && (dst[key] = src[key])
            }
            return dst || src
        }

        function serializeObject(obj) {
            var seen = [];
            return JSON.stringify(obj, function (key, val) {
                if (val = toJsonReplacer(key, val), isObject(val)) {
                    if (seen.indexOf(val) >= 0)return "...";
                    seen.push(val)
                }
                return val
            })
        }

        function toDebugString(obj) {
            return "function" == typeof obj ? obj.toString().replace(/ \{[\s\S]*$/, "") : isUndefined(obj) ? "undefined" : "string" != typeof obj ? serializeObject(obj) : obj
        }

        function publishExternalAPI(angular) {
            extend(angular, {
                bootstrap: bootstrap,
                copy: copy,
                extend: extend,
                merge: merge,
                equals: equals,
                element: jqLite,
                forEach: forEach,
                injector: createInjector,
                noop: noop,
                bind: bind,
                toJson: toJson,
                fromJson: fromJson,
                identity: identity,
                isUndefined: isUndefined,
                isDefined: isDefined,
                isString: isString,
                isFunction: isFunction,
                isObject: isObject,
                isNumber: isNumber,
                isElement: isElement,
                isArray: isArray,
                version: version,
                isDate: isDate,
                lowercase: lowercase,
                uppercase: uppercase,
                callbacks: {$$counter: 0},
                getTestability: getTestability,
                $$minErr: minErr,
                $$csp: csp,
                reloadWithDebugInfo: reloadWithDebugInfo
            }), (angularModule = setupModuleLoader(window))("ng", ["ngLocale"], ["$provide", function ($provide) {
                $provide.provider({$$sanitizeUri: $$SanitizeUriProvider}), $provide.provider("$compile", $CompileProvider).directive({
                    a: htmlAnchorDirective,
                    input: inputDirective,
                    textarea: inputDirective,
                    form: formDirective,
                    script: scriptDirective,
                    select: selectDirective,
                    style: styleDirective,
                    option: optionDirective,
                    ngBind: ngBindDirective,
                    ngBindHtml: ngBindHtmlDirective,
                    ngBindTemplate: ngBindTemplateDirective,
                    ngClass: ngClassDirective,
                    ngClassEven: ngClassEvenDirective,
                    ngClassOdd: ngClassOddDirective,
                    ngCloak: ngCloakDirective,
                    ngController: ngControllerDirective,
                    ngForm: ngFormDirective,
                    ngHide: ngHideDirective,
                    ngIf: ngIfDirective,
                    ngInclude: ngIncludeDirective,
                    ngInit: ngInitDirective,
                    ngNonBindable: ngNonBindableDirective,
                    ngPluralize: ngPluralizeDirective,
                    ngRepeat: ngRepeatDirective,
                    ngShow: ngShowDirective,
                    ngStyle: ngStyleDirective,
                    ngSwitch: ngSwitchDirective,
                    ngSwitchWhen: ngSwitchWhenDirective,
                    ngSwitchDefault: ngSwitchDefaultDirective,
                    ngOptions: ngOptionsDirective,
                    ngTransclude: ngTranscludeDirective,
                    ngModel: ngModelDirective,
                    ngList: ngListDirective,
                    ngChange: ngChangeDirective,
                    pattern: patternDirective,
                    ngPattern: patternDirective,
                    required: requiredDirective,
                    ngRequired: requiredDirective,
                    minlength: minlengthDirective,
                    ngMinlength: minlengthDirective,
                    maxlength: maxlengthDirective,
                    ngMaxlength: maxlengthDirective,
                    ngValue: ngValueDirective,
                    ngModelOptions: ngModelOptionsDirective
                }).directive({ngInclude: ngIncludeFillContentDirective}).directive(ngAttributeAliasDirectives).directive(ngEventDirectives), $provide.provider({
                    $anchorScroll: $AnchorScrollProvider,
                    $animate: $AnimateProvider,
                    $animateCss: $CoreAnimateCssProvider,
                    $$animateJs: $$CoreAnimateJsProvider,
                    $$animateQueue: $$CoreAnimateQueueProvider,
                    $$AnimateRunner: $$AnimateRunnerFactoryProvider,
                    $$animateAsyncRun: $$AnimateAsyncRunFactoryProvider,
                    $browser: $BrowserProvider,
                    $cacheFactory: $CacheFactoryProvider,
                    $controller: $ControllerProvider,
                    $document: $DocumentProvider,
                    $exceptionHandler: $ExceptionHandlerProvider,
                    $filter: $FilterProvider,
                    $$forceReflow: $$ForceReflowProvider,
                    $interpolate: $InterpolateProvider,
                    $interval: $IntervalProvider,
                    $http: $HttpProvider,
                    $httpParamSerializer: $HttpParamSerializerProvider,
                    $httpParamSerializerJQLike: $HttpParamSerializerJQLikeProvider,
                    $httpBackend: $HttpBackendProvider,
                    $xhrFactory: $xhrFactoryProvider,
                    $jsonpCallbacks: $jsonpCallbacksProvider,
                    $location: $LocationProvider,
                    $log: $LogProvider,
                    $parse: $ParseProvider,
                    $rootScope: $RootScopeProvider,
                    $q: $QProvider,
                    $$q: $$QProvider,
                    $sce: $SceProvider,
                    $sceDelegate: $SceDelegateProvider,
                    $sniffer: $SnifferProvider,
                    $templateCache: $TemplateCacheProvider,
                    $templateRequest: $TemplateRequestProvider,
                    $$testability: $$TestabilityProvider,
                    $timeout: $TimeoutProvider,
                    $window: $WindowProvider,
                    $$rAF: $$RAFProvider,
                    $$jqLite: $$jqLiteProvider,
                    $$HashMap: $$HashMapProvider,
                    $$cookieReader: $$CookieReaderProvider
                })
            }])
        }

        function jqNextId() {
            return ++jqId
        }

        function camelCase(name) {
            return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
                return offset ? letter.toUpperCase() : letter
            }).replace(MOZ_HACK_REGEXP, "Moz$1")
        }

        function jqLiteIsTextNode(html) {
            return !HTML_REGEXP.test(html)
        }

        function jqLiteAcceptsData(node) {
            var nodeType = node.nodeType;
            return nodeType === NODE_TYPE_ELEMENT || !nodeType || nodeType === NODE_TYPE_DOCUMENT
        }

        function jqLiteHasData(node) {
            for (var key in jqCache[node.ng339])return !0;
            return !1
        }

        function jqLiteCleanData(nodes) {
            for (var i = 0, ii = nodes.length; ii > i; i++)jqLiteRemoveData(nodes[i]);
        }

        function jqLiteBuildFragment(html, context) {
            var tmp, tag, wrap, i, fragment = context.createDocumentFragment(), nodes = [];
            if (jqLiteIsTextNode(html)) nodes.push(context.createTextNode(html)); else {
                for (tmp = fragment.appendChild(context.createElement("div")), tag = (TAG_NAME_REGEXP.exec(html) || ["", ""])[1].toLowerCase(), wrap = wrapMap[tag] || wrapMap._default, tmp.innerHTML = wrap[1] + html.replace(XHTML_TAG_REGEXP, "<$1></$2>") + wrap[2], i = wrap[0]; i--;)tmp = tmp.lastChild;
                nodes = concat(nodes, tmp.childNodes), tmp = fragment.firstChild, tmp.textContent = ""
            }
            return fragment.textContent = "", fragment.innerHTML = "", forEach(nodes, function (node) {
                fragment.appendChild(node)
            }), fragment
        }

        function jqLiteParseHTML(html, context) {
            context = context || window.document;
            var parsed;
            return (parsed = SINGLE_TAG_REGEXP.exec(html)) ? [context.createElement(parsed[1])] : (parsed = jqLiteBuildFragment(html, context)) ? parsed.childNodes : []
        }

        function jqLiteWrapNode(node, wrapper) {
            var parent = node.parentNode;
            parent && parent.replaceChild(wrapper, node), wrapper.appendChild(node)
        }

        function JQLite(element) {
            if (element instanceof JQLite)return element;
            var argIsString;
            if (isString(element) && (element = trim(element), argIsString = !0), !(this instanceof JQLite)) {
                if (argIsString && "<" != element.charAt(0))throw jqLiteMinErr("nosel", "Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element");
                return new JQLite(element)
            }
            argIsString ? jqLiteAddNodes(this, jqLiteParseHTML(element)) : jqLiteAddNodes(this, element)
        }

        function jqLiteClone(element) {
            return element.cloneNode(!0)
        }

        function jqLiteDealoc(element, onlyDescendants) {
            if (onlyDescendants || jqLiteRemoveData(element), element.querySelectorAll)for (var descendants = element.querySelectorAll("*"), i = 0, l = descendants.length; l > i; i++)jqLiteRemoveData(descendants[i])
        }

        function jqLiteOff(element, type, fn, unsupported) {
            if (isDefined(unsupported))throw jqLiteMinErr("offargs", "jqLite#off() does not support the `selector` argument");
            var expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, handle = expandoStore && expandoStore.handle;
            if (handle)if (type) {
                var removeHandler = function (type) {
                    var listenerFns = events[type];
                    isDefined(fn) && arrayRemove(listenerFns || [], fn), isDefined(fn) && listenerFns && listenerFns.length > 0 || (removeEventListenerFn(element, type, handle), delete events[type])
                };
                forEach(type.split(" "), function (type) {
                    removeHandler(type), MOUSE_EVENT_MAP[type] && removeHandler(MOUSE_EVENT_MAP[type])
                })
            } else for (type in events)"$destroy" !== type && removeEventListenerFn(element, type, handle), delete events[type]
        }

        function jqLiteRemoveData(element, name) {
            var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
            if (expandoStore) {
                if (name)return void delete expandoStore.data[name];
                expandoStore.handle && (expandoStore.events.$destroy && expandoStore.handle({}, "$destroy"), jqLiteOff(element)), delete jqCache[expandoId], element.ng339 = void 0
            }
        }

        function jqLiteExpandoStore(element, createIfNecessary) {
            var expandoId = element.ng339, expandoStore = expandoId && jqCache[expandoId];
            return createIfNecessary && !expandoStore && (element.ng339 = expandoId = jqNextId(), expandoStore = jqCache[expandoId] = {
                events: {},
                data: {},
                handle: void 0
            }), expandoStore
        }

        function jqLiteData(element, key, value) {
            if (jqLiteAcceptsData(element)) {
                var isSimpleSetter = isDefined(value), isSimpleGetter = !isSimpleSetter && key && !isObject(key), massGetter = !key, expandoStore = jqLiteExpandoStore(element, !isSimpleGetter), data = expandoStore && expandoStore.data;
                if (isSimpleSetter) data[key] = value; else {
                    if (massGetter)return data;
                    if (isSimpleGetter)return data && data[key];
                    extend(data, key)
                }
            }
        }

        function jqLiteHasClass(element, selector) {
            return element.getAttribute ? (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").indexOf(" " + selector + " ") > -1 : !1
        }

        function jqLiteRemoveClass(element, cssClasses) {
            cssClasses && element.setAttribute && forEach(cssClasses.split(" "), function (cssClass) {
                element.setAttribute("class", trim((" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ").replace(" " + trim(cssClass) + " ", " ")))
            })
        }

        function jqLiteAddClass(element, cssClasses) {
            if (cssClasses && element.setAttribute) {
                var existingClasses = (" " + (element.getAttribute("class") || "") + " ").replace(/[\n\t]/g, " ");
                forEach(cssClasses.split(" "), function (cssClass) {
                    cssClass = trim(cssClass), -1 === existingClasses.indexOf(" " + cssClass + " ") && (existingClasses += cssClass + " ")
                }), element.setAttribute("class", trim(existingClasses))
            }
        }

        function jqLiteAddNodes(root, elements) {
            if (elements)if (elements.nodeType) root[root.length++] = elements; else {
                var length = elements.length;
                if ("number" == typeof length && elements.window !== elements) {
                    if (length)for (var i = 0; length > i; i++)root[root.length++] = elements[i]
                } else root[root.length++] = elements
            }
        }

        function jqLiteController(element, name) {
            return jqLiteInheritedData(element, "$" + (name || "ngController") + "Controller")
        }

        function jqLiteInheritedData(element, name, value) {
            element.nodeType == NODE_TYPE_DOCUMENT && (element = element.documentElement);
            for (var names = isArray(name) ? name : [name]; element;) {
                for (var i = 0, ii = names.length; ii > i; i++)if (isDefined(value = jqLite.data(element, names[i])))return value;
                element = element.parentNode || element.nodeType === NODE_TYPE_DOCUMENT_FRAGMENT && element.host
            }
        }

        function jqLiteEmpty(element) {
            for (jqLiteDealoc(element, !0); element.firstChild;)element.removeChild(element.firstChild)
        }

        function jqLiteRemove(element, keepData) {
            keepData || jqLiteDealoc(element);
            var parent = element.parentNode;
            parent && parent.removeChild(element)
        }

        function jqLiteDocumentLoaded(action, win) {
            win = win || window, "complete" === win.document.readyState ? win.setTimeout(action) : jqLite(win).on("load", action)
        }

        function getBooleanAttrName(element, name) {
            var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];
            return booleanAttr && BOOLEAN_ELEMENTS[nodeName_(element)] && booleanAttr
        }

        function getAliasedAttrName(name) {
            return ALIASED_ATTR[name]
        }

        function createEventHandler(element, events) {
            var eventHandler = function (event, type) {
                event.isDefaultPrevented = function () {
                    return event.defaultPrevented
                };
                var eventFns = events[type || event.type], eventFnsLength = eventFns ? eventFns.length : 0;
                if (eventFnsLength) {
                    if (isUndefined(event.immediatePropagationStopped)) {
                        var originalStopImmediatePropagation = event.stopImmediatePropagation;
                        event.stopImmediatePropagation = function () {
                            event.immediatePropagationStopped = !0, event.stopPropagation && event.stopPropagation(), originalStopImmediatePropagation && originalStopImmediatePropagation.call(event)
                        }
                    }
                    event.isImmediatePropagationStopped = function () {
                        return event.immediatePropagationStopped === !0
                    };
                    var handlerWrapper = eventFns.specialHandlerWrapper || defaultHandlerWrapper;
                    eventFnsLength > 1 && (eventFns = shallowCopy(eventFns));
                    for (var i = 0; eventFnsLength > i; i++)event.isImmediatePropagationStopped() || handlerWrapper(element, event, eventFns[i])
                }
            };
            return eventHandler.elem = element, eventHandler
        }

        function defaultHandlerWrapper(element, event, handler) {
            handler.call(element, event)
        }

        function specialMouseHandlerWrapper(target, event, handler) {
            var related = event.relatedTarget;
            (!related || related !== target && !jqLiteContains.call(target, related)) && handler.call(target, event)
        }

        function $$jqLiteProvider() {
            this.$get = function () {
                return extend(JQLite, {
                    hasClass: function (node, classes) {
                        return node.attr && (node = node[0]), jqLiteHasClass(node, classes)
                    }, addClass: function (node, classes) {
                        return node.attr && (node = node[0]), jqLiteAddClass(node, classes)
                    }, removeClass: function (node, classes) {
                        return node.attr && (node = node[0]), jqLiteRemoveClass(node, classes)
                    }
                })
            }
        }

        function hashKey(obj, nextUidFn) {
            var key = obj && obj.$$hashKey;
            if (key)return "function" == typeof key && (key = obj.$$hashKey()), key;
            var objType = typeof obj;
            return key = "function" == objType || "object" == objType && null !== obj ? obj.$$hashKey = objType + ":" + (nextUidFn || nextUid)() : objType + ":" + obj
        }

        function HashMap(array, isolatedUid) {
            if (isolatedUid) {
                var uid = 0;
                this.nextUid = function () {
                    return ++uid
                }
            }
            forEach(array, this.put, this)
        }

        function stringifyFn(fn) {
            return Function.prototype.toString.call(fn) + " "
        }

        function extractArgs(fn) {
            var fnText = stringifyFn(fn).replace(STRIP_COMMENTS, ""), args = fnText.match(ARROW_ARG) || fnText.match(FN_ARGS);
            return args
        }

        function anonFn(fn) {
            var args = extractArgs(fn);
            return args ? "function(" + (args[1] || "").replace(/[\s\r\n]+/, " ") + ")" : "fn"
        }

        function annotate(fn, strictDi, name) {
            var $inject, argDecl, last;
            if ("function" == typeof fn) {
                if (!($inject = fn.$inject)) {
                    if ($inject = [], fn.length) {
                        if (strictDi)throw isString(name) && name || (name = fn.name || anonFn(fn)), $injectorMinErr("strictdi", "{0} is not using explicit annotation and cannot be invoked in strict mode", name);
                        argDecl = extractArgs(fn), forEach(argDecl[1].split(FN_ARG_SPLIT), function (arg) {
                            arg.replace(FN_ARG, function (all, underscore, name) {
                                $inject.push(name)
                            })
                        })
                    }
                    fn.$inject = $inject
                }
            } else isArray(fn) ? (last = fn.length - 1, assertArgFn(fn[last], "fn"), $inject = fn.slice(0, last)) : assertArgFn(fn, "fn", !0);
            return $inject
        }

        function createInjector(modulesToLoad, strictDi) {
            function supportObject(delegate) {
                return function (key, value) {
                    return isObject(key) ? void forEach(key, reverseParams(delegate)) : delegate(key, value)
                }
            }

            function provider(name, provider_) {
                if (assertNotHasOwnProperty(name, "service"), (isFunction(provider_) || isArray(provider_)) && (provider_ = providerInjector.instantiate(provider_)), !provider_.$get)throw $injectorMinErr("pget", "Provider '{0}' must define $get factory method.", name);
                return providerCache[name + providerSuffix] = provider_
            }

            function enforceReturnValue(name, factory) {
                return function () {
                    var result = instanceInjector.invoke(factory, this);
                    if (isUndefined(result))throw $injectorMinErr("undef", "Provider '{0}' must return a value from $get factory method.", name);
                    return result
                }
            }

            function factory(name, factoryFn, enforce) {
                return provider(name, {$get: enforce !== !1 ? enforceReturnValue(name, factoryFn) : factoryFn})
            }

            function service(name, constructor) {
                return factory(name, ["$injector", function ($injector) {
                    return $injector.instantiate(constructor)
                }])
            }

            function value(name, val) {
                return factory(name, valueFn(val), !1)
            }

            function constant(name, value) {
                assertNotHasOwnProperty(name, "constant"), providerCache[name] = value, instanceCache[name] = value
            }

            function decorator(serviceName, decorFn) {
                var origProvider = providerInjector.get(serviceName + providerSuffix), orig$get = origProvider.$get;
                origProvider.$get = function () {
                    var origInstance = instanceInjector.invoke(orig$get, origProvider);
                    return instanceInjector.invoke(decorFn, null, {$delegate: origInstance})
                }
            }

            function loadModules(modulesToLoad) {
                assertArg(isUndefined(modulesToLoad) || isArray(modulesToLoad), "modulesToLoad", "not an array");
                var moduleFn, runBlocks = [];
                return forEach(modulesToLoad, function (module) {
                    function runInvokeQueue(queue) {
                        var i, ii;
                        for (i = 0, ii = queue.length; ii > i; i++) {
                            var invokeArgs = queue[i], provider = providerInjector.get(invokeArgs[0]);
                            provider[invokeArgs[1]].apply(provider, invokeArgs[2])
                        }
                    }

                    if (!loadedModules.get(module)) {
                        loadedModules.put(module, !0);
                        try {
                            isString(module) ? (moduleFn = angularModule(module), runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks), runInvokeQueue(moduleFn._invokeQueue), runInvokeQueue(moduleFn._configBlocks)) : isFunction(module) ? runBlocks.push(providerInjector.invoke(module)) : isArray(module) ? runBlocks.push(providerInjector.invoke(module)) : assertArgFn(module, "module")
                        } catch (e) {
                            throw isArray(module) && (module = module[module.length - 1]), e.message && e.stack && -1 == e.stack.indexOf(e.message) && (e = e.message + "\n" + e.stack), $injectorMinErr("modulerr", "Failed to instantiate module {0} due to:\n{1}", module, e.stack || e.message || e)
                        }
                    }
                }), runBlocks
            }

            function createInternalInjector(cache, factory) {
                function getService(serviceName, caller) {
                    if (cache.hasOwnProperty(serviceName)) {
                        if (cache[serviceName] === INSTANTIATING)throw $injectorMinErr("cdep", "Circular dependency found: {0}", serviceName + " <- " + path.join(" <- "));
                        return cache[serviceName]
                    }
                    try {
                        return path.unshift(serviceName), cache[serviceName] = INSTANTIATING, cache[serviceName] = factory(serviceName, caller)
                    } catch (err) {
                        throw cache[serviceName] === INSTANTIATING && delete cache[serviceName], err
                    } finally {
                        path.shift()
                    }
                }

                function injectionArgs(fn, locals, serviceName) {
                    for (var args = [], $inject = createInjector.$$annotate(fn, strictDi, serviceName), i = 0, length = $inject.length; length > i; i++) {
                        var key = $inject[i];
                        if ("string" != typeof key)throw $injectorMinErr("itkn", "Incorrect injection token! Expected service name as string, got {0}", key);
                        args.push(locals && locals.hasOwnProperty(key) ? locals[key] : getService(key, serviceName))
                    }
                    return args
                }

                function isClass(func) {
                    return 11 >= msie ? !1 : "function" == typeof func && /^(?:class\b|constructor\()/.test(stringifyFn(func))
                }

                function invoke(fn, self, locals, serviceName) {
                    "string" == typeof locals && (serviceName = locals, locals = null);
                    var args = injectionArgs(fn, locals, serviceName);
                    return isArray(fn) && (fn = fn[fn.length - 1]), isClass(fn) ? (args.unshift(null), new (Function.prototype.bind.apply(fn, args))) : fn.apply(self, args)
                }

                function instantiate(Type, locals, serviceName) {
                    var ctor = isArray(Type) ? Type[Type.length - 1] : Type, args = injectionArgs(Type, locals, serviceName);
                    return args.unshift(null), new (Function.prototype.bind.apply(ctor, args))
                }

                return {
                    invoke: invoke,
                    instantiate: instantiate,
                    get: getService,
                    annotate: createInjector.$$annotate,
                    has: function (name) {
                        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name)
                    }
                }
            }

            strictDi = strictDi === !0;
            var INSTANTIATING = {}, providerSuffix = "Provider", path = [], loadedModules = new HashMap([], !0), providerCache = {
                $provide: {
                    provider: supportObject(provider),
                    factory: supportObject(factory),
                    service: supportObject(service),
                    value: supportObject(value),
                    constant: supportObject(constant),
                    decorator: decorator
                }
            }, providerInjector = providerCache.$injector = createInternalInjector(providerCache, function (serviceName, caller) {
                throw angular.isString(caller) && path.push(caller), $injectorMinErr("unpr", "Unknown provider: {0}", path.join(" <- "))
            }), instanceCache = {}, protoInstanceInjector = createInternalInjector(instanceCache, function (serviceName, caller) {
                var provider = providerInjector.get(serviceName + providerSuffix, caller);
                return instanceInjector.invoke(provider.$get, provider, void 0, serviceName)
            }), instanceInjector = protoInstanceInjector;
            providerCache["$injector" + providerSuffix] = {$get: valueFn(protoInstanceInjector)};
            var runBlocks = loadModules(modulesToLoad);
            return instanceInjector = protoInstanceInjector.get("$injector"), instanceInjector.strictDi = strictDi, forEach(runBlocks, function (fn) {
                fn && instanceInjector.invoke(fn)
            }), instanceInjector
        }

        function $AnchorScrollProvider() {
            var autoScrollingEnabled = !0;
            this.disableAutoScrolling = function () {
                autoScrollingEnabled = !1
            }, this.$get = ["$window", "$location", "$rootScope", function ($window, $location, $rootScope) {
                function getFirstAnchor(list) {
                    var result = null;
                    return Array.prototype.some.call(list, function (element) {
                        return "a" === nodeName_(element) ? (result = element, !0) : void 0
                    }), result
                }

                function getYOffset() {
                    var offset = scroll.yOffset;
                    if (isFunction(offset)) offset = offset(); else if (isElement(offset)) {
                        var elem = offset[0], style = $window.getComputedStyle(elem);
                        offset = "fixed" !== style.position ? 0 : elem.getBoundingClientRect().bottom
                    } else isNumber(offset) || (offset = 0);
                    return offset
                }

                function scrollTo(elem) {
                    if (elem) {
                        elem.scrollIntoView();
                        var offset = getYOffset();
                        if (offset) {
                            var elemTop = elem.getBoundingClientRect().top;
                            $window.scrollBy(0, elemTop - offset)
                        }
                    } else $window.scrollTo(0, 0)
                }

                function scroll(hash) {
                    hash = isString(hash) ? hash : $location.hash();
                    var elm;
                    hash ? (elm = document.getElementById(hash)) ? scrollTo(elm) : (elm = getFirstAnchor(document.getElementsByName(hash))) ? scrollTo(elm) : "top" === hash && scrollTo(null) : scrollTo(null)
                }

                var document = $window.document;
                return autoScrollingEnabled && $rootScope.$watch(function () {
                    return $location.hash()
                }, function (newVal, oldVal) {
                    (newVal !== oldVal || "" !== newVal) && jqLiteDocumentLoaded(function () {
                        $rootScope.$evalAsync(scroll)
                    })
                }), scroll
            }]
        }

        function mergeClasses(a, b) {
            return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")), isArray(b) && (b = b.join(" ")), a + " " + b) : a : b : ""
        }

        function extractElementNode(element) {
            for (var i = 0; i < element.length; i++) {
                var elm = element[i];
                if (elm.nodeType === ELEMENT_NODE)return elm
            }
        }

        function splitClasses(classes) {
            isString(classes) && (classes = classes.split(" "));
            var obj = createMap();
            return forEach(classes, function (klass) {
                klass.length && (obj[klass] = !0)
            }), obj
        }

        function prepareAnimateOptions(options) {
            return isObject(options) ? options : {}
        }

        function Browser(window, document, $log, $sniffer) {
            function completeOutstandingRequest(fn) {
                try {
                    fn.apply(null, sliceArgs(arguments, 1))
                } finally {
                    if (outstandingRequestCount--, 0 === outstandingRequestCount)for (; outstandingRequestCallbacks.length;)try {
                        outstandingRequestCallbacks.pop()()
                    } catch (e) {
                        $log.error(e)
                    }
                }
            }

            function getHash(url) {
                var index = url.indexOf("#");
                return -1 === index ? "" : url.substr(index)
            }

            function cacheStateAndFireUrlChange() {
                pendingLocation = null, cacheState(), fireUrlChange()
            }

            function cacheState() {
                cachedState = getCurrentState(), cachedState = isUndefined(cachedState) ? null : cachedState, equals(cachedState, lastCachedState) && (cachedState = lastCachedState), lastCachedState = cachedState
            }

            function fireUrlChange() {
                (lastBrowserUrl !== self.url() || lastHistoryState !== cachedState) && (lastBrowserUrl = self.url(), lastHistoryState = cachedState, forEach(urlChangeListeners, function (listener) {
                    listener(self.url(), cachedState)
                }))
            }

            var self = this, location = window.location, history = window.history, setTimeout = window.setTimeout, clearTimeout = window.clearTimeout, pendingDeferIds = {};
            self.isMock = !1;
            var outstandingRequestCount = 0, outstandingRequestCallbacks = [];
            self.$$completeOutstandingRequest = completeOutstandingRequest, self.$$incOutstandingRequestCount = function () {
                outstandingRequestCount++
            }, self.notifyWhenNoOutstandingRequests = function (callback) {
                0 === outstandingRequestCount ? callback() : outstandingRequestCallbacks.push(callback)
            };
            var cachedState, lastHistoryState, lastBrowserUrl = location.href, baseElement = document.find("base"), pendingLocation = null, getCurrentState = $sniffer.history ? function () {
                    try {
                        return history.state
                    } catch (e) {
                    }
                } : noop;
            cacheState(), lastHistoryState = cachedState, self.url = function (url, replace, state) {
                if (isUndefined(state) && (state = null), location !== window.location && (location = window.location), history !== window.history && (history = window.history), url) {
                    var sameState = lastHistoryState === state;
                    if (lastBrowserUrl === url && (!$sniffer.history || sameState))return self;
                    var sameBase = lastBrowserUrl && stripHash(lastBrowserUrl) === stripHash(url);
                    return lastBrowserUrl = url, lastHistoryState = state, !$sniffer.history || sameBase && sameState ? (sameBase || (pendingLocation = url), replace ? location.replace(url) : sameBase ? location.hash = getHash(url) : location.href = url, location.href !== url && (pendingLocation = url)) : (history[replace ? "replaceState" : "pushState"](state, "", url), cacheState(), lastHistoryState = cachedState), pendingLocation && (pendingLocation = url), self
                }
                return pendingLocation || location.href.replace(/%27/g, "'")
            }, self.state = function () {
                return cachedState
            };
            var urlChangeListeners = [], urlChangeInit = !1, lastCachedState = null;
            self.onUrlChange = function (callback) {
                return urlChangeInit || ($sniffer.history && jqLite(window).on("popstate", cacheStateAndFireUrlChange), jqLite(window).on("hashchange", cacheStateAndFireUrlChange), urlChangeInit = !0), urlChangeListeners.push(callback), callback
            }, self.$$applicationDestroyed = function () {
                jqLite(window).off("hashchange popstate", cacheStateAndFireUrlChange)
            }, self.$$checkUrlChange = fireUrlChange, self.baseHref = function () {
                var href = baseElement.attr("href");
                return href ? href.replace(/^(https?\:)?\/\/[^\/]*/, "") : ""
            }, self.defer = function (fn, delay) {
                var timeoutId;
                return outstandingRequestCount++, timeoutId = setTimeout(function () {
                    delete pendingDeferIds[timeoutId], completeOutstandingRequest(fn)
                }, delay || 0), pendingDeferIds[timeoutId] = !0, timeoutId
            }, self.defer.cancel = function (deferId) {
                return pendingDeferIds[deferId] ? (delete pendingDeferIds[deferId], clearTimeout(deferId), completeOutstandingRequest(noop), !0) : !1
            }
        }

        function $BrowserProvider() {
            this.$get = ["$window", "$log", "$sniffer", "$document", function ($window, $log, $sniffer, $document) {
                return new Browser($window, $document, $log, $sniffer)
            }]
        }

        function $CacheFactoryProvider() {
            this.$get = function () {
                function cacheFactory(cacheId, options) {
                    function refresh(entry) {
                        entry != freshEnd && (staleEnd ? staleEnd == entry && (staleEnd = entry.n) : staleEnd = entry, link(entry.n, entry.p), link(entry, freshEnd), freshEnd = entry, freshEnd.n = null)
                    }

                    function link(nextEntry, prevEntry) {
                        nextEntry != prevEntry && (nextEntry && (nextEntry.p = prevEntry), prevEntry && (prevEntry.n = nextEntry))
                    }

                    if (cacheId in caches)throw minErr("$cacheFactory")("iid", "CacheId '{0}' is already taken!", cacheId);
                    var size = 0, stats = extend({}, options, {id: cacheId}), data = createMap(), capacity = options && options.capacity || Number.MAX_VALUE, lruHash = createMap(), freshEnd = null, staleEnd = null;
                    return caches[cacheId] = {
                        put: function (key, value) {
                            if (!isUndefined(value)) {
                                if (capacity < Number.MAX_VALUE) {
                                    var lruEntry = lruHash[key] || (lruHash[key] = {key: key});
                                    refresh(lruEntry)
                                }
                                return key in data || size++, data[key] = value, size > capacity && this.remove(staleEnd.key), value
                            }
                        }, get: function (key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry)return;
                                refresh(lruEntry)
                            }
                            return data[key]
                        }, remove: function (key) {
                            if (capacity < Number.MAX_VALUE) {
                                var lruEntry = lruHash[key];
                                if (!lruEntry)return;
                                lruEntry == freshEnd && (freshEnd = lruEntry.p), lruEntry == staleEnd && (staleEnd = lruEntry.n), link(lruEntry.n, lruEntry.p), delete lruHash[key]
                            }
                            key in data && (delete data[key], size--)
                        }, removeAll: function () {
                            data = createMap(), size = 0, lruHash = createMap(), freshEnd = staleEnd = null
                        }, destroy: function () {
                            data = null, stats = null, lruHash = null, delete caches[cacheId]
                        }, info: function () {
                            return extend({}, stats, {size: size})
                        }
                    }
                }

                var caches = {};
                return cacheFactory.info = function () {
                    var info = {};
                    return forEach(caches, function (cache, cacheId) {
                        info[cacheId] = cache.info()
                    }), info
                }, cacheFactory.get = function (cacheId) {
                    return caches[cacheId]
                }, cacheFactory
            }
        }

        function $TemplateCacheProvider() {
            this.$get = ["$cacheFactory", function ($cacheFactory) {
                return $cacheFactory("templates")
            }]
        }

        function UNINITIALIZED_VALUE() {
        }

        function $CompileProvider($provide, $$sanitizeUriProvider) {
            function parseIsolateBindings(scope, directiveName, isController) {
                var LOCAL_REGEXP = /^\s*([@&<]|=(\*?))(\??)\s*(\w*)\s*$/, bindings = createMap();
                return forEach(scope, function (definition, scopeName) {
                    if (definition in bindingCache)return void(bindings[scopeName] = bindingCache[definition]);
                    var match = definition.match(LOCAL_REGEXP);
                    if (!match)throw $compileMinErr("iscp", "Invalid {3} for directive '{0}'. Definition: {... {1}: '{2}' ...}", directiveName, scopeName, definition, isController ? "controller bindings definition" : "isolate scope definition");
                    bindings[scopeName] = {
                        mode: match[1][0],
                        collection: "*" === match[2],
                        optional: "?" === match[3],
                        attrName: match[4] || scopeName
                    }, match[4] && (bindingCache[definition] = bindings[scopeName])
                }), bindings
            }

            function parseDirectiveBindings(directive, directiveName) {
                var bindings = {isolateScope: null, bindToController: null};
                if (isObject(directive.scope) && (directive.bindToController === !0 ? (bindings.bindToController = parseIsolateBindings(directive.scope, directiveName, !0), bindings.isolateScope = {}) : bindings.isolateScope = parseIsolateBindings(directive.scope, directiveName, !1)), isObject(directive.bindToController) && (bindings.bindToController = parseIsolateBindings(directive.bindToController, directiveName, !0)), isObject(bindings.bindToController)) {
                    var controller = directive.controller, controllerAs = directive.controllerAs;
                    if (!controller)throw $compileMinErr("noctrl", "Cannot bind to controller without directive '{0}'s controller.", directiveName);
                    if (!identifierForController(controller, controllerAs))throw $compileMinErr("noident", "Cannot bind to controller without identifier for directive '{0}'.", directiveName)
                }
                return bindings
            }

            function assertValidDirectiveName(name) {
                var letter = name.charAt(0);
                if (!letter || letter !== lowercase(letter))throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The first character must be a lowercase letter", name);
                if (name !== name.trim())throw $compileMinErr("baddir", "Directive/Component name '{0}' is invalid. The name should not contain leading or trailing whitespaces", name)
            }

            function getDirectiveRequire(directive) {
                var require = directive.require || directive.controller && directive.name;
                return !isArray(require) && isObject(require) && forEach(require, function (value, key) {
                    var match = value.match(REQUIRE_PREFIX_REGEXP), name = value.substring(match[0].length);
                    name || (require[key] = match[0] + key)
                }), require
            }

            var hasDirectives = {}, Suffix = "Directive", COMMENT_DIRECTIVE_REGEXP = /^\s*directive\:\s*([\w\-]+)\s+(.*)$/, CLASS_DIRECTIVE_REGEXP = /(([\w\-]+)(?:\:([^;]+))?;?)/, ALL_OR_NOTHING_ATTRS = makeMap("ngSrc,ngSrcset,src,srcset"), REQUIRE_PREFIX_REGEXP = /^(?:(\^\^?)?(\?)?(\^\^?)?)?/, EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]+|formaction)$/, bindingCache = createMap();
            this.directive = function registerDirective(name, directiveFactory) {
                return assertNotHasOwnProperty(name, "directive"), isString(name) ? (assertValidDirectiveName(name), assertArg(directiveFactory, "directiveFactory"), hasDirectives.hasOwnProperty(name) || (hasDirectives[name] = [], $provide.factory(name + Suffix, ["$injector", "$exceptionHandler", function ($injector, $exceptionHandler) {
                        var directives = [];
                        return forEach(hasDirectives[name], function (directiveFactory, index) {
                            try {
                                var directive = $injector.invoke(directiveFactory);
                                isFunction(directive) ? directive = {compile: valueFn(directive)} : !directive.compile && directive.link && (directive.compile = valueFn(directive.link)), directive.priority = directive.priority || 0, directive.index = index, directive.name = directive.name || name, directive.require = getDirectiveRequire(directive), directive.restrict = directive.restrict || "EA", directive.$$moduleName = directiveFactory.$$moduleName, directives.push(directive)
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                        }), directives
                    }])), hasDirectives[name].push(directiveFactory)) : forEach(name, reverseParams(registerDirective)), this
            }, this.component = function (name, options) {
                function factory($injector) {
                    function makeInjectable(fn) {
                        return isFunction(fn) || isArray(fn) ? function (tElement, tAttrs) {
                                return $injector.invoke(fn, this, {$element: tElement, $attrs: tAttrs})
                            } : fn
                    }

                    var template = options.template || options.templateUrl ? options.template : "", ddo = {
                        controller: controller,
                        controllerAs: identifierForController(options.controller) || options.controllerAs || "$ctrl",
                        template: makeInjectable(template),
                        templateUrl: makeInjectable(options.templateUrl),
                        transclude: options.transclude,
                        scope: {},
                        bindToController: options.bindings || {},
                        restrict: "E",
                        require: options.require
                    };
                    return forEach(options, function (val, key) {
                        "$" === key.charAt(0) && (ddo[key] = val)
                    }), ddo
                }

                var controller = options.controller || function () {
                    };
                return forEach(options, function (val, key) {
                    "$" === key.charAt(0) && (factory[key] = val, isFunction(controller) && (controller[key] = val))
                }), factory.$inject = ["$injector"], this.directive(name, factory)
            }, this.aHrefSanitizationWhitelist = function (regexp) {
                return isDefined(regexp) ? ($$sanitizeUriProvider.aHrefSanitizationWhitelist(regexp), this) : $$sanitizeUriProvider.aHrefSanitizationWhitelist()
            }, this.imgSrcSanitizationWhitelist = function (regexp) {
                return isDefined(regexp) ? ($$sanitizeUriProvider.imgSrcSanitizationWhitelist(regexp), this) : $$sanitizeUriProvider.imgSrcSanitizationWhitelist()
            };
            var debugInfoEnabled = !0;
            this.debugInfoEnabled = function (enabled) {
                return isDefined(enabled) ? (debugInfoEnabled = enabled, this) : debugInfoEnabled
            };
            var TTL = 10;
            this.onChangesTtl = function (value) {
                return arguments.length ? (TTL = value, this) : TTL
            }, this.$get = ["$injector", "$interpolate", "$exceptionHandler", "$templateRequest", "$parse", "$controller", "$rootScope", "$sce", "$animate", "$$sanitizeUri", function ($injector, $interpolate, $exceptionHandler, $templateRequest, $parse, $controller, $rootScope, $sce, $animate, $$sanitizeUri) {
                function flushOnChangesQueue() {
                    try {
                        if (!--onChangesTtl)throw onChangesQueue = void 0, $compileMinErr("infchng", "{0} $onChanges() iterations reached. Aborting!\n", TTL);
                        $rootScope.$apply(function () {
                            for (var errors = [], i = 0, ii = onChangesQueue.length; ii > i; ++i)try {
                                onChangesQueue[i]()
                            } catch (e) {
                                errors.push(e)
                            }
                            if (onChangesQueue = void 0, errors.length)throw errors
                        })
                    } finally {
                        onChangesTtl++
                    }
                }

                function Attributes(element, attributesToCopy) {
                    if (attributesToCopy) {
                        var i, l, key, keys = Object.keys(attributesToCopy);
                        for (i = 0, l = keys.length; l > i; i++)key = keys[i], this[key] = attributesToCopy[key]
                    } else this.$attr = {};
                    this.$$element = element
                }

                function setSpecialAttr(element, attrName, value) {
                    specialAttrHolder.innerHTML = "<span " + attrName + ">";
                    var attributes = specialAttrHolder.firstChild.attributes, attribute = attributes[0];
                    attributes.removeNamedItem(attribute.name), attribute.value = value, element.attributes.setNamedItem(attribute)
                }

                function safeAddClass($element, className) {
                    try {
                        $element.addClass(className)
                    } catch (e) {
                    }
                }

                function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                    $compileNodes instanceof jqLite || ($compileNodes = jqLite($compileNodes));
                    for (var NOT_EMPTY = /\S+/, i = 0, len = $compileNodes.length; len > i; i++) {
                        var domNode = $compileNodes[i];
                        domNode.nodeType === NODE_TYPE_TEXT && domNode.nodeValue.match(NOT_EMPTY) && jqLiteWrapNode(domNode, $compileNodes[i] = window.document.createElement("span"))
                    }
                    var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective, previousCompileContext);
                    compile.$$addScopeClass($compileNodes);
                    var namespace = null;
                    return function (scope, cloneConnectFn, options) {
                        assertArg(scope, "scope"), previousCompileContext && previousCompileContext.needsNewScope && (scope = scope.$parent.$new()), options = options || {};
                        var parentBoundTranscludeFn = options.parentBoundTranscludeFn, transcludeControllers = options.transcludeControllers, futureParentElement = options.futureParentElement;
                        parentBoundTranscludeFn && parentBoundTranscludeFn.$$boundTransclude && (parentBoundTranscludeFn = parentBoundTranscludeFn.$$boundTransclude), namespace || (namespace = detectNamespaceForChildElements(futureParentElement));
                        var $linkNode;
                        if ($linkNode = "html" !== namespace ? jqLite(wrapTemplate(namespace, jqLite("<div>").append($compileNodes).html())) : cloneConnectFn ? JQLitePrototype.clone.call($compileNodes) : $compileNodes, transcludeControllers)for (var controllerName in transcludeControllers)$linkNode.data("$" + controllerName + "Controller", transcludeControllers[controllerName].instance);
                        return compile.$$addScopeInfo($linkNode, scope), cloneConnectFn && cloneConnectFn($linkNode, scope), compositeLinkFn && compositeLinkFn(scope, $linkNode, $linkNode, parentBoundTranscludeFn), $linkNode
                    }
                }

                function detectNamespaceForChildElements(parentElement) {
                    var node = parentElement && parentElement[0];
                    return node && "foreignobject" !== nodeName_(node) && toString.call(node).match(/SVG/) ? "svg" : "html"
                }

                function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective, previousCompileContext) {
                    function compositeLinkFn(scope, nodeList, $rootElement, parentBoundTranscludeFn) {
                        var nodeLinkFn, childLinkFn, node, childScope, i, ii, idx, childBoundTranscludeFn, stableNodeList;
                        if (nodeLinkFnFound) {
                            var nodeListLength = nodeList.length;
                            for (stableNodeList = new Array(nodeListLength), i = 0; i < linkFns.length; i += 3)idx = linkFns[i], stableNodeList[idx] = nodeList[idx]
                        } else stableNodeList = nodeList;
                        for (i = 0, ii = linkFns.length; ii > i;)node = stableNodeList[linkFns[i++]], nodeLinkFn = linkFns[i++], childLinkFn = linkFns[i++], nodeLinkFn ? (nodeLinkFn.scope ? (childScope = scope.$new(), compile.$$addScopeInfo(jqLite(node), childScope)) : childScope = scope, childBoundTranscludeFn = nodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, nodeLinkFn.transclude, parentBoundTranscludeFn) : !nodeLinkFn.templateOnThisElement && parentBoundTranscludeFn ? parentBoundTranscludeFn : !parentBoundTranscludeFn && transcludeFn ? createBoundTranscludeFn(scope, transcludeFn) : null, nodeLinkFn(childLinkFn, childScope, node, $rootElement, childBoundTranscludeFn)) : childLinkFn && childLinkFn(scope, node.childNodes, void 0, parentBoundTranscludeFn)
                    }

                    for (var attrs, directives, nodeLinkFn, childNodes, childLinkFn, linkFnFound, nodeLinkFnFound, linkFns = [], i = 0; i < nodeList.length; i++)attrs = new Attributes, directives = collectDirectives(nodeList[i], [], attrs, 0 === i ? maxPriority : void 0, ignoreDirective), nodeLinkFn = directives.length ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement, null, [], [], previousCompileContext) : null, nodeLinkFn && nodeLinkFn.scope && compile.$$addScopeClass(attrs.$$element), childLinkFn = nodeLinkFn && nodeLinkFn.terminal || !(childNodes = nodeList[i].childNodes) || !childNodes.length ? null : compileNodes(childNodes, nodeLinkFn ? (nodeLinkFn.transcludeOnThisElement || !nodeLinkFn.templateOnThisElement) && nodeLinkFn.transclude : transcludeFn), (nodeLinkFn || childLinkFn) && (linkFns.push(i, nodeLinkFn, childLinkFn), linkFnFound = !0,
                        nodeLinkFnFound = nodeLinkFnFound || nodeLinkFn), previousCompileContext = null;
                    return linkFnFound ? compositeLinkFn : null
                }

                function createBoundTranscludeFn(scope, transcludeFn, previousBoundTranscludeFn) {
                    function boundTranscludeFn(transcludedScope, cloneFn, controllers, futureParentElement, containingScope) {
                        return transcludedScope || (transcludedScope = scope.$new(!1, containingScope), transcludedScope.$$transcluded = !0), transcludeFn(transcludedScope, cloneFn, {
                            parentBoundTranscludeFn: previousBoundTranscludeFn,
                            transcludeControllers: controllers,
                            futureParentElement: futureParentElement
                        })
                    }

                    var boundSlots = boundTranscludeFn.$$slots = createMap();
                    for (var slotName in transcludeFn.$$slots)transcludeFn.$$slots[slotName] ? boundSlots[slotName] = createBoundTranscludeFn(scope, transcludeFn.$$slots[slotName], previousBoundTranscludeFn) : boundSlots[slotName] = null;
                    return boundTranscludeFn
                }

                function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                    var match, className, nodeType = node.nodeType, attrsMap = attrs.$attr;
                    switch (nodeType) {
                        case NODE_TYPE_ELEMENT:
                            addDirective(directives, directiveNormalize(nodeName_(node)), "E", maxPriority, ignoreDirective);
                            for (var attr, name, nName, ngAttrName, value, isNgAttr, nAttrs = node.attributes, j = 0, jj = nAttrs && nAttrs.length; jj > j; j++) {
                                var attrStartName = !1, attrEndName = !1;
                                attr = nAttrs[j], name = attr.name, value = trim(attr.value), ngAttrName = directiveNormalize(name), (isNgAttr = NG_ATTR_BINDING.test(ngAttrName)) && (name = name.replace(PREFIX_REGEXP, "").substr(8).replace(/_(.)/g, function (match, letter) {
                                    return letter.toUpperCase()
                                }));
                                var multiElementMatch = ngAttrName.match(MULTI_ELEMENT_DIR_RE);
                                multiElementMatch && directiveIsMultiElement(multiElementMatch[1]) && (attrStartName = name, attrEndName = name.substr(0, name.length - 5) + "end", name = name.substr(0, name.length - 6)), nName = directiveNormalize(name.toLowerCase()), attrsMap[nName] = name, (isNgAttr || !attrs.hasOwnProperty(nName)) && (attrs[nName] = value, getBooleanAttrName(node, nName) && (attrs[nName] = !0)), addAttrInterpolateDirective(node, directives, value, nName, isNgAttr), addDirective(directives, nName, "A", maxPriority, ignoreDirective, attrStartName, attrEndName)
                            }
                            if (className = node.className, isObject(className) && (className = className.animVal), isString(className) && "" !== className)for (; match = CLASS_DIRECTIVE_REGEXP.exec(className);)nName = directiveNormalize(match[2]), addDirective(directives, nName, "C", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[3])), className = className.substr(match.index + match[0].length);
                            break;
                        case NODE_TYPE_TEXT:
                            if (11 === msie)for (; node.parentNode && node.nextSibling && node.nextSibling.nodeType === NODE_TYPE_TEXT;)node.nodeValue = node.nodeValue + node.nextSibling.nodeValue, node.parentNode.removeChild(node.nextSibling);
                            addTextInterpolateDirective(directives, node.nodeValue);
                            break;
                        case NODE_TYPE_COMMENT:
                            collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective)
                    }
                    return directives.sort(byPriority), directives
                }

                function collectCommentDirectives(node, directives, attrs, maxPriority, ignoreDirective) {
                    try {
                        var match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);
                        if (match) {
                            var nName = directiveNormalize(match[1]);
                            addDirective(directives, nName, "M", maxPriority, ignoreDirective) && (attrs[nName] = trim(match[2]))
                        }
                    } catch (e) {
                    }
                }

                function groupScan(node, attrStart, attrEnd) {
                    var nodes = [], depth = 0;
                    if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {
                        do {
                            if (!node)throw $compileMinErr("uterdir", "Unterminated attribute, found '{0}' but no matching '{1}' found.", attrStart, attrEnd);
                            node.nodeType == NODE_TYPE_ELEMENT && (node.hasAttribute(attrStart) && depth++, node.hasAttribute(attrEnd) && depth--), nodes.push(node), node = node.nextSibling
                        } while (depth > 0)
                    } else nodes.push(node);
                    return jqLite(nodes)
                }

                function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {
                    return function (scope, element, attrs, controllers, transcludeFn) {
                        return element = groupScan(element[0], attrStart, attrEnd), linkFn(scope, element, attrs, controllers, transcludeFn)
                    }
                }

                function compilationGenerator(eager, $compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) {
                    var compiled;
                    return eager ? compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext) : function () {
                            return compiled || (compiled = compile($compileNodes, transcludeFn, maxPriority, ignoreDirective, previousCompileContext), $compileNodes = transcludeFn = previousCompileContext = null), compiled.apply(this, arguments)
                        }
                }

                function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective, preLinkFns, postLinkFns, previousCompileContext) {
                    function addLinkFns(pre, post, attrStart, attrEnd) {
                        pre && (attrStart && (pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd)), pre.require = directive.require, pre.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (pre = cloneAndAnnotateFn(pre, {isolateScope: !0})), preLinkFns.push(pre)), post && (attrStart && (post = groupElementsLinkFnWrapper(post, attrStart, attrEnd)), post.require = directive.require, post.directiveName = directiveName, (newIsolateScopeDirective === directive || directive.$$isolateScope) && (post = cloneAndAnnotateFn(post, {isolateScope: !0})), postLinkFns.push(post))
                    }

                    function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {
                        function controllersBoundTransclude(scope, cloneAttachFn, futureParentElement, slotName) {
                            var transcludeControllers;
                            if (isScope(scope) || (slotName = futureParentElement, futureParentElement = cloneAttachFn, cloneAttachFn = scope, scope = void 0), hasElementTranscludeDirective && (transcludeControllers = elementControllers), futureParentElement || (futureParentElement = hasElementTranscludeDirective ? $element.parent() : $element), !slotName)return boundTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                            var slotTranscludeFn = boundTranscludeFn.$$slots[slotName];
                            if (slotTranscludeFn)return slotTranscludeFn(scope, cloneAttachFn, transcludeControllers, futureParentElement, scopeToChild);
                            if (isUndefined(slotTranscludeFn))throw $compileMinErr("noslot", 'No parent directive that requires a transclusion with slot name "{0}". Element: {1}', slotName, startingTag($element))
                        }

                        var i, ii, linkFn, isolateScope, controllerScope, elementControllers, transcludeFn, $element, attrs, scopeBindingInfo;
                        compileNode === linkNode ? (attrs = templateAttrs, $element = templateAttrs.$$element) : ($element = jqLite(linkNode), attrs = new Attributes($element, templateAttrs)), controllerScope = scope, newIsolateScopeDirective ? isolateScope = scope.$new(!0) : newScopeDirective && (controllerScope = scope.$parent), boundTranscludeFn && (transcludeFn = controllersBoundTransclude, transcludeFn.$$boundTransclude = boundTranscludeFn, transcludeFn.isSlotFilled = function (slotName) {
                            return !!boundTranscludeFn.$$slots[slotName]
                        }), controllerDirectives && (elementControllers = setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective)), newIsolateScopeDirective && (compile.$$addScopeInfo($element, isolateScope, !0, !(templateDirective && (templateDirective === newIsolateScopeDirective || templateDirective === newIsolateScopeDirective.$$originalDirective))), compile.$$addScopeClass($element, !0), isolateScope.$$isolateBindings = newIsolateScopeDirective.$$isolateBindings, scopeBindingInfo = initializeDirectiveBindings(scope, attrs, isolateScope, isolateScope.$$isolateBindings, newIsolateScopeDirective), scopeBindingInfo.removeWatches && isolateScope.$on("$destroy", scopeBindingInfo.removeWatches));
                        for (var name in elementControllers) {
                            var controllerDirective = controllerDirectives[name], controller = elementControllers[name], bindings = controllerDirective.$$bindings.bindToController;
                            controller.identifier && bindings ? controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective) : controller.bindingInfo = {};
                            var controllerResult = controller();
                            controllerResult !== controller.instance && (controller.instance = controllerResult, $element.data("$" + controllerDirective.name + "Controller", controllerResult), controller.bindingInfo.removeWatches && controller.bindingInfo.removeWatches(), controller.bindingInfo = initializeDirectiveBindings(controllerScope, attrs, controller.instance, bindings, controllerDirective))
                        }
                        for (forEach(controllerDirectives, function (controllerDirective, name) {
                            var require = controllerDirective.require;
                            controllerDirective.bindToController && !isArray(require) && isObject(require) && extend(elementControllers[name].instance, getControllers(name, require, $element, elementControllers))
                        }), forEach(elementControllers, function (controller) {
                            var controllerInstance = controller.instance;
                            if (isFunction(controllerInstance.$onChanges))try {
                                controllerInstance.$onChanges(controller.bindingInfo.initialChanges)
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                            if (isFunction(controllerInstance.$onInit))try {
                                controllerInstance.$onInit()
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                            isFunction(controllerInstance.$doCheck) && (controllerScope.$watch(function () {
                                controllerInstance.$doCheck()
                            }), controllerInstance.$doCheck()), isFunction(controllerInstance.$onDestroy) && controllerScope.$on("$destroy", function () {
                                controllerInstance.$onDestroy()
                            })
                        }), i = 0, ii = preLinkFns.length; ii > i; i++)linkFn = preLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                        var scopeToChild = scope;
                        for (newIsolateScopeDirective && (newIsolateScopeDirective.template || null === newIsolateScopeDirective.templateUrl) && (scopeToChild = isolateScope), childLinkFn && childLinkFn(scopeToChild, linkNode.childNodes, void 0, boundTranscludeFn), i = postLinkFns.length - 1; i >= 0; i--)linkFn = postLinkFns[i], invokeLinkFn(linkFn, linkFn.isolateScope ? isolateScope : scope, $element, attrs, linkFn.require && getControllers(linkFn.directiveName, linkFn.require, $element, elementControllers), transcludeFn);
                        forEach(elementControllers, function (controller) {
                            var controllerInstance = controller.instance;
                            isFunction(controllerInstance.$postLink) && controllerInstance.$postLink()
                        })
                    }

                    previousCompileContext = previousCompileContext || {};
                    for (var directive, directiveName, $template, linkFn, directiveValue, terminalPriority = -Number.MAX_VALUE, newScopeDirective = previousCompileContext.newScopeDirective, controllerDirectives = previousCompileContext.controllerDirectives, newIsolateScopeDirective = previousCompileContext.newIsolateScopeDirective, templateDirective = previousCompileContext.templateDirective, nonTlbTranscludeDirective = previousCompileContext.nonTlbTranscludeDirective, hasTranscludeDirective = !1, hasTemplate = !1, hasElementTranscludeDirective = previousCompileContext.hasElementTranscludeDirective, $compileNode = templateAttrs.$$element = jqLite(compileNode), replaceDirective = originalReplaceDirective, childTranscludeFn = transcludeFn, didScanForMultipleTransclusion = !1, mightHaveMultipleTransclusionError = !1, i = 0, ii = directives.length; ii > i; i++) {
                        directive = directives[i];
                        var attrStart = directive.$$start, attrEnd = directive.$$end;
                        if (attrStart && ($compileNode = groupScan(compileNode, attrStart, attrEnd)), $template = void 0, terminalPriority > directive.priority)break;
                        if ((directiveValue = directive.scope) && (directive.templateUrl || (isObject(directiveValue) ? (assertNoDuplicate("new/isolated scope", newIsolateScopeDirective || newScopeDirective, directive, $compileNode), newIsolateScopeDirective = directive) : assertNoDuplicate("new/isolated scope", newIsolateScopeDirective, directive, $compileNode)), newScopeDirective = newScopeDirective || directive), directiveName = directive.name, !didScanForMultipleTransclusion && (directive.replace && (directive.templateUrl || directive.template) || directive.transclude && !directive.$$tlb)) {
                            for (var candidateDirective, scanningIndex = i + 1; candidateDirective = directives[scanningIndex++];)if (candidateDirective.transclude && !candidateDirective.$$tlb || candidateDirective.replace && (candidateDirective.templateUrl || candidateDirective.template)) {
                                mightHaveMultipleTransclusionError = !0;
                                break
                            }
                            didScanForMultipleTransclusion = !0
                        }
                        if (!directive.templateUrl && directive.controller && (directiveValue = directive.controller, controllerDirectives = controllerDirectives || createMap(), assertNoDuplicate("'" + directiveName + "' controller", controllerDirectives[directiveName], directive, $compileNode), controllerDirectives[directiveName] = directive), directiveValue = directive.transclude)if (hasTranscludeDirective = !0, directive.$$tlb || (assertNoDuplicate("transclusion", nonTlbTranscludeDirective, directive, $compileNode), nonTlbTranscludeDirective = directive), "element" == directiveValue) hasElementTranscludeDirective = !0, terminalPriority = directive.priority, $template = $compileNode, $compileNode = templateAttrs.$$element = jqLite(compile.$$createComment(directiveName, templateAttrs[directiveName])), compileNode = $compileNode[0], replaceWith(jqCollection, sliceArgs($template), compileNode), $template[0].$$parentNode = $template[0].parentNode, childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, terminalPriority, replaceDirective && replaceDirective.name, {nonTlbTranscludeDirective: nonTlbTranscludeDirective}); else {
                            var slots = createMap();
                            if ($template = jqLite(jqLiteClone(compileNode)).contents(), isObject(directiveValue)) {
                                $template = [];
                                var slotMap = createMap(), filledSlots = createMap();
                                forEach(directiveValue, function (elementSelector, slotName) {
                                    var optional = "?" === elementSelector.charAt(0);
                                    elementSelector = optional ? elementSelector.substring(1) : elementSelector, slotMap[elementSelector] = slotName, slots[slotName] = null, filledSlots[slotName] = optional
                                }), forEach($compileNode.contents(), function (node) {
                                    var slotName = slotMap[directiveNormalize(nodeName_(node))];
                                    slotName ? (filledSlots[slotName] = !0, slots[slotName] = slots[slotName] || [], slots[slotName].push(node)) : $template.push(node)
                                }), forEach(filledSlots, function (filled, slotName) {
                                    if (!filled)throw $compileMinErr("reqslot", "Required transclusion slot `{0}` was not filled.", slotName)
                                });
                                for (var slotName in slots)slots[slotName] && (slots[slotName] = compilationGenerator(mightHaveMultipleTransclusionError, slots[slotName], transcludeFn))
                            }
                            $compileNode.empty(), childTranscludeFn = compilationGenerator(mightHaveMultipleTransclusionError, $template, transcludeFn, void 0, void 0, {needsNewScope: directive.$$isolateScope || directive.$$newScope}), childTranscludeFn.$$slots = slots
                        }
                        if (directive.template)if (hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, directiveValue = isFunction(directive.template) ? directive.template($compileNode, templateAttrs) : directive.template, directiveValue = denormalizeTemplate(directiveValue), directive.replace) {
                            if (replaceDirective = directive, $template = jqLiteIsTextNode(directiveValue) ? [] : removeComments(wrapTemplate(directive.templateNamespace, trim(directiveValue))), compileNode = $template[0], 1 != $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT)throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", directiveName, "");
                            replaceWith(jqCollection, $compileNode, compileNode);
                            var newTemplateAttrs = {$attr: {}}, templateDirectives = collectDirectives(compileNode, [], newTemplateAttrs), unprocessedDirectives = directives.splice(i + 1, directives.length - (i + 1));
                            (newIsolateScopeDirective || newScopeDirective) && markDirectiveScope(templateDirectives, newIsolateScopeDirective, newScopeDirective), directives = directives.concat(templateDirectives).concat(unprocessedDirectives), mergeTemplateAttributes(templateAttrs, newTemplateAttrs), ii = directives.length
                        } else $compileNode.html(directiveValue);
                        if (directive.templateUrl) hasTemplate = !0, assertNoDuplicate("template", templateDirective, directive, $compileNode), templateDirective = directive, directive.replace && (replaceDirective = directive), nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i), $compileNode, templateAttrs, jqCollection, hasTranscludeDirective && childTranscludeFn, preLinkFns, postLinkFns, {
                            controllerDirectives: controllerDirectives,
                            newScopeDirective: newScopeDirective !== directive && newScopeDirective,
                            newIsolateScopeDirective: newIsolateScopeDirective,
                            templateDirective: templateDirective,
                            nonTlbTranscludeDirective: nonTlbTranscludeDirective
                        }), ii = directives.length; else if (directive.compile)try {
                            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);
                            var context = directive.$$originalDirective || directive;
                            isFunction(linkFn) ? addLinkFns(null, bind(context, linkFn), attrStart, attrEnd) : linkFn && addLinkFns(bind(context, linkFn.pre), bind(context, linkFn.post), attrStart, attrEnd)
                        } catch (e) {
                            $exceptionHandler(e, startingTag($compileNode))
                        }
                        directive.terminal && (nodeLinkFn.terminal = !0, terminalPriority = Math.max(terminalPriority, directive.priority))
                    }
                    return nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope === !0, nodeLinkFn.transcludeOnThisElement = hasTranscludeDirective, nodeLinkFn.templateOnThisElement = hasTemplate, nodeLinkFn.transclude = childTranscludeFn, previousCompileContext.hasElementTranscludeDirective = hasElementTranscludeDirective, nodeLinkFn
                }

                function getControllers(directiveName, require, $element, elementControllers) {
                    var value;
                    if (isString(require)) {
                        var match = require.match(REQUIRE_PREFIX_REGEXP), name = require.substring(match[0].length), inheritType = match[1] || match[3], optional = "?" === match[2];
                        if ("^^" === inheritType ? $element = $element.parent() : (value = elementControllers && elementControllers[name], value = value && value.instance), !value) {
                            var dataName = "$" + name + "Controller";
                            value = inheritType ? $element.inheritedData(dataName) : $element.data(dataName)
                        }
                        if (!value && !optional)throw $compileMinErr("ctreq", "Controller '{0}', required by directive '{1}', can't be found!", name, directiveName)
                    } else if (isArray(require)) {
                        value = [];
                        for (var i = 0, ii = require.length; ii > i; i++)value[i] = getControllers(directiveName, require[i], $element, elementControllers)
                    } else isObject(require) && (value = {}, forEach(require, function (controller, property) {
                        value[property] = getControllers(directiveName, controller, $element, elementControllers)
                    }));
                    return value || null
                }

                function setupControllers($element, attrs, transcludeFn, controllerDirectives, isolateScope, scope, newIsolateScopeDirective) {
                    var elementControllers = createMap();
                    for (var controllerKey in controllerDirectives) {
                        var directive = controllerDirectives[controllerKey], locals = {
                            $scope: directive === newIsolateScopeDirective || directive.$$isolateScope ? isolateScope : scope,
                            $element: $element,
                            $attrs: attrs,
                            $transclude: transcludeFn
                        }, controller = directive.controller;
                        "@" == controller && (controller = attrs[directive.name]);
                        var controllerInstance = $controller(controller, locals, !0, directive.controllerAs);
                        elementControllers[directive.name] = controllerInstance, $element.data("$" + directive.name + "Controller", controllerInstance.instance)
                    }
                    return elementControllers
                }

                function markDirectiveScope(directives, isolateScope, newScope) {
                    for (var j = 0, jj = directives.length; jj > j; j++)directives[j] = inherit(directives[j], {
                        $$isolateScope: isolateScope,
                        $$newScope: newScope
                    })
                }

                function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {
                    if (name === ignoreDirective)return null;
                    var match = null;
                    if (hasDirectives.hasOwnProperty(name))for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++)try {
                        if (directive = directives[i], (isUndefined(maxPriority) || maxPriority > directive.priority) && -1 != directive.restrict.indexOf(location)) {
                            if (startAttrName && (directive = inherit(directive, {
                                    $$start: startAttrName,
                                    $$end: endAttrName
                                })), !directive.$$bindings) {
                                var bindings = directive.$$bindings = parseDirectiveBindings(directive, directive.name);
                                isObject(bindings.isolateScope) && (directive.$$isolateBindings = bindings.isolateScope)
                            }
                            tDirectives.push(directive), match = directive
                        }
                    } catch (e) {
                        $exceptionHandler(e)
                    }
                    return match
                }

                function directiveIsMultiElement(name) {
                    if (hasDirectives.hasOwnProperty(name))for (var directive, directives = $injector.get(name + Suffix), i = 0, ii = directives.length; ii > i; i++)if (directive = directives[i], directive.multiElement)return !0;
                    return !1
                }

                function mergeTemplateAttributes(dst, src) {
                    var srcAttr = src.$attr, dstAttr = dst.$attr;
                    dst.$$element;
                    forEach(dst, function (value, key) {
                        "$" != key.charAt(0) && (src[key] && src[key] !== value && (value += ("style" === key ? ";" : " ") + src[key]), dst.$set(key, value, !0, srcAttr[key]))
                    }), forEach(src, function (value, key) {
                        dst.hasOwnProperty(key) || "$" === key.charAt(0) || (dst[key] = value, "class" !== key && "style" !== key && (dstAttr[key] = srcAttr[key]))
                    })
                }

                function compileTemplateUrl(directives, $compileNode, tAttrs, $rootElement, childTranscludeFn, preLinkFns, postLinkFns, previousCompileContext) {
                    var afterTemplateNodeLinkFn, afterTemplateChildLinkFn, linkQueue = [], beforeTemplateCompileNode = $compileNode[0], origAsyncDirective = directives.shift(), derivedSyncDirective = inherit(origAsyncDirective, {
                        templateUrl: null,
                        transclude: null,
                        replace: null,
                        $$originalDirective: origAsyncDirective
                    }), templateUrl = isFunction(origAsyncDirective.templateUrl) ? origAsyncDirective.templateUrl($compileNode, tAttrs) : origAsyncDirective.templateUrl, templateNamespace = origAsyncDirective.templateNamespace;
                    return $compileNode.empty(), $templateRequest(templateUrl).then(function (content) {
                        var compileNode, tempTemplateAttrs, $template, childBoundTranscludeFn;
                        if (content = denormalizeTemplate(content), origAsyncDirective.replace) {
                            if ($template = jqLiteIsTextNode(content) ? [] : removeComments(wrapTemplate(templateNamespace, trim(content))), compileNode = $template[0], 1 != $template.length || compileNode.nodeType !== NODE_TYPE_ELEMENT)throw $compileMinErr("tplrt", "Template for directive '{0}' must have exactly one root element. {1}", origAsyncDirective.name, templateUrl);
                            tempTemplateAttrs = {$attr: {}}, replaceWith($rootElement, $compileNode, compileNode);
                            var templateDirectives = collectDirectives(compileNode, [], tempTemplateAttrs);
                            isObject(origAsyncDirective.scope) && markDirectiveScope(templateDirectives, !0), directives = templateDirectives.concat(directives), mergeTemplateAttributes(tAttrs, tempTemplateAttrs)
                        } else compileNode = beforeTemplateCompileNode, $compileNode.html(content);
                        for (directives.unshift(derivedSyncDirective), afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective, preLinkFns, postLinkFns, previousCompileContext), forEach($rootElement, function (node, i) {
                            node == compileNode && ($rootElement[i] = $compileNode[0])
                        }), afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn); linkQueue.length;) {
                            var scope = linkQueue.shift(), beforeTemplateLinkNode = linkQueue.shift(), linkRootElement = linkQueue.shift(), boundTranscludeFn = linkQueue.shift(), linkNode = $compileNode[0];
                            if (!scope.$$destroyed) {
                                if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {
                                    var oldClasses = beforeTemplateLinkNode.className;
                                    previousCompileContext.hasElementTranscludeDirective && origAsyncDirective.replace || (linkNode = jqLiteClone(compileNode)), replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode), safeAddClass(jqLite(linkNode), oldClasses)
                                }
                                childBoundTranscludeFn = afterTemplateNodeLinkFn.transcludeOnThisElement ? createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn) : boundTranscludeFn, afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, childBoundTranscludeFn)
                            }
                        }
                        linkQueue = null
                    }), function (ignoreChildLinkFn, scope, node, rootElement, boundTranscludeFn) {
                        var childBoundTranscludeFn = boundTranscludeFn;
                        scope.$$destroyed || (linkQueue ? linkQueue.push(scope, node, rootElement, childBoundTranscludeFn) : (afterTemplateNodeLinkFn.transcludeOnThisElement && (childBoundTranscludeFn = createBoundTranscludeFn(scope, afterTemplateNodeLinkFn.transclude, boundTranscludeFn)), afterTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, childBoundTranscludeFn)))
                    }
                }

                function byPriority(a, b) {
                    var diff = b.priority - a.priority;
                    return 0 !== diff ? diff : a.name !== b.name ? a.name < b.name ? -1 : 1 : a.index - b.index
                }

                function assertNoDuplicate(what, previousDirective, directive, element) {
                    function wrapModuleNameIfDefined(moduleName) {
                        return moduleName ? " (module: " + moduleName + ")" : ""
                    }

                    if (previousDirective)throw $compileMinErr("multidir", "Multiple directives [{0}{1}, {2}{3}] asking for {4} on: {5}", previousDirective.name, wrapModuleNameIfDefined(previousDirective.$$moduleName), directive.name, wrapModuleNameIfDefined(directive.$$moduleName), what, startingTag(element))
                }

                function addTextInterpolateDirective(directives, text) {
                    var interpolateFn = $interpolate(text, !0);
                    interpolateFn && directives.push({
                        priority: 0, compile: function (templateNode) {
                            var templateNodeParent = templateNode.parent(), hasCompileParent = !!templateNodeParent.length;
                            return hasCompileParent && compile.$$addBindingClass(templateNodeParent), function (scope, node) {
                                var parent = node.parent();
                                hasCompileParent || compile.$$addBindingClass(parent), compile.$$addBindingInfo(parent, interpolateFn.expressions), scope.$watch(interpolateFn, function (value) {
                                    node[0].nodeValue = value
                                })
                            }
                        }
                    })
                }

                function wrapTemplate(type, template) {
                    switch (type = lowercase(type || "html")) {
                        case"svg":
                        case"math":
                            var wrapper = window.document.createElement("div");
                            return wrapper.innerHTML = "<" + type + ">" + template + "</" + type + ">", wrapper.childNodes[0].childNodes;
                        default:
                            return template
                    }
                }

                function getTrustedContext(node, attrNormalizedName) {
                    if ("srcdoc" == attrNormalizedName)return $sce.HTML;
                    var tag = nodeName_(node);
                    return "xlinkHref" == attrNormalizedName || "form" == tag && "action" == attrNormalizedName || "img" != tag && ("src" == attrNormalizedName || "ngSrc" == attrNormalizedName) ? $sce.RESOURCE_URL : void 0
                }

                function addAttrInterpolateDirective(node, directives, value, name, allOrNothing) {
                    var trustedContext = getTrustedContext(node, name);
                    allOrNothing = ALL_OR_NOTHING_ATTRS[name] || allOrNothing;
                    var interpolateFn = $interpolate(value, !0, trustedContext, allOrNothing);
                    if (interpolateFn) {
                        if ("multiple" === name && "select" === nodeName_(node))throw $compileMinErr("selmulti", "Binding to the 'multiple' attribute is not supported. Element: {0}", startingTag(node));
                        directives.push({
                            priority: 100, compile: function () {
                                return {
                                    pre: function (scope, element, attr) {
                                        var $$observers = attr.$$observers || (attr.$$observers = createMap());
                                        if (EVENT_HANDLER_ATTR_REGEXP.test(name))throw $compileMinErr("nodomevents", "Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- versions (such as ng-click instead of onclick) instead.");
                                        var newValue = attr[name];
                                        newValue !== value && (interpolateFn = newValue && $interpolate(newValue, !0, trustedContext, allOrNothing), value = newValue), interpolateFn && (attr[name] = interpolateFn(scope), ($$observers[name] || ($$observers[name] = [])).$$inter = !0, (attr.$$observers && attr.$$observers[name].$$scope || scope).$watch(interpolateFn, function (newValue, oldValue) {
                                            "class" === name && newValue != oldValue ? attr.$updateClass(newValue, oldValue) : attr.$set(name, newValue)
                                        }))
                                    }
                                }
                            }
                        })
                    }
                }

                function replaceWith($rootElement, elementsToRemove, newNode) {
                    var i, ii, firstElementToRemove = elementsToRemove[0], removeCount = elementsToRemove.length, parent = firstElementToRemove.parentNode;
                    if ($rootElement)for (i = 0, ii = $rootElement.length; ii > i; i++)if ($rootElement[i] == firstElementToRemove) {
                        $rootElement[i++] = newNode;
                        for (var j = i, j2 = j + removeCount - 1, jj = $rootElement.length; jj > j; j++, j2++)jj > j2 ? $rootElement[j] = $rootElement[j2] : delete $rootElement[j];
                        $rootElement.length -= removeCount - 1, $rootElement.context === firstElementToRemove && ($rootElement.context = newNode);
                        break
                    }
                    parent && parent.replaceChild(newNode, firstElementToRemove);
                    var fragment = window.document.createDocumentFragment();
                    for (i = 0; removeCount > i; i++)fragment.appendChild(elementsToRemove[i]);
                    for (jqLite.hasData(firstElementToRemove) && (jqLite.data(newNode, jqLite.data(firstElementToRemove)), jqLite(firstElementToRemove).off("$destroy")), jqLite.cleanData(fragment.querySelectorAll("*")), i = 1; removeCount > i; i++)delete elementsToRemove[i];
                    elementsToRemove[0] = newNode, elementsToRemove.length = 1
                }

                function cloneAndAnnotateFn(fn, annotation) {
                    return extend(function () {
                        return fn.apply(null, arguments)
                    }, fn, annotation)
                }

                function invokeLinkFn(linkFn, scope, $element, attrs, controllers, transcludeFn) {
                    try {
                        linkFn(scope, $element, attrs, controllers, transcludeFn)
                    } catch (e) {
                        $exceptionHandler(e, startingTag($element))
                    }
                }

                function initializeDirectiveBindings(scope, attrs, destination, bindings, directive) {
                    function recordChanges(key, currentValue, previousValue) {
                        isFunction(destination.$onChanges) && currentValue !== previousValue && (onChangesQueue || (scope.$$postDigest(flushOnChangesQueue), onChangesQueue = []), changes || (changes = {}, onChangesQueue.push(triggerOnChangesHook)), changes[key] && (previousValue = changes[key].previousValue), changes[key] = new SimpleChange(previousValue, currentValue))
                    }

                    function triggerOnChangesHook() {
                        destination.$onChanges(changes), changes = void 0
                    }

                    var changes, removeWatchCollection = [], initialChanges = {};
                    return forEach(bindings, function (definition, scopeName) {
                        var lastValue, parentGet, parentSet, compare, removeWatch, attrName = definition.attrName, optional = definition.optional, mode = definition.mode;
                        switch (mode) {
                            case"@":
                                optional || hasOwnProperty.call(attrs, attrName) || (destination[scopeName] = attrs[attrName] = void 0), attrs.$observe(attrName, function (value) {
                                    if (isString(value) || isBoolean(value)) {
                                        var oldValue = destination[scopeName];
                                        recordChanges(scopeName, value, oldValue), destination[scopeName] = value
                                    }
                                }), attrs.$$observers[attrName].$$scope = scope, lastValue = attrs[attrName], isString(lastValue) ? destination[scopeName] = $interpolate(lastValue)(scope) : isBoolean(lastValue) && (destination[scopeName] = lastValue), initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]);
                                break;
                            case"=":
                                if (!hasOwnProperty.call(attrs, attrName)) {
                                    if (optional)break;
                                    attrs[attrName] = void 0
                                }
                                if (optional && !attrs[attrName])break;
                                parentGet = $parse(attrs[attrName]), compare = parentGet.literal ? equals : function (a, b) {
                                        return a === b || a !== a && b !== b
                                    }, parentSet = parentGet.assign || function () {
                                        throw lastValue = destination[scopeName] = parentGet(scope), $compileMinErr("nonassign", "Expression '{0}' in attribute '{1}' used with directive '{2}' is non-assignable!", attrs[attrName], attrName, directive.name)
                                    }, lastValue = destination[scopeName] = parentGet(scope);
                                var parentValueWatch = function (parentValue) {
                                    return compare(parentValue, destination[scopeName]) || (compare(parentValue, lastValue) ? parentSet(scope, parentValue = destination[scopeName]) : destination[scopeName] = parentValue), lastValue = parentValue
                                };
                                parentValueWatch.$stateful = !0, removeWatch = definition.collection ? scope.$watchCollection(attrs[attrName], parentValueWatch) : scope.$watch($parse(attrs[attrName], parentValueWatch), null, parentGet.literal), removeWatchCollection.push(removeWatch);
                                break;
                            case"<":
                                if (!hasOwnProperty.call(attrs, attrName)) {
                                    if (optional)break;
                                    attrs[attrName] = void 0
                                }
                                if (optional && !attrs[attrName])break;
                                parentGet = $parse(attrs[attrName]);
                                var initialValue = destination[scopeName] = parentGet(scope);
                                initialChanges[scopeName] = new SimpleChange(_UNINITIALIZED_VALUE, destination[scopeName]), removeWatch = scope.$watch(parentGet, function (newValue, oldValue) {
                                    if (oldValue === newValue) {
                                        if (oldValue === initialValue)return;
                                        oldValue = initialValue
                                    }
                                    recordChanges(scopeName, newValue, oldValue), destination[scopeName] = newValue
                                }, parentGet.literal), removeWatchCollection.push(removeWatch);
                                break;
                            case"&":
                                if (parentGet = attrs.hasOwnProperty(attrName) ? $parse(attrs[attrName]) : noop, parentGet === noop && optional)break;
                                destination[scopeName] = function (locals) {
                                    return parentGet(scope, locals)
                                }
                        }
                    }), {
                        initialChanges: initialChanges, removeWatches: removeWatchCollection.length && function () {
                            for (var i = 0, ii = removeWatchCollection.length; ii > i; ++i)removeWatchCollection[i]()
                        }
                    }
                }

                var onChangesQueue, SIMPLE_ATTR_NAME = /^\w/, specialAttrHolder = window.document.createElement("div"), onChangesTtl = TTL;
                Attributes.prototype = {
                    $normalize: directiveNormalize, $addClass: function (classVal) {
                        classVal && classVal.length > 0 && $animate.addClass(this.$$element, classVal)
                    }, $removeClass: function (classVal) {
                        classVal && classVal.length > 0 && $animate.removeClass(this.$$element, classVal)
                    }, $updateClass: function (newClasses, oldClasses) {
                        var toAdd = tokenDifference(newClasses, oldClasses);
                        toAdd && toAdd.length && $animate.addClass(this.$$element, toAdd);
                        var toRemove = tokenDifference(oldClasses, newClasses);
                        toRemove && toRemove.length && $animate.removeClass(this.$$element, toRemove)
                    }, $set: function (key, value, writeAttr, attrName) {
                        var nodeName, node = this.$$element[0], booleanKey = getBooleanAttrName(node, key), aliasedKey = getAliasedAttrName(key), observer = key;
                        if (booleanKey ? (this.$$element.prop(key, value), attrName = booleanKey) : aliasedKey && (this[aliasedKey] = value, observer = aliasedKey), this[key] = value, attrName ? this.$attr[key] = attrName : (attrName = this.$attr[key], attrName || (this.$attr[key] = attrName = snake_case(key, "-"))), nodeName = nodeName_(this.$$element), "a" === nodeName && ("href" === key || "xlinkHref" === key) || "img" === nodeName && "src" === key) this[key] = value = $$sanitizeUri(value, "src" === key); else if ("img" === nodeName && "srcset" === key && isDefined(value)) {
                            for (var result = "", trimmedSrcset = trim(value), srcPattern = /(\s+\d+x\s*,|\s+\d+w\s*,|\s+,|,\s+)/, pattern = /\s/.test(trimmedSrcset) ? srcPattern : /(,)/, rawUris = trimmedSrcset.split(pattern), nbrUrisWith2parts = Math.floor(rawUris.length / 2), i = 0; nbrUrisWith2parts > i; i++) {
                                var innerIdx = 2 * i;
                                result += $$sanitizeUri(trim(rawUris[innerIdx]), !0), result += " " + trim(rawUris[innerIdx + 1])
                            }
                            var lastTuple = trim(rawUris[2 * i]).split(/\s/);
                            result += $$sanitizeUri(trim(lastTuple[0]), !0), 2 === lastTuple.length && (result += " " + trim(lastTuple[1])), this[key] = value = result
                        }
                        writeAttr !== !1 && (null === value || isUndefined(value) ? this.$$element.removeAttr(attrName) : SIMPLE_ATTR_NAME.test(attrName) ? this.$$element.attr(attrName, value) : setSpecialAttr(this.$$element[0], attrName, value));
                        var $$observers = this.$$observers;
                        $$observers && forEach($$observers[observer], function (fn) {
                            try {
                                fn(value)
                            } catch (e) {
                                $exceptionHandler(e)
                            }
                        })
                    }, $observe: function (key, fn) {
                        var attrs = this, $$observers = attrs.$$observers || (attrs.$$observers = createMap()), listeners = $$observers[key] || ($$observers[key] = []);
                        return listeners.push(fn), $rootScope.$evalAsync(function () {
                            listeners.$$inter || !attrs.hasOwnProperty(key) || isUndefined(attrs[key]) || fn(attrs[key])
                        }), function () {
                            arrayRemove(listeners, fn)
                        }
                    }
                };
                var startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), denormalizeTemplate = "{{" == startSymbol && "}}" == endSymbol ? identity : function (template) {
                        return template.replace(/\{\{/g, startSymbol).replace(/}}/g, endSymbol)
                    }, NG_ATTR_BINDING = /^ngAttr[A-Z]/, MULTI_ELEMENT_DIR_RE = /^(.+)Start$/;
                return compile.$$addBindingInfo = debugInfoEnabled ? function ($element, binding) {
                        var bindings = $element.data("$binding") || [];
                        isArray(binding) ? bindings = bindings.concat(binding) : bindings.push(binding), $element.data("$binding", bindings)
                    } : noop, compile.$$addBindingClass = debugInfoEnabled ? function ($element) {
                        safeAddClass($element, "ng-binding")
                    } : noop, compile.$$addScopeInfo = debugInfoEnabled ? function ($element, scope, isolated, noTemplate) {
                        var dataName = isolated ? noTemplate ? "$isolateScopeNoTemplate" : "$isolateScope" : "$scope";
                        $element.data(dataName, scope)
                    } : noop, compile.$$addScopeClass = debugInfoEnabled ? function ($element, isolated) {
                        safeAddClass($element, isolated ? "ng-isolate-scope" : "ng-scope")
                    } : noop, compile.$$createComment = function (directiveName, comment) {
                    var content = "";
                    return debugInfoEnabled && (content = " " + (directiveName || "") + ": ", comment && (content += comment + " ")), window.document.createComment(content)
                }, compile
            }]
        }

        function SimpleChange(previous, current) {
            this.previousValue = previous, this.currentValue = current
        }

        function directiveNormalize(name) {
            return camelCase(name.replace(PREFIX_REGEXP, ""))
        }

        function tokenDifference(str1, str2) {
            var values = "", tokens1 = str1.split(/\s+/), tokens2 = str2.split(/\s+/);
            outer:for (var i = 0; i < tokens1.length; i++) {
                for (var token = tokens1[i], j = 0; j < tokens2.length; j++)if (token == tokens2[j])continue outer;
                values += (values.length > 0 ? " " : "") + token
            }
            return values
        }

        function removeComments(jqNodes) {
            jqNodes = jqLite(jqNodes);
            var i = jqNodes.length;
            if (1 >= i)return jqNodes;
            for (; i--;) {
                var node = jqNodes[i];
                node.nodeType === NODE_TYPE_COMMENT && splice.call(jqNodes, i, 1)
            }
            return jqNodes
        }

        function identifierForController(controller, ident) {
            if (ident && isString(ident))return ident;
            if (isString(controller)) {
                var match = CNTRL_REG.exec(controller);
                if (match)return match[3]
            }
        }

        function $ControllerProvider() {
            var controllers = {}, globals = !1;
            this.has = function (name) {
                return controllers.hasOwnProperty(name)
            }, this.register = function (name, constructor) {
                assertNotHasOwnProperty(name, "controller"), isObject(name) ? extend(controllers, name) : controllers[name] = constructor
            }, this.allowGlobals = function () {
                globals = !0
            }, this.$get = ["$injector", "$window", function ($injector, $window) {
                function addIdentifier(locals, identifier, instance, name) {
                    if (!locals || !isObject(locals.$scope))throw minErr("$controller")("noscp", "Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.", name, identifier);
                    locals.$scope[identifier] = instance
                }

                return function (expression, locals, later, ident) {
                    var instance, match, constructor, identifier;
                    if (later = later === !0, ident && isString(ident) && (identifier = ident), isString(expression)) {
                        if (match = expression.match(CNTRL_REG), !match)throw $controllerMinErr("ctrlfmt", "Badly formed controller string '{0}'. Must match `__name__ as __id__` or `__name__`.", expression);
                        constructor = match[1], identifier = identifier || match[3], expression = controllers.hasOwnProperty(constructor) ? controllers[constructor] : getter(locals.$scope, constructor, !0) || (globals ? getter($window, constructor, !0) : void 0), assertArgFn(expression, constructor, !0)
                    }
                    if (later) {
                        var controllerPrototype = (isArray(expression) ? expression[expression.length - 1] : expression).prototype;
                        instance = Object.create(controllerPrototype || null), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name);
                        var instantiate;
                        return instantiate = extend(function () {
                            var result = $injector.invoke(expression, instance, locals, constructor);
                            return result !== instance && (isObject(result) || isFunction(result)) && (instance = result, identifier && addIdentifier(locals, identifier, instance, constructor || expression.name)), instance
                        }, {instance: instance, identifier: identifier})
                    }
                    return instance = $injector.instantiate(expression, locals, constructor), identifier && addIdentifier(locals, identifier, instance, constructor || expression.name), instance
                }
            }]
        }

        function $DocumentProvider() {
            this.$get = ["$window", function (window) {
                return jqLite(window.document)
            }]
        }

        function $ExceptionHandlerProvider() {
            this.$get = ["$log", function ($log) {
                return function (exception, cause) {
                    $log.error.apply($log, arguments)
                }
            }]
        }

        function serializeValue(v) {
            return isObject(v) ? isDate(v) ? v.toISOString() : toJson(v) : v
        }

        function $HttpParamSerializerProvider() {
            this.$get = function () {
                return function (params) {
                    if (!params)return "";
                    var parts = [];
                    return forEachSorted(params, function (value, key) {
                        null === value || isUndefined(value) || (isArray(value) ? forEach(value, function (v) {
                                parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(v)))
                            }) : parts.push(encodeUriQuery(key) + "=" + encodeUriQuery(serializeValue(value))))
                    }), parts.join("&")
                }
            }
        }

        function $HttpParamSerializerJQLikeProvider() {
            this.$get = function () {
                return function (params) {
                    function serialize(toSerialize, prefix, topLevel) {
                        null === toSerialize || isUndefined(toSerialize) || (isArray(toSerialize) ? forEach(toSerialize, function (value, index) {
                                serialize(value, prefix + "[" + (isObject(value) ? index : "") + "]")
                            }) : isObject(toSerialize) && !isDate(toSerialize) ? forEachSorted(toSerialize, function (value, key) {
                                    serialize(value, prefix + (topLevel ? "" : "[") + key + (topLevel ? "" : "]"))
                                }) : parts.push(encodeUriQuery(prefix) + "=" + encodeUriQuery(serializeValue(toSerialize))))
                    }

                    if (!params)return "";
                    var parts = [];
                    return serialize(params, "", !0), parts.join("&")
                }
            }
        }

        function defaultHttpResponseTransform(data, headers) {
            if (isString(data)) {
                var tempData = data.replace(JSON_PROTECTION_PREFIX, "").trim();
                if (tempData) {
                    var contentType = headers("Content-Type");
                    (contentType && 0 === contentType.indexOf(APPLICATION_JSON) || isJsonLike(tempData)) && (data = fromJson(tempData))
                }
            }
            return data
        }

        function isJsonLike(str) {
            var jsonStart = str.match(JSON_START);
            return jsonStart && JSON_ENDS[jsonStart[0]].test(str)
        }

        function parseHeaders(headers) {
            function fillInParsed(key, val) {
                key && (parsed[key] = parsed[key] ? parsed[key] + ", " + val : val)
            }

            var i, parsed = createMap();
            return isString(headers) ? forEach(headers.split("\n"), function (line) {
                    i = line.indexOf(":"), fillInParsed(lowercase(trim(line.substr(0, i))), trim(line.substr(i + 1)))
                }) : isObject(headers) && forEach(headers, function (headerVal, headerKey) {
                    fillInParsed(lowercase(headerKey), trim(headerVal))
                }), parsed
        }

        function headersGetter(headers) {
            var headersObj;
            return function (name) {
                if (headersObj || (headersObj = parseHeaders(headers)), name) {
                    var value = headersObj[lowercase(name)];
                    return void 0 === value && (value = null), value
                }
                return headersObj
            }
        }

        function transformData(data, headers, status, fns) {
            return isFunction(fns) ? fns(data, headers, status) : (forEach(fns, function (fn) {
                    data = fn(data, headers, status)
                }), data)
        }

        function isSuccess(status) {
            return status >= 200 && 300 > status
        }

        function $HttpProvider() {
            var defaults = this.defaults = {
                transformResponse: [defaultHttpResponseTransform],
                transformRequest: [function (d) {
                    return !isObject(d) || isFile(d) || isBlob(d) || isFormData(d) ? d : toJson(d)
                }],
                headers: {
                    common: {Accept: "application/json, text/plain, */*"},
                    post: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                    put: shallowCopy(CONTENT_TYPE_APPLICATION_JSON),
                    patch: shallowCopy(CONTENT_TYPE_APPLICATION_JSON)
                },
                xsrfCookieName: "XSRF-TOKEN",
                xsrfHeaderName: "X-XSRF-TOKEN",
                paramSerializer: "$httpParamSerializer"
            }, useApplyAsync = !1;
            this.useApplyAsync = function (value) {
                return isDefined(value) ? (useApplyAsync = !!value, this) : useApplyAsync
            };
            var useLegacyPromise = !0;
            this.useLegacyPromiseExtensions = function (value) {
                return isDefined(value) ? (useLegacyPromise = !!value, this) : useLegacyPromise
            };
            var interceptorFactories = this.interceptors = [];
            this.$get = ["$httpBackend", "$$cookieReader", "$cacheFactory", "$rootScope", "$q", "$injector", function ($httpBackend, $$cookieReader, $cacheFactory, $rootScope, $q, $injector) {
                function $http(requestConfig) {
                    function chainInterceptors(promise, interceptors) {
                        for (var i = 0, ii = interceptors.length; ii > i;) {
                            var thenFn = interceptors[i++], rejectFn = interceptors[i++];
                            promise = promise.then(thenFn, rejectFn)
                        }
                        return interceptors.length = 0, promise
                    }

                    function executeHeaderFns(headers, config) {
                        var headerContent, processedHeaders = {};
                        return forEach(headers, function (headerFn, header) {
                            isFunction(headerFn) ? (headerContent = headerFn(config), null != headerContent && (processedHeaders[header] = headerContent)) : processedHeaders[header] = headerFn
                        }), processedHeaders
                    }

                    function mergeHeaders(config) {
                        var defHeaderName, lowercaseDefHeaderName, reqHeaderName, defHeaders = defaults.headers, reqHeaders = extend({}, config.headers);
                        defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);
                        defaultHeadersIteration:for (defHeaderName in defHeaders) {
                            lowercaseDefHeaderName = lowercase(defHeaderName);
                            for (reqHeaderName in reqHeaders)if (lowercase(reqHeaderName) === lowercaseDefHeaderName)continue defaultHeadersIteration;
                            reqHeaders[defHeaderName] = defHeaders[defHeaderName]
                        }
                        return executeHeaderFns(reqHeaders, shallowCopy(config))
                    }

                    function serverRequest(config) {
                        var headers = config.headers, reqData = transformData(config.data, headersGetter(headers), void 0, config.transformRequest);
                        return isUndefined(reqData) && forEach(headers, function (value, header) {
                            "content-type" === lowercase(header) && delete headers[header]
                        }), isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials) && (config.withCredentials = defaults.withCredentials), sendReq(config, reqData).then(transformResponse, transformResponse)
                    }

                    function transformResponse(response) {
                        var resp = extend({}, response);
                        return resp.data = transformData(response.data, response.headers, response.status, config.transformResponse), isSuccess(response.status) ? resp : $q.reject(resp)
                    }

                    if (!isObject(requestConfig))throw minErr("$http")("badreq", "Http request configuration must be an object.  Received: {0}", requestConfig);
                    if (!isString(requestConfig.url))throw minErr("$http")("badreq", "Http request configuration url must be a string.  Received: {0}", requestConfig.url);
                    var config = extend({
                        method: "get",
                        transformRequest: defaults.transformRequest,
                        transformResponse: defaults.transformResponse,
                        paramSerializer: defaults.paramSerializer
                    }, requestConfig);
                    config.headers = mergeHeaders(requestConfig), config.method = uppercase(config.method), config.paramSerializer = isString(config.paramSerializer) ? $injector.get(config.paramSerializer) : config.paramSerializer;
                    var requestInterceptors = [], responseInterceptors = [], promise = $q.when(config);
                    return forEach(reversedInterceptors, function (interceptor) {
                        (interceptor.request || interceptor.requestError) && requestInterceptors.unshift(interceptor.request, interceptor.requestError), (interceptor.response || interceptor.responseError) && responseInterceptors.push(interceptor.response, interceptor.responseError)
                    }), promise = chainInterceptors(promise, requestInterceptors), promise = promise.then(serverRequest), promise = chainInterceptors(promise, responseInterceptors), useLegacyPromise ? (promise.success = function (fn) {
                            return assertArgFn(fn, "fn"), promise.then(function (response) {
                                fn(response.data, response.status, response.headers, config)
                            }), promise
                        }, promise.error = function (fn) {
                            return assertArgFn(fn, "fn"), promise.then(null, function (response) {
                                fn(response.data, response.status, response.headers, config)
                            }), promise
                        }) : (promise.success = $httpMinErrLegacyFn("success"), promise.error = $httpMinErrLegacyFn("error")), promise
                }

                function createShortMethods(names) {
                    forEach(arguments, function (name) {
                        $http[name] = function (url, config) {
                            return $http(extend({}, config || {}, {method: name, url: url}))
                        }
                    })
                }

                function createShortMethodsWithData(name) {
                    forEach(arguments, function (name) {
                        $http[name] = function (url, data, config) {
                            return $http(extend({}, config || {}, {method: name, url: url, data: data}))
                        }
                    })
                }

                function sendReq(config, reqData) {
                    function createApplyHandlers(eventHandlers) {
                        if (eventHandlers) {
                            var applyHandlers = {};
                            return forEach(eventHandlers, function (eventHandler, key) {
                                applyHandlers[key] = function (event) {
                                    function callEventHandler() {
                                        eventHandler(event)
                                    }

                                    useApplyAsync ? $rootScope.$applyAsync(callEventHandler) : $rootScope.$$phase ? callEventHandler() : $rootScope.$apply(callEventHandler)
                                }
                            }), applyHandlers
                        }
                    }

                    function done(status, response, headersString, statusText) {
                        function resolveHttpPromise() {
                            resolvePromise(response, status, headersString, statusText)
                        }

                        cache && (isSuccess(status) ? cache.put(url, [status, response, parseHeaders(headersString), statusText]) : cache.remove(url)), useApplyAsync ? $rootScope.$applyAsync(resolveHttpPromise) : (resolveHttpPromise(), $rootScope.$$phase || $rootScope.$apply())
                    }

                    function resolvePromise(response, status, headers, statusText) {
                        status = status >= -1 ? status : 0, (isSuccess(status) ? deferred.resolve : deferred.reject)({
                            data: response,
                            status: status,
                            headers: headersGetter(headers),
                            config: config,
                            statusText: statusText
                        })
                    }

                    function resolvePromiseWithResult(result) {
                        resolvePromise(result.data, result.status, shallowCopy(result.headers()), result.statusText)
                    }

                    function removePendingReq() {
                        var idx = $http.pendingRequests.indexOf(config);
                        -1 !== idx && $http.pendingRequests.splice(idx, 1)
                    }

                    var cache, cachedResp, deferred = $q.defer(), promise = deferred.promise, reqHeaders = config.headers, url = buildUrl(config.url, config.paramSerializer(config.params));
                    if ($http.pendingRequests.push(config), promise.then(removePendingReq, removePendingReq), !config.cache && !defaults.cache || config.cache === !1 || "GET" !== config.method && "JSONP" !== config.method || (cache = isObject(config.cache) ? config.cache : isObject(defaults.cache) ? defaults.cache : defaultCache), cache && (cachedResp = cache.get(url), isDefined(cachedResp) ? isPromiseLike(cachedResp) ? cachedResp.then(resolvePromiseWithResult, resolvePromiseWithResult) : isArray(cachedResp) ? resolvePromise(cachedResp[1], cachedResp[0], shallowCopy(cachedResp[2]), cachedResp[3]) : resolvePromise(cachedResp, 200, {}, "OK") : cache.put(url, promise)), isUndefined(cachedResp)) {
                        var xsrfValue = urlIsSameOrigin(config.url) ? $$cookieReader()[config.xsrfCookieName || defaults.xsrfCookieName] : void 0;
                        xsrfValue && (reqHeaders[config.xsrfHeaderName || defaults.xsrfHeaderName] = xsrfValue), $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout, config.withCredentials, config.responseType, createApplyHandlers(config.eventHandlers), createApplyHandlers(config.uploadEventHandlers))
                    }
                    return promise
                }

                function buildUrl(url, serializedParams) {
                    return serializedParams.length > 0 && (url += (-1 == url.indexOf("?") ? "?" : "&") + serializedParams), url
                }

                var defaultCache = $cacheFactory("$http");
                defaults.paramSerializer = isString(defaults.paramSerializer) ? $injector.get(defaults.paramSerializer) : defaults.paramSerializer;
                var reversedInterceptors = [];
                return forEach(interceptorFactories, function (interceptorFactory) {
                    reversedInterceptors.unshift(isString(interceptorFactory) ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory))
                }), $http.pendingRequests = [], createShortMethods("get", "delete", "head", "jsonp"), createShortMethodsWithData("post", "put", "patch"), $http.defaults = defaults, $http
            }]
        }

        function $xhrFactoryProvider() {
            this.$get = function () {
                return function () {
                    return new window.XMLHttpRequest
                }
            }
        }

        function $HttpBackendProvider() {
            this.$get = ["$browser", "$jsonpCallbacks", "$document", "$xhrFactory", function ($browser, $jsonpCallbacks, $document, $xhrFactory) {
                return createHttpBackend($browser, $xhrFactory, $browser.defer, $jsonpCallbacks, $document[0])
            }]
        }

        function createHttpBackend($browser, createXhr, $browserDefer, callbacks, rawDocument) {
            function jsonpReq(url, callbackPath, done) {
                url = url.replace("JSON_CALLBACK", callbackPath);
                var script = rawDocument.createElement("script"), callback = null;
                return script.type = "text/javascript", script.src = url, script.async = !0, callback = function (event) {
                    removeEventListenerFn(script, "load", callback), removeEventListenerFn(script, "error", callback), rawDocument.body.removeChild(script), script = null;
                    var status = -1, text = "unknown";
                    event && ("load" !== event.type || callbacks.wasCalled(callbackPath) || (event = {type: "error"}), text = event.type, status = "error" === event.type ? 404 : 200), done && done(status, text)
                }, addEventListenerFn(script, "load", callback), addEventListenerFn(script, "error", callback), rawDocument.body.appendChild(script), callback
            }

            return function (method, url, post, callback, headers, timeout, withCredentials, responseType, eventHandlers, uploadEventHandlers) {
                function timeoutRequest() {
                    jsonpDone && jsonpDone(), xhr && xhr.abort()
                }

                function completeRequest(callback, status, response, headersString, statusText) {
                    isDefined(timeoutId) && $browserDefer.cancel(timeoutId), jsonpDone = xhr = null, callback(status, response, headersString, statusText), $browser.$$completeOutstandingRequest(noop)
                }

                if ($browser.$$incOutstandingRequestCount(), url = url || $browser.url(), "jsonp" === lowercase(method))var callbackPath = callbacks.createCallback(url), jsonpDone = jsonpReq(url, callbackPath, function (status, text) {
                    var response = 200 === status && callbacks.getResponse(callbackPath);
                    completeRequest(callback, status, response, "", text), callbacks.removeCallback(callbackPath)
                }); else {
                    var xhr = createXhr(method, url);
                    xhr.open(method, url, !0), forEach(headers, function (value, key) {
                        isDefined(value) && xhr.setRequestHeader(key, value)
                    }), xhr.onload = function () {
                        var statusText = xhr.statusText || "", response = "response" in xhr ? xhr.response : xhr.responseText, status = 1223 === xhr.status ? 204 : xhr.status;
                        0 === status && (status = response ? 200 : "file" == urlResolve(url).protocol ? 404 : 0), completeRequest(callback, status, response, xhr.getAllResponseHeaders(), statusText)
                    };
                    var requestError = function () {
                        completeRequest(callback, -1, null, null, "")
                    };
                    if (xhr.onerror = requestError, xhr.onabort = requestError, forEach(eventHandlers, function (value, key) {
                            xhr.addEventListener(key, value)
                        }), forEach(uploadEventHandlers, function (value, key) {
                            xhr.upload.addEventListener(key, value)
                        }), withCredentials && (xhr.withCredentials = !0), responseType)try {
                        xhr.responseType = responseType
                    } catch (e) {
                        if ("json" !== responseType)throw e
                    }
                    xhr.send(isUndefined(post) ? null : post)
                }
                if (timeout > 0)var timeoutId = $browserDefer(timeoutRequest, timeout); else isPromiseLike(timeout) && timeout.then(timeoutRequest)
            }
        }

        function $InterpolateProvider() {
            var startSymbol = "{{", endSymbol = "}}";
            this.startSymbol = function (value) {
                return value ? (startSymbol = value, this) : startSymbol
            }, this.endSymbol = function (value) {
                return value ? (endSymbol = value, this) : endSymbol
            }, this.$get = ["$parse", "$exceptionHandler", "$sce", function ($parse, $exceptionHandler, $sce) {
                function escape(ch) {
                    return "\\\\\\" + ch
                }

                function unescapeText(text) {
                    return text.replace(escapedStartRegexp, startSymbol).replace(escapedEndRegexp, endSymbol)
                }

                function stringify(value) {
                    if (null == value)return "";
                    switch (typeof value) {
                        case"string":
                            break;
                        case"number":
                            value = "" + value;
                            break;
                        default:
                            value = toJson(value)
                    }
                    return value
                }

                function constantWatchDelegate(scope, listener, objectEquality, constantInterp) {
                    var unwatch;
                    return unwatch = scope.$watch(function (scope) {
                        return unwatch(), constantInterp(scope)
                    }, listener, objectEquality)
                }

                function $interpolate(text, mustHaveExpression, trustedContext, allOrNothing) {
                    function parseStringifyInterceptor(value) {
                        try {
                            return value = getValue(value), allOrNothing && !isDefined(value) ? value : stringify(value)
                        } catch (err) {
                            $exceptionHandler($interpolateMinErr.interr(text, err))
                        }
                    }

                    if (!text.length || -1 === text.indexOf(startSymbol)) {
                        var constantInterp;
                        if (!mustHaveExpression) {
                            var unescapedText = unescapeText(text);
                            constantInterp = valueFn(unescapedText), constantInterp.exp = text, constantInterp.expressions = [], constantInterp.$$watchDelegate = constantWatchDelegate
                        }
                        return constantInterp
                    }
                    allOrNothing = !!allOrNothing;
                    for (var startIndex, endIndex, exp, index = 0, expressions = [], parseFns = [], textLength = text.length, concat = [], expressionPositions = []; textLength > index;) {
                        if (-1 == (startIndex = text.indexOf(startSymbol, index)) || -1 == (endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength))) {
                            index !== textLength && concat.push(unescapeText(text.substring(index)));
                            break
                        }
                        index !== startIndex && concat.push(unescapeText(text.substring(index, startIndex))), exp = text.substring(startIndex + startSymbolLength, endIndex), expressions.push(exp), parseFns.push($parse(exp, parseStringifyInterceptor)), index = endIndex + endSymbolLength, expressionPositions.push(concat.length), concat.push("")
                    }
                    if (trustedContext && concat.length > 1 && $interpolateMinErr.throwNoconcat(text), !mustHaveExpression || expressions.length) {
                        var compute = function (values) {
                            for (var i = 0, ii = expressions.length; ii > i; i++) {
                                if (allOrNothing && isUndefined(values[i]))return;
                                concat[expressionPositions[i]] = values[i]
                            }
                            return concat.join("")
                        }, getValue = function (value) {
                            return trustedContext ? $sce.getTrusted(trustedContext, value) : $sce.valueOf(value)
                        };
                        return extend(function (context) {
                            var i = 0, ii = expressions.length, values = new Array(ii);
                            try {
                                for (; ii > i; i++)values[i] = parseFns[i](context);
                                return compute(values)
                            } catch (err) {
                                $exceptionHandler($interpolateMinErr.interr(text, err))
                            }
                        }, {
                            exp: text, expressions: expressions, $$watchDelegate: function (scope, listener) {
                                var lastValue;
                                return scope.$watchGroup(parseFns, function (values, oldValues) {
                                    var currValue = compute(values);
                                    isFunction(listener) && listener.call(this, currValue, values !== oldValues ? lastValue : currValue, scope), lastValue = currValue
                                })
                            }
                        })
                    }
                }

                var startSymbolLength = startSymbol.length, endSymbolLength = endSymbol.length, escapedStartRegexp = new RegExp(startSymbol.replace(/./g, escape), "g"), escapedEndRegexp = new RegExp(endSymbol.replace(/./g, escape), "g");
                return $interpolate.startSymbol = function () {
                    return startSymbol
                }, $interpolate.endSymbol = function () {
                    return endSymbol
                }, $interpolate
            }]
        }

        function $IntervalProvider() {
            this.$get = ["$rootScope", "$window", "$q", "$$q", "$browser", function ($rootScope, $window, $q, $$q, $browser) {
                function interval(fn, delay, count, invokeApply) {
                    function callback() {
                        hasParams ? fn.apply(null, args) : fn(iteration)
                    }

                    var hasParams = arguments.length > 4, args = hasParams ? sliceArgs(arguments, 4) : [], setInterval = $window.setInterval, clearInterval = $window.clearInterval, iteration = 0, skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                    return count = isDefined(count) ? count : 0, promise.$$intervalId = setInterval(function () {
                        skipApply ? $browser.defer(callback) : $rootScope.$evalAsync(callback), deferred.notify(iteration++), count > 0 && iteration >= count && (deferred.resolve(iteration), clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId]), skipApply || $rootScope.$apply()
                    }, delay), intervals[promise.$$intervalId] = deferred, promise
                }

                var intervals = {};
                return interval.cancel = function (promise) {
                    return promise && promise.$$intervalId in intervals ? (intervals[promise.$$intervalId].reject("canceled"), $window.clearInterval(promise.$$intervalId), delete intervals[promise.$$intervalId], !0) : !1
                }, interval
            }]
        }

        function encodePath(path) {
            for (var segments = path.split("/"), i = segments.length; i--;)segments[i] = encodeUriSegment(segments[i]);
            return segments.join("/")
        }

        function parseAbsoluteUrl(absoluteUrl, locationObj) {
            var parsedUrl = urlResolve(absoluteUrl);
            locationObj.$$protocol = parsedUrl.protocol, locationObj.$$host = parsedUrl.hostname, locationObj.$$port = toInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null
        }

        function parseAppUrl(relativeUrl, locationObj) {
            var prefixed = "/" !== relativeUrl.charAt(0);
            prefixed && (relativeUrl = "/" + relativeUrl);
            var match = urlResolve(relativeUrl);
            locationObj.$$path = decodeURIComponent(prefixed && "/" === match.pathname.charAt(0) ? match.pathname.substring(1) : match.pathname), locationObj.$$search = parseKeyValue(match.search), locationObj.$$hash = decodeURIComponent(match.hash), locationObj.$$path && "/" != locationObj.$$path.charAt(0) && (locationObj.$$path = "/" + locationObj.$$path)
        }

        function startsWith(haystack, needle) {
            return 0 === haystack.lastIndexOf(needle, 0)
        }

        function stripBaseUrl(base, url) {
            return startsWith(url, base) ? url.substr(base.length) : void 0
        }

        function stripHash(url) {
            var index = url.indexOf("#");
            return -1 == index ? url : url.substr(0, index)
        }

        function trimEmptyHash(url) {
            return url.replace(/(#.+)|#$/, "$1")
        }

        function stripFile(url) {
            return url.substr(0, stripHash(url).lastIndexOf("/") + 1)
        }

        function serverBase(url) {
            return url.substring(0, url.indexOf("/", url.indexOf("//") + 2))
        }

        function LocationHtml5Url(appBase, appBaseNoFile, basePrefix) {
            this.$$html5 = !0, basePrefix = basePrefix || "", parseAbsoluteUrl(appBase, this), this.$$parse = function (url) {
                var pathUrl = stripBaseUrl(appBaseNoFile, url);
                if (!isString(pathUrl))throw $locationMinErr("ipthprfx", 'Invalid url "{0}", missing path prefix "{1}".', url, appBaseNoFile);
                parseAppUrl(pathUrl, this), this.$$path || (this.$$path = "/"), this.$$compose()
            }, this.$$compose = function () {
                var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBaseNoFile + this.$$url.substr(1)
            }, this.$$parseLinkUrl = function (url, relHref) {
                if (relHref && "#" === relHref[0])return this.hash(relHref.slice(1)), !0;
                var appUrl, prevAppUrl, rewrittenUrl;
                return isDefined(appUrl = stripBaseUrl(appBase, url)) ? (prevAppUrl = appUrl, rewrittenUrl = isDefined(appUrl = stripBaseUrl(basePrefix, appUrl)) ? appBaseNoFile + (stripBaseUrl("/", appUrl) || appUrl) : appBase + prevAppUrl) : isDefined(appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBaseNoFile + appUrl : appBaseNoFile == url + "/" && (rewrittenUrl = appBaseNoFile), rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl
            }
        }

        function LocationHashbangUrl(appBase, appBaseNoFile, hashPrefix) {
            parseAbsoluteUrl(appBase, this), this.$$parse = function (url) {
                function removeWindowsDriveName(path, url, base) {
                    var firstPathSegmentMatch, windowsFilePathExp = /^\/[A-Z]:(\/.*)/;
                    return startsWith(url, base) && (url = url.replace(base, "")), windowsFilePathExp.exec(url) ? path : (firstPathSegmentMatch = windowsFilePathExp.exec(path), firstPathSegmentMatch ? firstPathSegmentMatch[1] : path)
                }

                var withoutHashUrl, withoutBaseUrl = stripBaseUrl(appBase, url) || stripBaseUrl(appBaseNoFile, url);
                isUndefined(withoutBaseUrl) || "#" !== withoutBaseUrl.charAt(0) ? this.$$html5 ? withoutHashUrl = withoutBaseUrl : (withoutHashUrl = "", isUndefined(withoutBaseUrl) && (appBase = url, this.replace())) : (withoutHashUrl = stripBaseUrl(hashPrefix, withoutBaseUrl), isUndefined(withoutHashUrl) && (withoutHashUrl = withoutBaseUrl)), parseAppUrl(withoutHashUrl, this), this.$$path = removeWindowsDriveName(this.$$path, withoutHashUrl, appBase), this.$$compose()
            }, this.$$compose = function () {
                var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : "")
            }, this.$$parseLinkUrl = function (url, relHref) {
                return stripHash(appBase) == stripHash(url) ? (this.$$parse(url), !0) : !1
            }
        }

        function LocationHashbangInHtml5Url(appBase, appBaseNoFile, hashPrefix) {
            this.$$html5 = !0, LocationHashbangUrl.apply(this, arguments), this.$$parseLinkUrl = function (url, relHref) {
                if (relHref && "#" === relHref[0])return this.hash(relHref.slice(1)), !0;
                var rewrittenUrl, appUrl;
                return appBase == stripHash(url) ? rewrittenUrl = url : (appUrl = stripBaseUrl(appBaseNoFile, url)) ? rewrittenUrl = appBase + hashPrefix + appUrl : appBaseNoFile === url + "/" && (rewrittenUrl = appBaseNoFile), rewrittenUrl && this.$$parse(rewrittenUrl), !!rewrittenUrl
            }, this.$$compose = function () {
                var search = toKeyValue(this.$$search), hash = this.$$hash ? "#" + encodeUriSegment(this.$$hash) : "";
                this.$$url = encodePath(this.$$path) + (search ? "?" + search : "") + hash, this.$$absUrl = appBase + hashPrefix + this.$$url
            }
        }

        function locationGetter(property) {
            return function () {
                return this[property]
            }
        }

        function locationGetterSetter(property, preprocess) {
            return function (value) {
                return isUndefined(value) ? this[property] : (this[property] = preprocess(value), this.$$compose(), this)
            }
        }

        function $LocationProvider() {
            var hashPrefix = "", html5Mode = {enabled: !1, requireBase: !0, rewriteLinks: !0};
            this.hashPrefix = function (prefix) {
                return isDefined(prefix) ? (hashPrefix = prefix, this) : hashPrefix
            }, this.html5Mode = function (mode) {
                return isBoolean(mode) ? (html5Mode.enabled = mode, this) : isObject(mode) ? (isBoolean(mode.enabled) && (html5Mode.enabled = mode.enabled), isBoolean(mode.requireBase) && (html5Mode.requireBase = mode.requireBase), isBoolean(mode.rewriteLinks) && (html5Mode.rewriteLinks = mode.rewriteLinks), this) : html5Mode
            }, this.$get = ["$rootScope", "$browser", "$sniffer", "$rootElement", "$window", function ($rootScope, $browser, $sniffer, $rootElement, $window) {
                function setBrowserUrlWithFallback(url, replace, state) {
                    var oldUrl = $location.url(), oldState = $location.$$state;
                    try {
                        $browser.url(url, replace, state), $location.$$state = $browser.state()
                    } catch (e) {
                        throw $location.url(oldUrl), $location.$$state = oldState, e
                    }
                }

                function afterLocationChange(oldUrl, oldState) {
                    $rootScope.$broadcast("$locationChangeSuccess", $location.absUrl(), oldUrl, $location.$$state, oldState)
                }

                var $location, LocationMode, appBase, baseHref = $browser.baseHref(), initialUrl = $browser.url();
                if (html5Mode.enabled) {
                    if (!baseHref && html5Mode.requireBase)throw $locationMinErr("nobase", "$location in HTML5 mode requires a <base> tag to be present!");
                    appBase = serverBase(initialUrl) + (baseHref || "/"), LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url
                } else appBase = stripHash(initialUrl), LocationMode = LocationHashbangUrl;
                var appBaseNoFile = stripFile(appBase);
                $location = new LocationMode(appBase, appBaseNoFile, "#" + hashPrefix), $location.$$parseLinkUrl(initialUrl, initialUrl), $location.$$state = $browser.state();
                var IGNORE_URI_REGEXP = /^\s*(javascript|mailto):/i;
                $rootElement.on("click", function (event) {
                    if (html5Mode.rewriteLinks && !event.ctrlKey && !event.metaKey && !event.shiftKey && 2 != event.which && 2 != event.button) {
                        for (var elm = jqLite(event.target); "a" !== nodeName_(elm[0]);)if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0])return;
                        var absHref = elm.prop("href"), relHref = elm.attr("href") || elm.attr("xlink:href");
                        isObject(absHref) && "[object SVGAnimatedString]" === absHref.toString() && (absHref = urlResolve(absHref.animVal).href), IGNORE_URI_REGEXP.test(absHref) || !absHref || elm.attr("target") || event.isDefaultPrevented() || $location.$$parseLinkUrl(absHref, relHref) && (event.preventDefault(), $location.absUrl() != $browser.url() && ($rootScope.$apply(), $window.angular["ff-684208-preventDefault"] = !0))
                    }
                }), trimEmptyHash($location.absUrl()) != trimEmptyHash(initialUrl) && $browser.url($location.absUrl(), !0);
                var initializing = !0;
                return $browser.onUrlChange(function (newUrl, newState) {
                    return isUndefined(stripBaseUrl(appBaseNoFile, newUrl)) ? void($window.location.href = newUrl) : ($rootScope.$evalAsync(function () {
                            var defaultPrevented, oldUrl = $location.absUrl(), oldState = $location.$$state;
                            newUrl = trimEmptyHash(newUrl), $location.$$parse(newUrl), $location.$$state = newState, defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, newState, oldState).defaultPrevented, $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), $location.$$state = oldState, setBrowserUrlWithFallback(oldUrl, !1, oldState)) : (initializing = !1, afterLocationChange(oldUrl, oldState)))
                        }), void($rootScope.$$phase || $rootScope.$digest()))
                }), $rootScope.$watch(function () {
                    var oldUrl = trimEmptyHash($browser.url()), newUrl = trimEmptyHash($location.absUrl()), oldState = $browser.state(), currentReplace = $location.$$replace, urlOrStateChanged = oldUrl !== newUrl || $location.$$html5 && $sniffer.history && oldState !== $location.$$state;
                    (initializing || urlOrStateChanged) && (initializing = !1, $rootScope.$evalAsync(function () {
                        var newUrl = $location.absUrl(), defaultPrevented = $rootScope.$broadcast("$locationChangeStart", newUrl, oldUrl, $location.$$state, oldState).defaultPrevented;
                        $location.absUrl() === newUrl && (defaultPrevented ? ($location.$$parse(oldUrl), $location.$$state = oldState) : (urlOrStateChanged && setBrowserUrlWithFallback(newUrl, currentReplace, oldState === $location.$$state ? null : $location.$$state),
                                afterLocationChange(oldUrl, oldState)))
                    })), $location.$$replace = !1
                }), $location
            }]
        }

        function $LogProvider() {
            var debug = !0, self = this;
            this.debugEnabled = function (flag) {
                return isDefined(flag) ? (debug = flag, this) : debug
            }, this.$get = ["$window", function ($window) {
                function formatError(arg) {
                    return arg instanceof Error && (arg.stack ? arg = arg.message && -1 === arg.stack.indexOf(arg.message) ? "Error: " + arg.message + "\n" + arg.stack : arg.stack : arg.sourceURL && (arg = arg.message + "\n" + arg.sourceURL + ":" + arg.line)), arg
                }

                function consoleLog(type) {
                    var console = $window.console || {}, logFn = console[type] || console.log || noop, hasApply = !1;
                    try {
                        hasApply = !!logFn.apply
                    } catch (e) {
                    }
                    return hasApply ? function () {
                            var args = [];
                            return forEach(arguments, function (arg) {
                                args.push(formatError(arg))
                            }), logFn.apply(console, args)
                        } : function (arg1, arg2) {
                            logFn(arg1, null == arg2 ? "" : arg2)
                        }
                }

                return {
                    log: consoleLog("log"),
                    info: consoleLog("info"),
                    warn: consoleLog("warn"),
                    error: consoleLog("error"),
                    debug: function () {
                        var fn = consoleLog("debug");
                        return function () {
                            debug && fn.apply(self, arguments)
                        }
                    }()
                }
            }]
        }

        function ensureSafeMemberName(name, fullExpression) {
            if ("__defineGetter__" === name || "__defineSetter__" === name || "__lookupGetter__" === name || "__lookupSetter__" === name || "__proto__" === name)throw $parseMinErr("isecfld", "Attempting to access a disallowed field in Angular expressions! Expression: {0}", fullExpression);
            return name
        }

        function getStringValue(name) {
            return name + ""
        }

        function ensureSafeObject(obj, fullExpression) {
            if (obj) {
                if (obj.constructor === obj)throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
                if (obj.window === obj)throw $parseMinErr("isecwindow", "Referencing the Window in Angular expressions is disallowed! Expression: {0}", fullExpression);
                if (obj.children && (obj.nodeName || obj.prop && obj.attr && obj.find))throw $parseMinErr("isecdom", "Referencing DOM nodes in Angular expressions is disallowed! Expression: {0}", fullExpression);
                if (obj === Object)throw $parseMinErr("isecobj", "Referencing Object in Angular expressions is disallowed! Expression: {0}", fullExpression)
            }
            return obj
        }

        function ensureSafeFunction(obj, fullExpression) {
            if (obj) {
                if (obj.constructor === obj)throw $parseMinErr("isecfn", "Referencing Function in Angular expressions is disallowed! Expression: {0}", fullExpression);
                if (obj === CALL || obj === APPLY || obj === BIND)throw $parseMinErr("isecff", "Referencing call, apply or bind in Angular expressions is disallowed! Expression: {0}", fullExpression)
            }
        }

        function ensureSafeAssignContext(obj, fullExpression) {
            if (obj && (obj === 0..constructor || obj === (!1).constructor || obj === "".constructor || obj === {}.constructor || obj === [].constructor || obj === Function.constructor))throw $parseMinErr("isecaf", "Assigning to a constructor is disallowed! Expression: {0}", fullExpression)
        }

        function ifDefined(v, d) {
            return "undefined" != typeof v ? v : d
        }

        function plusFn(l, r) {
            return "undefined" == typeof l ? r : "undefined" == typeof r ? l : l + r
        }

        function isStateless($filter, filterName) {
            var fn = $filter(filterName);
            return !fn.$stateful
        }

        function findConstantAndWatchExpressions(ast, $filter) {
            var allConstants, argsToWatch;
            switch (ast.type) {
                case AST.Program:
                    allConstants = !0, forEach(ast.body, function (expr) {
                        findConstantAndWatchExpressions(expr.expression, $filter), allConstants = allConstants && expr.expression.constant
                    }), ast.constant = allConstants;
                    break;
                case AST.Literal:
                    ast.constant = !0, ast.toWatch = [];
                    break;
                case AST.UnaryExpression:
                    findConstantAndWatchExpressions(ast.argument, $filter), ast.constant = ast.argument.constant, ast.toWatch = ast.argument.toWatch;
                    break;
                case AST.BinaryExpression:
                    findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.left.toWatch.concat(ast.right.toWatch);
                    break;
                case AST.LogicalExpression:
                    findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = ast.constant ? [] : [ast];
                    break;
                case AST.ConditionalExpression:
                    findConstantAndWatchExpressions(ast.test, $filter), findConstantAndWatchExpressions(ast.alternate, $filter), findConstantAndWatchExpressions(ast.consequent, $filter), ast.constant = ast.test.constant && ast.alternate.constant && ast.consequent.constant, ast.toWatch = ast.constant ? [] : [ast];
                    break;
                case AST.Identifier:
                    ast.constant = !1, ast.toWatch = [ast];
                    break;
                case AST.MemberExpression:
                    findConstantAndWatchExpressions(ast.object, $filter), ast.computed && findConstantAndWatchExpressions(ast.property, $filter), ast.constant = ast.object.constant && (!ast.computed || ast.property.constant), ast.toWatch = [ast];
                    break;
                case AST.CallExpression:
                    allConstants = ast.filter ? isStateless($filter, ast.callee.name) : !1, argsToWatch = [], forEach(ast.arguments, function (expr) {
                        findConstantAndWatchExpressions(expr, $filter), allConstants = allConstants && expr.constant, expr.constant || argsToWatch.push.apply(argsToWatch, expr.toWatch)
                    }), ast.constant = allConstants, ast.toWatch = ast.filter && isStateless($filter, ast.callee.name) ? argsToWatch : [ast];
                    break;
                case AST.AssignmentExpression:
                    findConstantAndWatchExpressions(ast.left, $filter), findConstantAndWatchExpressions(ast.right, $filter), ast.constant = ast.left.constant && ast.right.constant, ast.toWatch = [ast];
                    break;
                case AST.ArrayExpression:
                    allConstants = !0, argsToWatch = [], forEach(ast.elements, function (expr) {
                        findConstantAndWatchExpressions(expr, $filter), allConstants = allConstants && expr.constant, expr.constant || argsToWatch.push.apply(argsToWatch, expr.toWatch)
                    }), ast.constant = allConstants, ast.toWatch = argsToWatch;
                    break;
                case AST.ObjectExpression:
                    allConstants = !0, argsToWatch = [], forEach(ast.properties, function (property) {
                        findConstantAndWatchExpressions(property.value, $filter), allConstants = allConstants && property.value.constant && !property.computed, property.value.constant || argsToWatch.push.apply(argsToWatch, property.value.toWatch)
                    }), ast.constant = allConstants, ast.toWatch = argsToWatch;
                    break;
                case AST.ThisExpression:
                    ast.constant = !1, ast.toWatch = [];
                    break;
                case AST.LocalsExpression:
                    ast.constant = !1, ast.toWatch = []
            }
        }

        function getInputs(body) {
            if (1 == body.length) {
                var lastExpression = body[0].expression, candidate = lastExpression.toWatch;
                return 1 !== candidate.length ? candidate : candidate[0] !== lastExpression ? candidate : void 0
            }
        }

        function isAssignable(ast) {
            return ast.type === AST.Identifier || ast.type === AST.MemberExpression
        }

        function assignableAST(ast) {
            return 1 === ast.body.length && isAssignable(ast.body[0].expression) ? {
                    type: AST.AssignmentExpression,
                    left: ast.body[0].expression,
                    right: {type: AST.NGValueParameter},
                    operator: "="
                } : void 0
        }

        function isLiteral(ast) {
            return 0 === ast.body.length || 1 === ast.body.length && (ast.body[0].expression.type === AST.Literal || ast.body[0].expression.type === AST.ArrayExpression || ast.body[0].expression.type === AST.ObjectExpression)
        }

        function isConstant(ast) {
            return ast.constant
        }

        function ASTCompiler(astBuilder, $filter) {
            this.astBuilder = astBuilder, this.$filter = $filter
        }

        function ASTInterpreter(astBuilder, $filter) {
            this.astBuilder = astBuilder, this.$filter = $filter
        }

        function isPossiblyDangerousMemberName(name) {
            return "constructor" == name
        }

        function getValueOf(value) {
            return isFunction(value.valueOf) ? value.valueOf() : objectValueOf.call(value)
        }

        function $ParseProvider() {
            var identStart, identContinue, cacheDefault = createMap(), cacheExpensive = createMap(), literals = {
                "true": !0,
                "false": !1,
                "null": null,
                undefined: void 0
            };
            this.addLiteral = function (literalName, literalValue) {
                literals[literalName] = literalValue
            }, this.setIdentifierFns = function (identifierStart, identifierContinue) {
                return identStart = identifierStart, identContinue = identifierContinue, this
            }, this.$get = ["$filter", function ($filter) {
                function $parse(exp, interceptorFn, expensiveChecks) {
                    var parsedExpression, oneTime, cacheKey;
                    switch (expensiveChecks = expensiveChecks || runningChecksEnabled, typeof exp) {
                        case"string":
                            exp = exp.trim(), cacheKey = exp;
                            var cache = expensiveChecks ? cacheExpensive : cacheDefault;
                            if (parsedExpression = cache[cacheKey], !parsedExpression) {
                                ":" === exp.charAt(0) && ":" === exp.charAt(1) && (oneTime = !0, exp = exp.substring(2));
                                var parseOptions = expensiveChecks ? $parseOptionsExpensive : $parseOptions, lexer = new Lexer(parseOptions), parser = new Parser(lexer, $filter, parseOptions);
                                parsedExpression = parser.parse(exp), parsedExpression.constant ? parsedExpression.$$watchDelegate = constantWatchDelegate : oneTime ? parsedExpression.$$watchDelegate = parsedExpression.literal ? oneTimeLiteralWatchDelegate : oneTimeWatchDelegate : parsedExpression.inputs && (parsedExpression.$$watchDelegate = inputsWatchDelegate), expensiveChecks && (parsedExpression = expensiveChecksInterceptor(parsedExpression)), cache[cacheKey] = parsedExpression
                            }
                            return addInterceptor(parsedExpression, interceptorFn);
                        case"function":
                            return addInterceptor(exp, interceptorFn);
                        default:
                            return addInterceptor(noop, interceptorFn)
                    }
                }

                function expensiveChecksInterceptor(fn) {
                    function expensiveCheckFn(scope, locals, assign, inputs) {
                        var expensiveCheckOldValue = runningChecksEnabled;
                        runningChecksEnabled = !0;
                        try {
                            return fn(scope, locals, assign, inputs)
                        } finally {
                            runningChecksEnabled = expensiveCheckOldValue
                        }
                    }

                    if (!fn)return fn;
                    expensiveCheckFn.$$watchDelegate = fn.$$watchDelegate, expensiveCheckFn.assign = expensiveChecksInterceptor(fn.assign), expensiveCheckFn.constant = fn.constant, expensiveCheckFn.literal = fn.literal;
                    for (var i = 0; fn.inputs && i < fn.inputs.length; ++i)fn.inputs[i] = expensiveChecksInterceptor(fn.inputs[i]);
                    return expensiveCheckFn.inputs = fn.inputs, expensiveCheckFn
                }

                function expressionInputDirtyCheck(newValue, oldValueOfValue) {
                    return null == newValue || null == oldValueOfValue ? newValue === oldValueOfValue : "object" == typeof newValue && (newValue = getValueOf(newValue), "object" == typeof newValue) ? !1 : newValue === oldValueOfValue || newValue !== newValue && oldValueOfValue !== oldValueOfValue
                }

                function inputsWatchDelegate(scope, listener, objectEquality, parsedExpression, prettyPrintExpression) {
                    var lastResult, inputExpressions = parsedExpression.inputs;
                    if (1 === inputExpressions.length) {
                        var oldInputValueOf = expressionInputDirtyCheck;
                        return inputExpressions = inputExpressions[0], scope.$watch(function (scope) {
                            var newInputValue = inputExpressions(scope);
                            return expressionInputDirtyCheck(newInputValue, oldInputValueOf) || (lastResult = parsedExpression(scope, void 0, void 0, [newInputValue]), oldInputValueOf = newInputValue && getValueOf(newInputValue)), lastResult
                        }, listener, objectEquality, prettyPrintExpression)
                    }
                    for (var oldInputValueOfValues = [], oldInputValues = [], i = 0, ii = inputExpressions.length; ii > i; i++)oldInputValueOfValues[i] = expressionInputDirtyCheck, oldInputValues[i] = null;
                    return scope.$watch(function (scope) {
                        for (var changed = !1, i = 0, ii = inputExpressions.length; ii > i; i++) {
                            var newInputValue = inputExpressions[i](scope);
                            (changed || (changed = !expressionInputDirtyCheck(newInputValue, oldInputValueOfValues[i]))) && (oldInputValues[i] = newInputValue, oldInputValueOfValues[i] = newInputValue && getValueOf(newInputValue))
                        }
                        return changed && (lastResult = parsedExpression(scope, void 0, void 0, oldInputValues)), lastResult
                    }, listener, objectEquality, prettyPrintExpression)
                }

                function oneTimeWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                    var unwatch, lastValue;
                    return unwatch = scope.$watch(function (scope) {
                        return parsedExpression(scope)
                    }, function (value, old, scope) {
                        lastValue = value, isFunction(listener) && listener.apply(this, arguments), isDefined(value) && scope.$$postDigest(function () {
                            isDefined(lastValue) && unwatch()
                        })
                    }, objectEquality)
                }

                function oneTimeLiteralWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                    function isAllDefined(value) {
                        var allDefined = !0;
                        return forEach(value, function (val) {
                            isDefined(val) || (allDefined = !1)
                        }), allDefined
                    }

                    var unwatch, lastValue;
                    return unwatch = scope.$watch(function (scope) {
                        return parsedExpression(scope)
                    }, function (value, old, scope) {
                        lastValue = value, isFunction(listener) && listener.call(this, value, old, scope), isAllDefined(value) && scope.$$postDigest(function () {
                            isAllDefined(lastValue) && unwatch()
                        })
                    }, objectEquality)
                }

                function constantWatchDelegate(scope, listener, objectEquality, parsedExpression) {
                    var unwatch;
                    return unwatch = scope.$watch(function (scope) {
                        return unwatch(), parsedExpression(scope)
                    }, listener, objectEquality)
                }

                function addInterceptor(parsedExpression, interceptorFn) {
                    if (!interceptorFn)return parsedExpression;
                    var watchDelegate = parsedExpression.$$watchDelegate, useInputs = !1, regularWatch = watchDelegate !== oneTimeLiteralWatchDelegate && watchDelegate !== oneTimeWatchDelegate, fn = regularWatch ? function (scope, locals, assign, inputs) {
                            var value = useInputs && inputs ? inputs[0] : parsedExpression(scope, locals, assign, inputs);
                            return interceptorFn(value, scope, locals)
                        } : function (scope, locals, assign, inputs) {
                            var value = parsedExpression(scope, locals, assign, inputs), result = interceptorFn(value, scope, locals);
                            return isDefined(value) ? result : value
                        };
                    return parsedExpression.$$watchDelegate && parsedExpression.$$watchDelegate !== inputsWatchDelegate ? fn.$$watchDelegate = parsedExpression.$$watchDelegate : interceptorFn.$stateful || (fn.$$watchDelegate = inputsWatchDelegate, useInputs = !parsedExpression.inputs, fn.inputs = parsedExpression.inputs ? parsedExpression.inputs : [parsedExpression]), fn
                }

                var noUnsafeEval = csp().noUnsafeEval, $parseOptions = {
                    csp: noUnsafeEval,
                    expensiveChecks: !1,
                    literals: copy(literals),
                    isIdentifierStart: isFunction(identStart) && identStart,
                    isIdentifierContinue: isFunction(identContinue) && identContinue
                }, $parseOptionsExpensive = {
                    csp: noUnsafeEval,
                    expensiveChecks: !0,
                    literals: copy(literals),
                    isIdentifierStart: isFunction(identStart) && identStart,
                    isIdentifierContinue: isFunction(identContinue) && identContinue
                }, runningChecksEnabled = !1;
                return $parse.$$runningExpensiveChecks = function () {
                    return runningChecksEnabled
                }, $parse
            }]
        }

        function $QProvider() {
            this.$get = ["$rootScope", "$exceptionHandler", function ($rootScope, $exceptionHandler) {
                return qFactory(function (callback) {
                    $rootScope.$evalAsync(callback)
                }, $exceptionHandler)
            }]
        }

        function $$QProvider() {
            this.$get = ["$browser", "$exceptionHandler", function ($browser, $exceptionHandler) {
                return qFactory(function (callback) {
                    $browser.defer(callback)
                }, $exceptionHandler)
            }]
        }

        function qFactory(nextTick, exceptionHandler) {
            function Promise() {
                this.$$state = {status: 0}
            }

            function simpleBind(context, fn) {
                return function (value) {
                    fn.call(context, value)
                }
            }

            function processQueue(state) {
                var fn, deferred, pending;
                pending = state.pending, state.processScheduled = !1, state.pending = void 0;
                for (var i = 0, ii = pending.length; ii > i; ++i) {
                    deferred = pending[i][0], fn = pending[i][state.status];
                    try {
                        isFunction(fn) ? deferred.resolve(fn(state.value)) : 1 === state.status ? deferred.resolve(state.value) : deferred.reject(state.value)
                    } catch (e) {
                        deferred.reject(e), exceptionHandler(e)
                    }
                }
            }

            function scheduleProcessQueue(state) {
                !state.processScheduled && state.pending && (state.processScheduled = !0, nextTick(function () {
                    processQueue(state)
                }))
            }

            function Deferred() {
                this.promise = new Promise
            }

            function all(promises) {
                var deferred = new Deferred, counter = 0, results = isArray(promises) ? [] : {};
                return forEach(promises, function (promise, key) {
                    counter++, when(promise).then(function (value) {
                        results.hasOwnProperty(key) || (results[key] = value, --counter || deferred.resolve(results))
                    }, function (reason) {
                        results.hasOwnProperty(key) || deferred.reject(reason)
                    })
                }), 0 === counter && deferred.resolve(results), deferred.promise
            }

            function race(promises) {
                var deferred = defer();
                return forEach(promises, function (promise) {
                    when(promise).then(deferred.resolve, deferred.reject)
                }), deferred.promise
            }

            var $qMinErr = minErr("$q", TypeError), defer = function () {
                var d = new Deferred;
                return d.resolve = simpleBind(d, d.resolve), d.reject = simpleBind(d, d.reject), d.notify = simpleBind(d, d.notify), d
            };
            extend(Promise.prototype, {
                then: function (onFulfilled, onRejected, progressBack) {
                    if (isUndefined(onFulfilled) && isUndefined(onRejected) && isUndefined(progressBack))return this;
                    var result = new Deferred;
                    return this.$$state.pending = this.$$state.pending || [], this.$$state.pending.push([result, onFulfilled, onRejected, progressBack]), this.$$state.status > 0 && scheduleProcessQueue(this.$$state), result.promise
                }, "catch": function (callback) {
                    return this.then(null, callback)
                }, "finally": function (callback, progressBack) {
                    return this.then(function (value) {
                        return handleCallback(value, !0, callback)
                    }, function (error) {
                        return handleCallback(error, !1, callback)
                    }, progressBack)
                }
            }), extend(Deferred.prototype, {
                resolve: function (val) {
                    this.promise.$$state.status || (val === this.promise ? this.$$reject($qMinErr("qcycle", "Expected promise to be resolved with value other than itself '{0}'", val)) : this.$$resolve(val))
                }, $$resolve: function (val) {
                    function resolvePromise(val) {
                        done || (done = !0, that.$$resolve(val))
                    }

                    function rejectPromise(val) {
                        done || (done = !0, that.$$reject(val))
                    }

                    var then, that = this, done = !1;
                    try {
                        (isObject(val) || isFunction(val)) && (then = val && val.then), isFunction(then) ? (this.promise.$$state.status = -1, then.call(val, resolvePromise, rejectPromise, simpleBind(this, this.notify))) : (this.promise.$$state.value = val, this.promise.$$state.status = 1, scheduleProcessQueue(this.promise.$$state))
                    } catch (e) {
                        rejectPromise(e), exceptionHandler(e)
                    }
                }, reject: function (reason) {
                    this.promise.$$state.status || this.$$reject(reason)
                }, $$reject: function (reason) {
                    this.promise.$$state.value = reason, this.promise.$$state.status = 2, scheduleProcessQueue(this.promise.$$state)
                }, notify: function (progress) {
                    var callbacks = this.promise.$$state.pending;
                    this.promise.$$state.status <= 0 && callbacks && callbacks.length && nextTick(function () {
                        for (var callback, result, i = 0, ii = callbacks.length; ii > i; i++) {
                            result = callbacks[i][0], callback = callbacks[i][3];
                            try {
                                result.notify(isFunction(callback) ? callback(progress) : progress)
                            } catch (e) {
                                exceptionHandler(e)
                            }
                        }
                    })
                }
            });
            var reject = function (reason) {
                var result = new Deferred;
                return result.reject(reason), result.promise
            }, makePromise = function (value, resolved) {
                var result = new Deferred;
                return resolved ? result.resolve(value) : result.reject(value), result.promise
            }, handleCallback = function (value, isResolved, callback) {
                var callbackOutput = null;
                try {
                    isFunction(callback) && (callbackOutput = callback())
                } catch (e) {
                    return makePromise(e, !1)
                }
                return isPromiseLike(callbackOutput) ? callbackOutput.then(function () {
                        return makePromise(value, isResolved)
                    }, function (error) {
                        return makePromise(error, !1)
                    }) : makePromise(value, isResolved)
            }, when = function (value, callback, errback, progressBack) {
                var result = new Deferred;
                return result.resolve(value), result.promise.then(callback, errback, progressBack)
            }, resolve = when, $Q = function (resolver) {
                function resolveFn(value) {
                    deferred.resolve(value)
                }

                function rejectFn(reason) {
                    deferred.reject(reason)
                }

                if (!isFunction(resolver))throw $qMinErr("norslvr", "Expected resolverFn, got '{0}'", resolver);
                var deferred = new Deferred;
                return resolver(resolveFn, rejectFn), deferred.promise
            };
            return $Q.prototype = Promise.prototype, $Q.defer = defer, $Q.reject = reject, $Q.when = when, $Q.resolve = resolve, $Q.all = all, $Q.race = race, $Q
        }

        function $$RAFProvider() {
            this.$get = ["$window", "$timeout", function ($window, $timeout) {
                var requestAnimationFrame = $window.requestAnimationFrame || $window.webkitRequestAnimationFrame, cancelAnimationFrame = $window.cancelAnimationFrame || $window.webkitCancelAnimationFrame || $window.webkitCancelRequestAnimationFrame, rafSupported = !!requestAnimationFrame, raf = rafSupported ? function (fn) {
                        var id = requestAnimationFrame(fn);
                        return function () {
                            cancelAnimationFrame(id)
                        }
                    } : function (fn) {
                        var timer = $timeout(fn, 16.66, !1);
                        return function () {
                            $timeout.cancel(timer)
                        }
                    };
                return raf.supported = rafSupported, raf
            }]
        }

        function $RootScopeProvider() {
            function createChildScopeClass(parent) {
                function ChildScope() {
                    this.$$watchers = this.$$nextSibling = this.$$childHead = this.$$childTail = null, this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$id = nextUid(), this.$$ChildScope = null
                }

                return ChildScope.prototype = parent, ChildScope
            }

            var TTL = 10, $rootScopeMinErr = minErr("$rootScope"), lastDirtyWatch = null, applyAsyncId = null;
            this.digestTtl = function (value) {
                return arguments.length && (TTL = value), TTL
            }, this.$get = ["$exceptionHandler", "$parse", "$browser", function ($exceptionHandler, $parse, $browser) {
                function destroyChildScope($event) {
                    $event.currentScope.$$destroyed = !0
                }

                function cleanUpScope($scope) {
                    9 === msie && ($scope.$$childHead && cleanUpScope($scope.$$childHead), $scope.$$nextSibling && cleanUpScope($scope.$$nextSibling)), $scope.$parent = $scope.$$nextSibling = $scope.$$prevSibling = $scope.$$childHead = $scope.$$childTail = $scope.$root = $scope.$$watchers = null
                }

                function Scope() {
                    this.$id = nextUid(), this.$$phase = this.$parent = this.$$watchers = this.$$nextSibling = this.$$prevSibling = this.$$childHead = this.$$childTail = null, this.$root = this, this.$$destroyed = !1, this.$$listeners = {}, this.$$listenerCount = {}, this.$$watchersCount = 0, this.$$isolateBindings = null
                }

                function beginPhase(phase) {
                    if ($rootScope.$$phase)throw $rootScopeMinErr("inprog", "{0} already in progress", $rootScope.$$phase);
                    $rootScope.$$phase = phase
                }

                function clearPhase() {
                    $rootScope.$$phase = null
                }

                function incrementWatchersCount(current, count) {
                    do current.$$watchersCount += count; while (current = current.$parent)
                }

                function decrementListenerCount(current, count, name) {
                    do current.$$listenerCount[name] -= count, 0 === current.$$listenerCount[name] && delete current.$$listenerCount[name]; while (current = current.$parent)
                }

                function initWatchVal() {
                }

                function flushApplyAsync() {
                    for (; applyAsyncQueue.length;)try {
                        applyAsyncQueue.shift()()
                    } catch (e) {
                        $exceptionHandler(e)
                    }
                    applyAsyncId = null
                }

                function scheduleApplyAsync() {
                    null === applyAsyncId && (applyAsyncId = $browser.defer(function () {
                        $rootScope.$apply(flushApplyAsync)
                    }))
                }

                Scope.prototype = {
                    constructor: Scope, $new: function (isolate, parent) {
                        var child;
                        return parent = parent || this, isolate ? (child = new Scope, child.$root = this.$root) : (this.$$ChildScope || (this.$$ChildScope = createChildScopeClass(this)), child = new this.$$ChildScope), child.$parent = parent, child.$$prevSibling = parent.$$childTail, parent.$$childHead ? (parent.$$childTail.$$nextSibling = child, parent.$$childTail = child) : parent.$$childHead = parent.$$childTail = child, (isolate || parent != this) && child.$on("$destroy", destroyChildScope), child
                    }, $watch: function (watchExp, listener, objectEquality, prettyPrintExpression) {
                        var get = $parse(watchExp);
                        if (get.$$watchDelegate)return get.$$watchDelegate(this, listener, objectEquality, get, watchExp);
                        var scope = this, array = scope.$$watchers, watcher = {
                            fn: listener,
                            last: initWatchVal,
                            get: get,
                            exp: prettyPrintExpression || watchExp,
                            eq: !!objectEquality
                        };
                        return lastDirtyWatch = null, isFunction(listener) || (watcher.fn = noop), array || (array = scope.$$watchers = []), array.unshift(watcher), incrementWatchersCount(this, 1), function () {
                            arrayRemove(array, watcher) >= 0 && incrementWatchersCount(scope, -1), lastDirtyWatch = null
                        }
                    }, $watchGroup: function (watchExpressions, listener) {
                        function watchGroupAction() {
                            changeReactionScheduled = !1, firstRun ? (firstRun = !1, listener(newValues, newValues, self)) : listener(newValues, oldValues, self)
                        }

                        var oldValues = new Array(watchExpressions.length), newValues = new Array(watchExpressions.length), deregisterFns = [], self = this, changeReactionScheduled = !1, firstRun = !0;
                        if (!watchExpressions.length) {
                            var shouldCall = !0;
                            return self.$evalAsync(function () {
                                shouldCall && listener(newValues, newValues, self)
                            }), function () {
                                shouldCall = !1
                            }
                        }
                        return 1 === watchExpressions.length ? this.$watch(watchExpressions[0], function (value, oldValue, scope) {
                                newValues[0] = value, oldValues[0] = oldValue, listener(newValues, value === oldValue ? newValues : oldValues, scope)
                            }) : (forEach(watchExpressions, function (expr, i) {
                                var unwatchFn = self.$watch(expr, function (value, oldValue) {
                                    newValues[i] = value, oldValues[i] = oldValue, changeReactionScheduled || (changeReactionScheduled = !0, self.$evalAsync(watchGroupAction))
                                });
                                deregisterFns.push(unwatchFn)
                            }), function () {
                                for (; deregisterFns.length;)deregisterFns.shift()()
                            })
                    }, $watchCollection: function (obj, listener) {
                        function $watchCollectionInterceptor(_value) {
                            newValue = _value;
                            var newLength, key, bothNaN, newItem, oldItem;
                            if (!isUndefined(newValue)) {
                                if (isObject(newValue))if (isArrayLike(newValue)) {
                                    oldValue !== internalArray && (oldValue = internalArray, oldLength = oldValue.length = 0, changeDetected++), newLength = newValue.length, oldLength !== newLength && (changeDetected++, oldValue.length = oldLength = newLength);
                                    for (var i = 0; newLength > i; i++)oldItem = oldValue[i], newItem = newValue[i], bothNaN = oldItem !== oldItem && newItem !== newItem, bothNaN || oldItem === newItem || (changeDetected++, oldValue[i] = newItem)
                                } else {
                                    oldValue !== internalObject && (oldValue = internalObject = {}, oldLength = 0, changeDetected++), newLength = 0;
                                    for (key in newValue)hasOwnProperty.call(newValue, key) && (newLength++, newItem = newValue[key], oldItem = oldValue[key], key in oldValue ? (bothNaN = oldItem !== oldItem && newItem !== newItem, bothNaN || oldItem === newItem || (changeDetected++, oldValue[key] = newItem)) : (oldLength++, oldValue[key] = newItem, changeDetected++));
                                    if (oldLength > newLength) {
                                        changeDetected++;
                                        for (key in oldValue)hasOwnProperty.call(newValue, key) || (oldLength--, delete oldValue[key])
                                    }
                                } else oldValue !== newValue && (oldValue = newValue, changeDetected++);
                                return changeDetected
                            }
                        }

                        function $watchCollectionAction() {
                            if (initRun ? (initRun = !1, listener(newValue, newValue, self)) : listener(newValue, veryOldValue, self), trackVeryOldValue)if (isObject(newValue))if (isArrayLike(newValue)) {
                                veryOldValue = new Array(newValue.length);
                                for (var i = 0; i < newValue.length; i++)veryOldValue[i] = newValue[i]
                            } else {
                                veryOldValue = {};
                                for (var key in newValue)hasOwnProperty.call(newValue, key) && (veryOldValue[key] = newValue[key])
                            } else veryOldValue = newValue
                        }

                        $watchCollectionInterceptor.$stateful = !0;
                        var newValue, oldValue, veryOldValue, self = this, trackVeryOldValue = listener.length > 1, changeDetected = 0, changeDetector = $parse(obj, $watchCollectionInterceptor), internalArray = [], internalObject = {}, initRun = !0, oldLength = 0;
                        return this.$watch(changeDetector, $watchCollectionAction)
                    }, $digest: function () {
                        var watch, value, last, fn, get, watchers, length, dirty, next, current, logIdx, asyncTask, ttl = TTL, target = this, watchLog = [];
                        beginPhase("$digest"), $browser.$$checkUrlChange(), this === $rootScope && null !== applyAsyncId && ($browser.defer.cancel(applyAsyncId), flushApplyAsync()), lastDirtyWatch = null;
                        do {
                            dirty = !1, current = target;
                            for (var asyncQueuePosition = 0; asyncQueuePosition < asyncQueue.length; asyncQueuePosition++) {
                                try {
                                    asyncTask = asyncQueue[asyncQueuePosition], asyncTask.scope.$eval(asyncTask.expression, asyncTask.locals)
                                } catch (e) {
                                    $exceptionHandler(e)
                                }
                                lastDirtyWatch = null
                            }
                            asyncQueue.length = 0;
                            traverseScopesLoop:do {
                                if (watchers = current.$$watchers)for (length = watchers.length; length--;)try {
                                    if (watch = watchers[length])if (get = watch.get, (value = get(current)) === (last = watch.last) || (watch.eq ? equals(value, last) : "number" == typeof value && "number" == typeof last && isNaN(value) && isNaN(last))) {
                                        if (watch === lastDirtyWatch) {
                                            dirty = !1;
                                            break traverseScopesLoop
                                        }
                                    } else dirty = !0, lastDirtyWatch = watch, watch.last = watch.eq ? copy(value, null) : value, fn = watch.fn, fn(value, last === initWatchVal ? value : last, current), 5 > ttl && (logIdx = 4 - ttl, watchLog[logIdx] || (watchLog[logIdx] = []), watchLog[logIdx].push({
                                        msg: isFunction(watch.exp) ? "fn: " + (watch.exp.name || watch.exp.toString()) : watch.exp,
                                        newVal: value,
                                        oldVal: last
                                    }))
                                } catch (e) {
                                    $exceptionHandler(e)
                                }
                                if (!(next = current.$$watchersCount && current.$$childHead || current !== target && current.$$nextSibling))for (; current !== target && !(next = current.$$nextSibling);)current = current.$parent
                            } while (current = next);
                            if ((dirty || asyncQueue.length) && !ttl--)throw clearPhase(), $rootScopeMinErr("infdig", "{0} $digest() iterations reached. Aborting!\nWatchers fired in the last 5 iterations: {1}", TTL, watchLog)
                        } while (dirty || asyncQueue.length);
                        for (clearPhase(); postDigestQueuePosition < postDigestQueue.length;)try {
                            postDigestQueue[postDigestQueuePosition++]()
                        } catch (e) {
                            $exceptionHandler(e)
                        }
                        postDigestQueue.length = postDigestQueuePosition = 0
                    }, $destroy: function () {
                        if (!this.$$destroyed) {
                            var parent = this.$parent;
                            this.$broadcast("$destroy"), this.$$destroyed = !0, this === $rootScope && $browser.$$applicationDestroyed(), incrementWatchersCount(this, -this.$$watchersCount);
                            for (var eventName in this.$$listenerCount)decrementListenerCount(this, this.$$listenerCount[eventName], eventName);
                            parent && parent.$$childHead == this && (parent.$$childHead = this.$$nextSibling), parent && parent.$$childTail == this && (parent.$$childTail = this.$$prevSibling), this.$$prevSibling && (this.$$prevSibling.$$nextSibling = this.$$nextSibling), this.$$nextSibling && (this.$$nextSibling.$$prevSibling = this.$$prevSibling), this.$destroy = this.$digest = this.$apply = this.$evalAsync = this.$applyAsync = noop, this.$on = this.$watch = this.$watchGroup = function () {
                                return noop
                            }, this.$$listeners = {}, this.$$nextSibling = null, cleanUpScope(this)
                        }
                    }, $eval: function (expr, locals) {
                        return $parse(expr)(this, locals)
                    }, $evalAsync: function (expr, locals) {
                        $rootScope.$$phase || asyncQueue.length || $browser.defer(function () {
                            asyncQueue.length && $rootScope.$digest()
                        }), asyncQueue.push({scope: this, expression: $parse(expr), locals: locals})
                    }, $$postDigest: function (fn) {
                        postDigestQueue.push(fn)
                    }, $apply: function (expr) {
                        try {
                            beginPhase("$apply");
                            try {
                                return this.$eval(expr)
                            } finally {
                                clearPhase()
                            }
                        } catch (e) {
                            $exceptionHandler(e)
                        } finally {
                            try {
                                $rootScope.$digest()
                            } catch (e) {
                                throw $exceptionHandler(e), e
                            }
                        }
                    }, $applyAsync: function (expr) {
                        function $applyAsyncExpression() {
                            scope.$eval(expr)
                        }

                        var scope = this;
                        expr && applyAsyncQueue.push($applyAsyncExpression), expr = $parse(expr), scheduleApplyAsync()
                    }, $on: function (name, listener) {
                        var namedListeners = this.$$listeners[name];
                        namedListeners || (this.$$listeners[name] = namedListeners = []), namedListeners.push(listener);
                        var current = this;
                        do current.$$listenerCount[name] || (current.$$listenerCount[name] = 0), current.$$listenerCount[name]++; while (current = current.$parent);
                        var self = this;
                        return function () {
                            var indexOfListener = namedListeners.indexOf(listener);
                            -1 !== indexOfListener && (namedListeners[indexOfListener] = null, decrementListenerCount(self, 1, name))
                        }
                    }, $emit: function (name, args) {
                        var namedListeners, i, length, empty = [], scope = this, stopPropagation = !1, event = {
                            name: name,
                            targetScope: scope,
                            stopPropagation: function () {
                                stopPropagation = !0
                            },
                            preventDefault: function () {
                                event.defaultPrevented = !0
                            },
                            defaultPrevented: !1
                        }, listenerArgs = concat([event], arguments, 1);
                        do {
                            for (namedListeners = scope.$$listeners[name] || empty, event.currentScope = scope, i = 0, length = namedListeners.length; length > i; i++)if (namedListeners[i])try {
                                namedListeners[i].apply(null, listenerArgs)
                            } catch (e) {
                                $exceptionHandler(e)
                            } else namedListeners.splice(i, 1), i--, length--;
                            if (stopPropagation)return event.currentScope = null, event;
                            scope = scope.$parent
                        } while (scope);
                        return event.currentScope = null, event
                    }, $broadcast: function (name, args) {
                        var target = this, current = target, next = target, event = {
                            name: name,
                            targetScope: target,
                            preventDefault: function () {
                                event.defaultPrevented = !0
                            },
                            defaultPrevented: !1
                        };
                        if (!target.$$listenerCount[name])return event;
                        for (var listeners, i, length, listenerArgs = concat([event], arguments, 1); current = next;) {
                            for (event.currentScope = current, listeners = current.$$listeners[name] || [], i = 0, length = listeners.length; length > i; i++)if (listeners[i])try {
                                listeners[i].apply(null, listenerArgs)
                            } catch (e) {
                                $exceptionHandler(e)
                            } else listeners.splice(i, 1), i--, length--;
                            if (!(next = current.$$listenerCount[name] && current.$$childHead || current !== target && current.$$nextSibling))for (; current !== target && !(next = current.$$nextSibling);)current = current.$parent
                        }
                        return event.currentScope = null, event
                    }
                };
                var $rootScope = new Scope, asyncQueue = $rootScope.$$asyncQueue = [], postDigestQueue = $rootScope.$$postDigestQueue = [], applyAsyncQueue = $rootScope.$$applyAsyncQueue = [], postDigestQueuePosition = 0;
                return $rootScope
            }]
        }

        function $$SanitizeUriProvider() {
            var aHrefSanitizationWhitelist = /^\s*(https?|ftp|mailto|tel|file):/, imgSrcSanitizationWhitelist = /^\s*((https?|ftp|file|blob):|data:image\/)/;
            this.aHrefSanitizationWhitelist = function (regexp) {
                return isDefined(regexp) ? (aHrefSanitizationWhitelist = regexp, this) : aHrefSanitizationWhitelist
            }, this.imgSrcSanitizationWhitelist = function (regexp) {
                return isDefined(regexp) ? (imgSrcSanitizationWhitelist = regexp, this) : imgSrcSanitizationWhitelist
            }, this.$get = function () {
                return function (uri, isImage) {
                    var normalizedVal, regex = isImage ? imgSrcSanitizationWhitelist : aHrefSanitizationWhitelist;
                    return normalizedVal = urlResolve(uri).href, "" === normalizedVal || normalizedVal.match(regex) ? uri : "unsafe:" + normalizedVal
                }
            }
        }

        function adjustMatcher(matcher) {
            if ("self" === matcher)return matcher;
            if (isString(matcher)) {
                if (matcher.indexOf("***") > -1)throw $sceMinErr("iwcard", "Illegal sequence *** in string matcher.  String: {0}", matcher);
                return matcher = escapeForRegexp(matcher).replace("\\*\\*", ".*").replace("\\*", "[^:/.?&;]*"), new RegExp("^" + matcher + "$")
            }
            if (isRegExp(matcher))return new RegExp("^" + matcher.source + "$");
            throw $sceMinErr("imatcher", 'Matchers may only be "self", string patterns or RegExp objects')
        }

        function adjustMatchers(matchers) {
            var adjustedMatchers = [];
            return isDefined(matchers) && forEach(matchers, function (matcher) {
                adjustedMatchers.push(adjustMatcher(matcher))
            }), adjustedMatchers;
        }

        function $SceDelegateProvider() {
            this.SCE_CONTEXTS = SCE_CONTEXTS;
            var resourceUrlWhitelist = ["self"], resourceUrlBlacklist = [];
            this.resourceUrlWhitelist = function (value) {
                return arguments.length && (resourceUrlWhitelist = adjustMatchers(value)), resourceUrlWhitelist
            }, this.resourceUrlBlacklist = function (value) {
                return arguments.length && (resourceUrlBlacklist = adjustMatchers(value)), resourceUrlBlacklist
            }, this.$get = ["$injector", function ($injector) {
                function matchUrl(matcher, parsedUrl) {
                    return "self" === matcher ? urlIsSameOrigin(parsedUrl) : !!matcher.exec(parsedUrl.href)
                }

                function isResourceUrlAllowedByPolicy(url) {
                    var i, n, parsedUrl = urlResolve(url.toString()), allowed = !1;
                    for (i = 0, n = resourceUrlWhitelist.length; n > i; i++)if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {
                        allowed = !0;
                        break
                    }
                    if (allowed)for (i = 0, n = resourceUrlBlacklist.length; n > i; i++)if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {
                        allowed = !1;
                        break
                    }
                    return allowed
                }

                function generateHolderType(Base) {
                    var holderType = function (trustedValue) {
                        this.$$unwrapTrustedValue = function () {
                            return trustedValue
                        }
                    };
                    return Base && (holderType.prototype = new Base), holderType.prototype.valueOf = function () {
                        return this.$$unwrapTrustedValue()
                    }, holderType.prototype.toString = function () {
                        return this.$$unwrapTrustedValue().toString()
                    }, holderType
                }

                function trustAs(type, trustedValue) {
                    var Constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                    if (!Constructor)throw $sceMinErr("icontext", "Attempted to trust a value in invalid context. Context: {0}; Value: {1}", type, trustedValue);
                    if (null === trustedValue || isUndefined(trustedValue) || "" === trustedValue)return trustedValue;
                    if ("string" != typeof trustedValue)throw $sceMinErr("itype", "Attempted to trust a non-string value in a content requiring a string: Context: {0}", type);
                    return new Constructor(trustedValue)
                }

                function valueOf(maybeTrusted) {
                    return maybeTrusted instanceof trustedValueHolderBase ? maybeTrusted.$$unwrapTrustedValue() : maybeTrusted
                }

                function getTrusted(type, maybeTrusted) {
                    if (null === maybeTrusted || isUndefined(maybeTrusted) || "" === maybeTrusted)return maybeTrusted;
                    var constructor = byType.hasOwnProperty(type) ? byType[type] : null;
                    if (constructor && maybeTrusted instanceof constructor)return maybeTrusted.$$unwrapTrustedValue();
                    if (type === SCE_CONTEXTS.RESOURCE_URL) {
                        if (isResourceUrlAllowedByPolicy(maybeTrusted))return maybeTrusted;
                        throw $sceMinErr("insecurl", "Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}", maybeTrusted.toString())
                    }
                    if (type === SCE_CONTEXTS.HTML)return htmlSanitizer(maybeTrusted);
                    throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
                }

                var htmlSanitizer = function (html) {
                    throw $sceMinErr("unsafe", "Attempting to use an unsafe value in a safe context.")
                };
                $injector.has("$sanitize") && (htmlSanitizer = $injector.get("$sanitize"));
                var trustedValueHolderBase = generateHolderType(), byType = {};
                return byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase), byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]), {
                    trustAs: trustAs,
                    getTrusted: getTrusted,
                    valueOf: valueOf
                }
            }]
        }

        function $SceProvider() {
            var enabled = !0;
            this.enabled = function (value) {
                return arguments.length && (enabled = !!value), enabled
            }, this.$get = ["$parse", "$sceDelegate", function ($parse, $sceDelegate) {
                if (enabled && 8 > msie)throw $sceMinErr("iequirks", "Strict Contextual Escaping does not support Internet Explorer version < 11 in quirks mode.  You can fix this by adding the text <!doctype html> to the top of your HTML document.  See http://docs.angularjs.org/api/ng.$sce for more information.");
                var sce = shallowCopy(SCE_CONTEXTS);
                sce.isEnabled = function () {
                    return enabled
                }, sce.trustAs = $sceDelegate.trustAs, sce.getTrusted = $sceDelegate.getTrusted, sce.valueOf = $sceDelegate.valueOf, enabled || (sce.trustAs = sce.getTrusted = function (type, value) {
                    return value
                }, sce.valueOf = identity), sce.parseAs = function (type, expr) {
                    var parsed = $parse(expr);
                    return parsed.literal && parsed.constant ? parsed : $parse(expr, function (value) {
                            return sce.getTrusted(type, value)
                        })
                };
                var parse = sce.parseAs, getTrusted = sce.getTrusted, trustAs = sce.trustAs;
                return forEach(SCE_CONTEXTS, function (enumValue, name) {
                    var lName = lowercase(name);
                    sce[camelCase("parse_as_" + lName)] = function (expr) {
                        return parse(enumValue, expr)
                    }, sce[camelCase("get_trusted_" + lName)] = function (value) {
                        return getTrusted(enumValue, value)
                    }, sce[camelCase("trust_as_" + lName)] = function (value) {
                        return trustAs(enumValue, value)
                    }
                }), sce
            }]
        }

        function $SnifferProvider() {
            this.$get = ["$window", "$document", function ($window, $document) {
                var vendorPrefix, match, eventSupport = {}, isChromePackagedApp = $window.chrome && $window.chrome.app && $window.chrome.app.runtime, hasHistoryPushState = !isChromePackagedApp && $window.history && $window.history.pushState, android = toInt((/android (\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]), boxee = /Boxee/i.test(($window.navigator || {}).userAgent), document = $document[0] || {}, vendorRegex = /^(Moz|webkit|ms)(?=[A-Z])/, bodyStyle = document.body && document.body.style, transitions = !1, animations = !1;
                if (bodyStyle) {
                    for (var prop in bodyStyle)if (match = vendorRegex.exec(prop)) {
                        vendorPrefix = match[0], vendorPrefix = vendorPrefix[0].toUpperCase() + vendorPrefix.substr(1);
                        break
                    }
                    vendorPrefix || (vendorPrefix = "WebkitOpacity" in bodyStyle && "webkit"), transitions = !!("transition" in bodyStyle || vendorPrefix + "Transition" in bodyStyle), animations = !!("animation" in bodyStyle || vendorPrefix + "Animation" in bodyStyle), !android || transitions && animations || (transitions = isString(bodyStyle.webkitTransition), animations = isString(bodyStyle.webkitAnimation))
                }
                return {
                    history: !(!hasHistoryPushState || 4 > android || boxee),
                    hasEvent: function (event) {
                        if ("input" === event && 11 >= msie)return !1;
                        if (isUndefined(eventSupport[event])) {
                            var divElm = document.createElement("div");
                            eventSupport[event] = "on" + event in divElm
                        }
                        return eventSupport[event]
                    },
                    csp: csp(),
                    vendorPrefix: vendorPrefix,
                    transitions: transitions,
                    animations: animations,
                    android: android
                }
            }]
        }

        function $TemplateRequestProvider() {
            var httpOptions;
            this.httpOptions = function (val) {
                return val ? (httpOptions = val, this) : httpOptions
            }, this.$get = ["$templateCache", "$http", "$q", "$sce", function ($templateCache, $http, $q, $sce) {
                function handleRequestFn(tpl, ignoreRequestError) {
                    function handleError(resp) {
                        if (!ignoreRequestError)throw $templateRequestMinErr("tpload", "Failed to load template: {0} (HTTP status: {1} {2})", tpl, resp.status, resp.statusText);
                        return $q.reject(resp)
                    }

                    handleRequestFn.totalPendingRequests++, (!isString(tpl) || isUndefined($templateCache.get(tpl))) && (tpl = $sce.getTrustedResourceUrl(tpl));
                    var transformResponse = $http.defaults && $http.defaults.transformResponse;
                    return isArray(transformResponse) ? transformResponse = transformResponse.filter(function (transformer) {
                            return transformer !== defaultHttpResponseTransform
                        }) : transformResponse === defaultHttpResponseTransform && (transformResponse = null), $http.get(tpl, extend({
                        cache: $templateCache,
                        transformResponse: transformResponse
                    }, httpOptions))["finally"](function () {
                        handleRequestFn.totalPendingRequests--
                    }).then(function (response) {
                        return $templateCache.put(tpl, response.data), response.data
                    }, handleError)
                }

                return handleRequestFn.totalPendingRequests = 0, handleRequestFn
            }]
        }

        function $$TestabilityProvider() {
            this.$get = ["$rootScope", "$browser", "$location", function ($rootScope, $browser, $location) {
                var testability = {};
                return testability.findBindings = function (element, expression, opt_exactMatch) {
                    var bindings = element.getElementsByClassName("ng-binding"), matches = [];
                    return forEach(bindings, function (binding) {
                        var dataBinding = angular.element(binding).data("$binding");
                        dataBinding && forEach(dataBinding, function (bindingName) {
                            if (opt_exactMatch) {
                                var matcher = new RegExp("(^|\\s)" + escapeForRegexp(expression) + "(\\s|\\||$)");
                                matcher.test(bindingName) && matches.push(binding)
                            } else-1 != bindingName.indexOf(expression) && matches.push(binding)
                        })
                    }), matches
                }, testability.findModels = function (element, expression, opt_exactMatch) {
                    for (var prefixes = ["ng-", "data-ng-", "ng\\:"], p = 0; p < prefixes.length; ++p) {
                        var attributeEquals = opt_exactMatch ? "=" : "*=", selector = "[" + prefixes[p] + "model" + attributeEquals + '"' + expression + '"]', elements = element.querySelectorAll(selector);
                        if (elements.length)return elements
                    }
                }, testability.getLocation = function () {
                    return $location.url()
                }, testability.setLocation = function (url) {
                    url !== $location.url() && ($location.url(url), $rootScope.$digest())
                }, testability.whenStable = function (callback) {
                    $browser.notifyWhenNoOutstandingRequests(callback)
                }, testability
            }]
        }

        function $TimeoutProvider() {
            this.$get = ["$rootScope", "$browser", "$q", "$$q", "$exceptionHandler", function ($rootScope, $browser, $q, $$q, $exceptionHandler) {
                function timeout(fn, delay, invokeApply) {
                    isFunction(fn) || (invokeApply = delay, delay = fn, fn = noop);
                    var timeoutId, args = sliceArgs(arguments, 3), skipApply = isDefined(invokeApply) && !invokeApply, deferred = (skipApply ? $$q : $q).defer(), promise = deferred.promise;
                    return timeoutId = $browser.defer(function () {
                        try {
                            deferred.resolve(fn.apply(null, args))
                        } catch (e) {
                            deferred.reject(e), $exceptionHandler(e)
                        } finally {
                            delete deferreds[promise.$$timeoutId]
                        }
                        skipApply || $rootScope.$apply()
                    }, delay), promise.$$timeoutId = timeoutId, deferreds[timeoutId] = deferred, promise
                }

                var deferreds = {};
                return timeout.cancel = function (promise) {
                    return promise && promise.$$timeoutId in deferreds ? (deferreds[promise.$$timeoutId].reject("canceled"), delete deferreds[promise.$$timeoutId], $browser.defer.cancel(promise.$$timeoutId)) : !1
                }, timeout
            }]
        }

        function urlResolve(url) {
            var href = url;
            return msie && (urlParsingNode.setAttribute("href", href), href = urlParsingNode.href), urlParsingNode.setAttribute("href", href), {
                href: urlParsingNode.href,
                protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
                host: urlParsingNode.host,
                search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
                hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
                hostname: urlParsingNode.hostname,
                port: urlParsingNode.port,
                pathname: "/" === urlParsingNode.pathname.charAt(0) ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
            }
        }

        function urlIsSameOrigin(requestUrl) {
            var parsed = isString(requestUrl) ? urlResolve(requestUrl) : requestUrl;
            return parsed.protocol === originUrl.protocol && parsed.host === originUrl.host
        }

        function $WindowProvider() {
            this.$get = valueFn(window)
        }

        function $$CookieReader($document) {
            function safeDecodeURIComponent(str) {
                try {
                    return decodeURIComponent(str)
                } catch (e) {
                    return str
                }
            }

            var rawDocument = $document[0] || {}, lastCookies = {}, lastCookieString = "";
            return function () {
                var cookieArray, cookie, i, index, name, currentCookieString = rawDocument.cookie || "";
                if (currentCookieString !== lastCookieString)for (lastCookieString = currentCookieString, cookieArray = lastCookieString.split("; "), lastCookies = {}, i = 0; i < cookieArray.length; i++)cookie = cookieArray[i], index = cookie.indexOf("="), index > 0 && (name = safeDecodeURIComponent(cookie.substring(0, index)), isUndefined(lastCookies[name]) && (lastCookies[name] = safeDecodeURIComponent(cookie.substring(index + 1))));
                return lastCookies
            }
        }

        function $$CookieReaderProvider() {
            this.$get = $$CookieReader
        }

        function $FilterProvider($provide) {
            function register(name, factory) {
                if (isObject(name)) {
                    var filters = {};
                    return forEach(name, function (filter, key) {
                        filters[key] = register(key, filter)
                    }), filters
                }
                return $provide.factory(name + suffix, factory)
            }

            var suffix = "Filter";
            this.register = register, this.$get = ["$injector", function ($injector) {
                return function (name) {
                    return $injector.get(name + suffix)
                }
            }], register("currency", currencyFilter), register("date", dateFilter), register("filter", filterFilter), register("json", jsonFilter), register("limitTo", limitToFilter), register("lowercase", lowercaseFilter), register("number", numberFilter), register("orderBy", orderByFilter), register("uppercase", uppercaseFilter)
        }

        function filterFilter() {
            return function (array, expression, comparator, anyPropertyKey) {
                if (!isArrayLike(array)) {
                    if (null == array)return array;
                    throw minErr("filter")("notarray", "Expected array but received: {0}", array)
                }
                anyPropertyKey = anyPropertyKey || "$";
                var predicateFn, matchAgainstAnyProp, expressionType = getTypeForFilter(expression);
                switch (expressionType) {
                    case"function":
                        predicateFn = expression;
                        break;
                    case"boolean":
                    case"null":
                    case"number":
                    case"string":
                        matchAgainstAnyProp = !0;
                    case"object":
                        predicateFn = createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp);
                        break;
                    default:
                        return array
                }
                return Array.prototype.filter.call(array, predicateFn)
            }
        }

        function createPredicateFn(expression, comparator, anyPropertyKey, matchAgainstAnyProp) {
            var predicateFn, shouldMatchPrimitives = isObject(expression) && anyPropertyKey in expression;
            return comparator === !0 ? comparator = equals : isFunction(comparator) || (comparator = function (actual, expected) {
                    return isUndefined(actual) ? !1 : null === actual || null === expected ? actual === expected : isObject(expected) || isObject(actual) && !hasCustomToString(actual) ? !1 : (actual = lowercase("" + actual), expected = lowercase("" + expected), -1 !== actual.indexOf(expected))
                }), predicateFn = function (item) {
                return shouldMatchPrimitives && !isObject(item) ? deepCompare(item, expression[anyPropertyKey], comparator, anyPropertyKey, !1) : deepCompare(item, expression, comparator, anyPropertyKey, matchAgainstAnyProp)
            }
        }

        function deepCompare(actual, expected, comparator, anyPropertyKey, matchAgainstAnyProp, dontMatchWholeObject) {
            var actualType = getTypeForFilter(actual), expectedType = getTypeForFilter(expected);
            if ("string" === expectedType && "!" === expected.charAt(0))return !deepCompare(actual, expected.substring(1), comparator, anyPropertyKey, matchAgainstAnyProp);
            if (isArray(actual))return actual.some(function (item) {
                return deepCompare(item, expected, comparator, anyPropertyKey, matchAgainstAnyProp)
            });
            switch (actualType) {
                case"object":
                    var key;
                    if (matchAgainstAnyProp) {
                        for (key in actual)if ("$" !== key.charAt(0) && deepCompare(actual[key], expected, comparator, anyPropertyKey, !0))return !0;
                        return dontMatchWholeObject ? !1 : deepCompare(actual, expected, comparator, anyPropertyKey, !1)
                    }
                    if ("object" === expectedType) {
                        for (key in expected) {
                            var expectedVal = expected[key];
                            if (!isFunction(expectedVal) && !isUndefined(expectedVal)) {
                                var matchAnyProperty = key === anyPropertyKey, actualVal = matchAnyProperty ? actual : actual[key];
                                if (!deepCompare(actualVal, expectedVal, comparator, anyPropertyKey, matchAnyProperty, matchAnyProperty))return !1
                            }
                        }
                        return !0
                    }
                    return comparator(actual, expected);
                case"function":
                    return !1;
                default:
                    return comparator(actual, expected)
            }
        }

        function getTypeForFilter(val) {
            return null === val ? "null" : typeof val
        }

        function currencyFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function (amount, currencySymbol, fractionSize) {
                return isUndefined(currencySymbol) && (currencySymbol = formats.CURRENCY_SYM), isUndefined(fractionSize) && (fractionSize = formats.PATTERNS[1].maxFrac), null == amount ? amount : formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize).replace(/\u00A4/g, currencySymbol)
            }
        }

        function numberFilter($locale) {
            var formats = $locale.NUMBER_FORMATS;
            return function (number, fractionSize) {
                return null == number ? number : formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP, fractionSize)
            }
        }

        function parse(numStr) {
            var digits, numberOfIntegerDigits, i, j, zeros, exponent = 0;
            for ((numberOfIntegerDigits = numStr.indexOf(DECIMAL_SEP)) > -1 && (numStr = numStr.replace(DECIMAL_SEP, "")), (i = numStr.search(/e/i)) > 0 ? (0 > numberOfIntegerDigits && (numberOfIntegerDigits = i), numberOfIntegerDigits += +numStr.slice(i + 1), numStr = numStr.substring(0, i)) : 0 > numberOfIntegerDigits && (numberOfIntegerDigits = numStr.length), i = 0; numStr.charAt(i) == ZERO_CHAR; i++);
            if (i == (zeros = numStr.length)) digits = [0], numberOfIntegerDigits = 1; else {
                for (zeros--; numStr.charAt(zeros) == ZERO_CHAR;)zeros--;
                for (numberOfIntegerDigits -= i, digits = [], j = 0; zeros >= i; i++, j++)digits[j] = +numStr.charAt(i)
            }
            return numberOfIntegerDigits > MAX_DIGITS && (digits = digits.splice(0, MAX_DIGITS - 1), exponent = numberOfIntegerDigits - 1, numberOfIntegerDigits = 1), {
                d: digits,
                e: exponent,
                i: numberOfIntegerDigits
            }
        }

        function roundNumber(parsedNumber, fractionSize, minFrac, maxFrac) {
            var digits = parsedNumber.d, fractionLen = digits.length - parsedNumber.i;
            fractionSize = isUndefined(fractionSize) ? Math.min(Math.max(minFrac, fractionLen), maxFrac) : +fractionSize;
            var roundAt = fractionSize + parsedNumber.i, digit = digits[roundAt];
            if (roundAt > 0) {
                digits.splice(Math.max(parsedNumber.i, roundAt));
                for (var j = roundAt; j < digits.length; j++)digits[j] = 0
            } else {
                fractionLen = Math.max(0, fractionLen), parsedNumber.i = 1, digits.length = Math.max(1, roundAt = fractionSize + 1), digits[0] = 0;
                for (var i = 1; roundAt > i; i++)digits[i] = 0
            }
            if (digit >= 5)if (0 > roundAt - 1) {
                for (var k = 0; k > roundAt; k--)digits.unshift(0), parsedNumber.i++;
                digits.unshift(1), parsedNumber.i++
            } else digits[roundAt - 1]++;
            for (; fractionLen < Math.max(0, fractionSize); fractionLen++)digits.push(0);
            var carry = digits.reduceRight(function (carry, d, i, digits) {
                return d += carry, digits[i] = d % 10, Math.floor(d / 10)
            }, 0);
            carry && (digits.unshift(carry), parsedNumber.i++)
        }

        function formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {
            if (!isString(number) && !isNumber(number) || isNaN(number))return "";
            var parsedNumber, isInfinity = !isFinite(number), isZero = !1, numStr = Math.abs(number) + "", formattedText = "";
            if (isInfinity) formattedText = "∞"; else {
                parsedNumber = parse(numStr), roundNumber(parsedNumber, fractionSize, pattern.minFrac, pattern.maxFrac);
                var digits = parsedNumber.d, integerLen = parsedNumber.i, exponent = parsedNumber.e, decimals = [];
                for (isZero = digits.reduce(function (isZero, d) {
                    return isZero && !d
                }, !0); 0 > integerLen;)digits.unshift(0), integerLen++;
                integerLen > 0 ? decimals = digits.splice(integerLen, digits.length) : (decimals = digits, digits = [0]);
                var groups = [];
                for (digits.length >= pattern.lgSize && groups.unshift(digits.splice(-pattern.lgSize, digits.length).join("")); digits.length > pattern.gSize;)groups.unshift(digits.splice(-pattern.gSize, digits.length).join(""));
                digits.length && groups.unshift(digits.join("")), formattedText = groups.join(groupSep), decimals.length && (formattedText += decimalSep + decimals.join("")), exponent && (formattedText += "e+" + exponent)
            }
            return 0 > number && !isZero ? pattern.negPre + formattedText + pattern.negSuf : pattern.posPre + formattedText + pattern.posSuf
        }

        function padNumber(num, digits, trim, negWrap) {
            var neg = "";
            for ((0 > num || negWrap && 0 >= num) && (negWrap ? num = -num + 1 : (num = -num, neg = "-")), num = "" + num; num.length < digits;)num = ZERO_CHAR + num;
            return trim && (num = num.substr(num.length - digits)), neg + num
        }

        function dateGetter(name, size, offset, trim, negWrap) {
            return offset = offset || 0, function (date) {
                var value = date["get" + name]();
                return (offset > 0 || value > -offset) && (value += offset), 0 === value && -12 == offset && (value = 12), padNumber(value, size, trim, negWrap)
            }
        }

        function dateStrGetter(name, shortForm, standAlone) {
            return function (date, formats) {
                var value = date["get" + name](), propPrefix = (standAlone ? "STANDALONE" : "") + (shortForm ? "SHORT" : ""), get = uppercase(propPrefix + name);
                return formats[get][value]
            }
        }

        function timeZoneGetter(date, formats, offset) {
            var zone = -1 * offset, paddedZone = zone >= 0 ? "+" : "";
            return paddedZone += padNumber(Math[zone > 0 ? "floor" : "ceil"](zone / 60), 2) + padNumber(Math.abs(zone % 60), 2)
        }

        function getFirstThursdayOfYear(year) {
            var dayOfWeekOnFirst = new Date(year, 0, 1).getDay();
            return new Date(year, 0, (4 >= dayOfWeekOnFirst ? 5 : 12) - dayOfWeekOnFirst)
        }

        function getThursdayThisWeek(datetime) {
            return new Date(datetime.getFullYear(), datetime.getMonth(), datetime.getDate() + (4 - datetime.getDay()))
        }

        function weekGetter(size) {
            return function (date) {
                var firstThurs = getFirstThursdayOfYear(date.getFullYear()), thisThurs = getThursdayThisWeek(date), diff = +thisThurs - +firstThurs, result = 1 + Math.round(diff / 6048e5);
                return padNumber(result, size)
            }
        }

        function ampmGetter(date, formats) {
            return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1]
        }

        function eraGetter(date, formats) {
            return date.getFullYear() <= 0 ? formats.ERAS[0] : formats.ERAS[1]
        }

        function longEraGetter(date, formats) {
            return date.getFullYear() <= 0 ? formats.ERANAMES[0] : formats.ERANAMES[1]
        }

        function dateFilter($locale) {
            function jsonStringToDate(string) {
                var match;
                if (match = string.match(R_ISO8601_STR)) {
                    var date = new Date(0), tzHour = 0, tzMin = 0, dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear, timeSetter = match[8] ? date.setUTCHours : date.setHours;
                    match[9] && (tzHour = toInt(match[9] + match[10]), tzMin = toInt(match[9] + match[11])), dateSetter.call(date, toInt(match[1]), toInt(match[2]) - 1, toInt(match[3]));
                    var h = toInt(match[4] || 0) - tzHour, m = toInt(match[5] || 0) - tzMin, s = toInt(match[6] || 0), ms = Math.round(1e3 * parseFloat("0." + (match[7] || 0)));
                    return timeSetter.call(date, h, m, s, ms), date
                }
                return string
            }

            var R_ISO8601_STR = /^(\d{4})-?(\d\d)-?(\d\d)(?:T(\d\d)(?::?(\d\d)(?::?(\d\d)(?:\.(\d+))?)?)?(Z|([+-])(\d\d):?(\d\d))?)?$/;
            return function (date, format, timezone) {
                var fn, match, text = "", parts = [];
                if (format = format || "mediumDate", format = $locale.DATETIME_FORMATS[format] || format, isString(date) && (date = NUMBER_STRING.test(date) ? toInt(date) : jsonStringToDate(date)), isNumber(date) && (date = new Date(date)), !isDate(date) || !isFinite(date.getTime()))return date;
                for (; format;)match = DATE_FORMATS_SPLIT.exec(format), match ? (parts = concat(parts, match, 1), format = parts.pop()) : (parts.push(format), format = null);
                var dateTimezoneOffset = date.getTimezoneOffset();
                return timezone && (dateTimezoneOffset = timezoneToOffset(timezone, dateTimezoneOffset), date = convertTimezoneToLocal(date, timezone, !0)), forEach(parts, function (value) {
                    fn = DATE_FORMATS[value], text += fn ? fn(date, $locale.DATETIME_FORMATS, dateTimezoneOffset) : "''" === value ? "'" : value.replace(/(^'|'$)/g, "").replace(/''/g, "'")
                }), text
            }
        }

        function jsonFilter() {
            return function (object, spacing) {
                return isUndefined(spacing) && (spacing = 2), toJson(object, spacing)
            }
        }

        function limitToFilter() {
            return function (input, limit, begin) {
                return limit = Math.abs(Number(limit)) === 1 / 0 ? Number(limit) : toInt(limit), isNaN(limit) ? input : (isNumber(input) && (input = input.toString()), isArrayLike(input) ? (begin = !begin || isNaN(begin) ? 0 : toInt(begin), begin = 0 > begin ? Math.max(0, input.length + begin) : begin, limit >= 0 ? sliceFn(input, begin, begin + limit) : 0 === begin ? sliceFn(input, limit, input.length) : sliceFn(input, Math.max(0, begin + limit), begin)) : input)
            }
        }

        function sliceFn(input, begin, end) {
            return isString(input) ? input.slice(begin, end) : slice.call(input, begin, end)
        }

        function orderByFilter($parse) {
            function processPredicates(sortPredicates) {
                return sortPredicates.map(function (predicate) {
                    var descending = 1, get = identity;
                    if (isFunction(predicate)) get = predicate; else if (isString(predicate) && (("+" == predicate.charAt(0) || "-" == predicate.charAt(0)) && (descending = "-" == predicate.charAt(0) ? -1 : 1, predicate = predicate.substring(1)), "" !== predicate && (get = $parse(predicate), get.constant))) {
                        var key = get();
                        get = function (value) {
                            return value[key]
                        }
                    }
                    return {get: get, descending: descending}
                })
            }

            function isPrimitive(value) {
                switch (typeof value) {
                    case"number":
                    case"boolean":
                    case"string":
                        return !0;
                    default:
                        return !1
                }
            }

            function objectValue(value) {
                return isFunction(value.valueOf) && (value = value.valueOf(), isPrimitive(value)) ? value : hasCustomToString(value) && (value = value.toString(), isPrimitive(value)) ? value : value
            }

            function getPredicateValue(value, index) {
                var type = typeof value;
                return null === value ? (type = "string", value = "null") : "object" === type && (value = objectValue(value)), {
                    value: value,
                    type: type,
                    index: index
                }
            }

            function defaultCompare(v1, v2) {
                var result = 0, type1 = v1.type, type2 = v2.type;
                if (type1 === type2) {
                    var value1 = v1.value, value2 = v2.value;
                    "string" === type1 ? (value1 = value1.toLowerCase(), value2 = value2.toLowerCase()) : "object" === type1 && (isObject(value1) && (value1 = v1.index), isObject(value2) && (value2 = v2.index)), value1 !== value2 && (result = value2 > value1 ? -1 : 1)
                } else result = type2 > type1 ? -1 : 1;
                return result
            }

            return function (array, sortPredicate, reverseOrder, compareFn) {
                function getComparisonObject(value, index) {
                    return {
                        value: value,
                        tieBreaker: {value: index, type: "number", index: index},
                        predicateValues: predicates.map(function (predicate) {
                            return getPredicateValue(predicate.get(value), index)
                        })
                    }
                }

                function doComparison(v1, v2) {
                    for (var i = 0, ii = predicates.length; ii > i; i++) {
                        var result = compare(v1.predicateValues[i], v2.predicateValues[i]);
                        if (result)return result * predicates[i].descending * descending
                    }
                    return compare(v1.tieBreaker, v2.tieBreaker) * descending
                }

                if (null == array)return array;
                if (!isArrayLike(array))throw minErr("orderBy")("notarray", "Expected array but received: {0}", array);
                isArray(sortPredicate) || (sortPredicate = [sortPredicate]), 0 === sortPredicate.length && (sortPredicate = ["+"]);
                var predicates = processPredicates(sortPredicate), descending = reverseOrder ? -1 : 1, compare = isFunction(compareFn) ? compareFn : defaultCompare, compareValues = Array.prototype.map.call(array, getComparisonObject);
                return compareValues.sort(doComparison), array = compareValues.map(function (item) {
                    return item.value
                })
            }
        }

        function ngDirective(directive) {
            return isFunction(directive) && (directive = {link: directive}), directive.restrict = directive.restrict || "AC", valueFn(directive)
        }

        function nullFormRenameControl(control, name) {
            control.$name = name
        }

        function FormController(element, attrs, $scope, $animate, $interpolate) {
            var form = this, controls = [];
            form.$error = {}, form.$$success = {}, form.$pending = void 0, form.$name = $interpolate(attrs.name || attrs.ngForm || "")($scope), form.$dirty = !1, form.$pristine = !0, form.$valid = !0, form.$invalid = !1, form.$submitted = !1, form.$$parentForm = nullFormCtrl, form.$rollbackViewValue = function () {
                forEach(controls, function (control) {
                    control.$rollbackViewValue()
                })
            }, form.$commitViewValue = function () {
                forEach(controls, function (control) {
                    control.$commitViewValue()
                })
            }, form.$addControl = function (control) {
                assertNotHasOwnProperty(control.$name, "input"), controls.push(control), control.$name && (form[control.$name] = control), control.$$parentForm = form
            }, form.$$renameControl = function (control, newName) {
                var oldName = control.$name;
                form[oldName] === control && delete form[oldName], form[newName] = control, control.$name = newName
            }, form.$removeControl = function (control) {
                control.$name && form[control.$name] === control && delete form[control.$name], forEach(form.$pending, function (value, name) {
                    form.$setValidity(name, null, control)
                }), forEach(form.$error, function (value, name) {
                    form.$setValidity(name, null, control)
                }), forEach(form.$$success, function (value, name) {
                    form.$setValidity(name, null, control)
                }), arrayRemove(controls, control), control.$$parentForm = nullFormCtrl
            }, addSetValidityMethod({
                ctrl: this, $element: element, set: function (object, property, controller) {
                    var list = object[property];
                    if (list) {
                        var index = list.indexOf(controller);
                        -1 === index && list.push(controller)
                    } else object[property] = [controller]
                }, unset: function (object, property, controller) {
                    var list = object[property];
                    list && (arrayRemove(list, controller), 0 === list.length && delete object[property])
                }, $animate: $animate
            }), form.$setDirty = function () {
                $animate.removeClass(element, PRISTINE_CLASS), $animate.addClass(element, DIRTY_CLASS), form.$dirty = !0, form.$pristine = !1, form.$$parentForm.$setDirty()
            }, form.$setPristine = function () {
                $animate.setClass(element, PRISTINE_CLASS, DIRTY_CLASS + " " + SUBMITTED_CLASS), form.$dirty = !1, form.$pristine = !0, form.$submitted = !1, forEach(controls, function (control) {
                    control.$setPristine()
                })
            }, form.$setUntouched = function () {
                forEach(controls, function (control) {
                    control.$setUntouched()
                })
            }, form.$setSubmitted = function () {
                $animate.addClass(element, SUBMITTED_CLASS), form.$submitted = !0, form.$$parentForm.$setSubmitted()
            }
        }

        function stringBasedInputType(ctrl) {
            ctrl.$formatters.push(function (value) {
                return ctrl.$isEmpty(value) ? value : value.toString()
            })
        }

        function textInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl)
        }

        function baseInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            var type = lowercase(element[0].type);
            if (!$sniffer.android) {
                var composing = !1;
                element.on("compositionstart", function () {
                    composing = !0
                }), element.on("compositionend", function () {
                    composing = !1, listener()
                })
            }
            var timeout, listener = function (ev) {
                if (timeout && ($browser.defer.cancel(timeout), timeout = null), !composing) {
                    var value = element.val(), event = ev && ev.type;
                    "password" === type || attr.ngTrim && "false" === attr.ngTrim || (value = trim(value)), (ctrl.$viewValue !== value || "" === value && ctrl.$$hasNativeValidators) && ctrl.$setViewValue(value, event)
                }
            };
            if ($sniffer.hasEvent("input")) element.on("input", listener); else {
                var deferListener = function (ev, input, origValue) {
                    timeout || (timeout = $browser.defer(function () {
                        timeout = null, input && input.value === origValue || listener(ev)
                    }))
                };
                element.on("keydown", function (event) {
                    var key = event.keyCode;
                    91 === key || key > 15 && 19 > key || key >= 37 && 40 >= key || deferListener(event, this, this.value)
                }), $sniffer.hasEvent("paste") && element.on("paste cut", deferListener)
            }
            element.on("change", listener), PARTIAL_VALIDATION_TYPES[type] && ctrl.$$hasNativeValidators && type === attr.type && element.on(PARTIAL_VALIDATION_EVENTS, function (ev) {
                if (!timeout) {
                    var validity = this[VALIDITY_STATE_PROPERTY], origBadInput = validity.badInput, origTypeMismatch = validity.typeMismatch;
                    timeout = $browser.defer(function () {
                        timeout = null, (validity.badInput !== origBadInput || validity.typeMismatch !== origTypeMismatch) && listener(ev)
                    })
                }
            }), ctrl.$render = function () {
                var value = ctrl.$isEmpty(ctrl.$viewValue) ? "" : ctrl.$viewValue;
                element.val() !== value && element.val(value)
            }
        }

        function weekParser(isoWeek, existingDate) {
            if (isDate(isoWeek))return isoWeek;
            if (isString(isoWeek)) {
                WEEK_REGEXP.lastIndex = 0;
                var parts = WEEK_REGEXP.exec(isoWeek);
                if (parts) {
                    var year = +parts[1], week = +parts[2], hours = 0, minutes = 0, seconds = 0, milliseconds = 0, firstThurs = getFirstThursdayOfYear(year), addDays = 7 * (week - 1);
                    return existingDate && (hours = existingDate.getHours(), minutes = existingDate.getMinutes(), seconds = existingDate.getSeconds(), milliseconds = existingDate.getMilliseconds()), new Date(year, 0, firstThurs.getDate() + addDays, hours, minutes, seconds, milliseconds)
                }
            }
            return NaN
        }

        function createDateParser(regexp, mapping) {
            return function (iso, date) {
                var parts, map;
                if (isDate(iso))return iso;
                if (isString(iso)) {
                    if ('"' == iso.charAt(0) && '"' == iso.charAt(iso.length - 1) && (iso = iso.substring(1, iso.length - 1)), ISO_DATE_REGEXP.test(iso))return new Date(iso);
                    if (regexp.lastIndex = 0, parts = regexp.exec(iso))return parts.shift(), map = date ? {
                            yyyy: date.getFullYear(),
                            MM: date.getMonth() + 1,
                            dd: date.getDate(),
                            HH: date.getHours(),
                            mm: date.getMinutes(),
                            ss: date.getSeconds(),
                            sss: date.getMilliseconds() / 1e3
                        } : {
                            yyyy: 1970,
                            MM: 1,
                            dd: 1,
                            HH: 0,
                            mm: 0,
                            ss: 0,
                            sss: 0
                        }, forEach(parts, function (part, index) {
                        index < mapping.length && (map[mapping[index]] = +part)
                    }), new Date(map.yyyy, map.MM - 1, map.dd, map.HH, map.mm, map.ss || 0, 1e3 * map.sss || 0)
                }
                return NaN
            }
        }

        function createDateInputType(type, regexp, parseDate, format) {
            return function (scope, element, attr, ctrl, $sniffer, $browser, $filter) {
                function isValidDate(value) {
                    return value && !(value.getTime && value.getTime() !== value.getTime())
                }

                function parseObservedDateValue(val) {
                    return isDefined(val) && !isDate(val) ? parseDate(val) || void 0 : val
                }

                badInputChecker(scope, element, attr, ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser);
                var previousDate, timezone = ctrl && ctrl.$options && ctrl.$options.timezone;
                if (ctrl.$$parserName = type, ctrl.$parsers.push(function (value) {
                        if (ctrl.$isEmpty(value))return null;
                        if (regexp.test(value)) {
                            var parsedDate = parseDate(value, previousDate);
                            return timezone && (parsedDate = convertTimezoneToLocal(parsedDate, timezone)), parsedDate
                        }
                        return void 0
                    }), ctrl.$formatters.push(function (value) {
                        if (value && !isDate(value))throw ngModelMinErr("datefmt", "Expected `{0}` to be a date", value);
                        return isValidDate(value) ? (previousDate = value, previousDate && timezone && (previousDate = convertTimezoneToLocal(previousDate, timezone, !0)), $filter("date")(value, format, timezone)) : (previousDate = null, "")
                    }), isDefined(attr.min) || attr.ngMin) {
                    var minVal;
                    ctrl.$validators.min = function (value) {
                        return !isValidDate(value) || isUndefined(minVal) || parseDate(value) >= minVal
                    }, attr.$observe("min", function (val) {
                        minVal = parseObservedDateValue(val), ctrl.$validate()
                    })
                }
                if (isDefined(attr.max) || attr.ngMax) {
                    var maxVal;
                    ctrl.$validators.max = function (value) {
                        return !isValidDate(value) || isUndefined(maxVal) || parseDate(value) <= maxVal
                    }, attr.$observe("max", function (val) {
                        maxVal = parseObservedDateValue(val), ctrl.$validate()
                    })
                }
            }
        }

        function badInputChecker(scope, element, attr, ctrl) {
            var node = element[0], nativeValidation = ctrl.$$hasNativeValidators = isObject(node.validity);
            nativeValidation && ctrl.$parsers.push(function (value) {
                var validity = element.prop(VALIDITY_STATE_PROPERTY) || {};
                return validity.badInput || validity.typeMismatch ? void 0 : value
            })
        }

        function numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            if (badInputChecker(scope, element, attr, ctrl), baseInputType(scope, element, attr, ctrl, $sniffer, $browser), ctrl.$$parserName = "number", ctrl.$parsers.push(function (value) {
                    return ctrl.$isEmpty(value) ? null : NUMBER_REGEXP.test(value) ? parseFloat(value) : void 0;
                }), ctrl.$formatters.push(function (value) {
                    if (!ctrl.$isEmpty(value)) {
                        if (!isNumber(value))throw ngModelMinErr("numfmt", "Expected `{0}` to be a number", value);
                        value = value.toString()
                    }
                    return value
                }), isDefined(attr.min) || attr.ngMin) {
                var minVal;
                ctrl.$validators.min = function (value) {
                    return ctrl.$isEmpty(value) || isUndefined(minVal) || value >= minVal
                }, attr.$observe("min", function (val) {
                    isDefined(val) && !isNumber(val) && (val = parseFloat(val)), minVal = isNumber(val) && !isNaN(val) ? val : void 0, ctrl.$validate()
                })
            }
            if (isDefined(attr.max) || attr.ngMax) {
                var maxVal;
                ctrl.$validators.max = function (value) {
                    return ctrl.$isEmpty(value) || isUndefined(maxVal) || maxVal >= value
                }, attr.$observe("max", function (val) {
                    isDefined(val) && !isNumber(val) && (val = parseFloat(val)), maxVal = isNumber(val) && !isNaN(val) ? val : void 0, ctrl.$validate()
                })
            }
        }

        function urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), ctrl.$$parserName = "url", ctrl.$validators.url = function (modelValue, viewValue) {
                var value = modelValue || viewValue;
                return ctrl.$isEmpty(value) || URL_REGEXP.test(value)
            }
        }

        function emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {
            baseInputType(scope, element, attr, ctrl, $sniffer, $browser), stringBasedInputType(ctrl), ctrl.$$parserName = "email", ctrl.$validators.email = function (modelValue, viewValue) {
                var value = modelValue || viewValue;
                return ctrl.$isEmpty(value) || EMAIL_REGEXP.test(value)
            }
        }

        function radioInputType(scope, element, attr, ctrl) {
            isUndefined(attr.name) && element.attr("name", nextUid());
            var listener = function (ev) {
                element[0].checked && ctrl.$setViewValue(attr.value, ev && ev.type)
            };
            element.on("click", listener), ctrl.$render = function () {
                var value = attr.value;
                element[0].checked = value == ctrl.$viewValue
            }, attr.$observe("value", ctrl.$render)
        }

        function parseConstantExpr($parse, context, name, expression, fallback) {
            var parseFn;
            if (isDefined(expression)) {
                if (parseFn = $parse(expression), !parseFn.constant)throw ngModelMinErr("constexpr", "Expected constant expression for `{0}`, but saw `{1}`.", name, expression);
                return parseFn(context)
            }
            return fallback
        }

        function checkboxInputType(scope, element, attr, ctrl, $sniffer, $browser, $filter, $parse) {
            var trueValue = parseConstantExpr($parse, scope, "ngTrueValue", attr.ngTrueValue, !0), falseValue = parseConstantExpr($parse, scope, "ngFalseValue", attr.ngFalseValue, !1), listener = function (ev) {
                ctrl.$setViewValue(element[0].checked, ev && ev.type)
            };
            element.on("click", listener), ctrl.$render = function () {
                element[0].checked = ctrl.$viewValue
            }, ctrl.$isEmpty = function (value) {
                return value === !1
            }, ctrl.$formatters.push(function (value) {
                return equals(value, trueValue)
            }), ctrl.$parsers.push(function (value) {
                return value ? trueValue : falseValue
            })
        }

        function classDirective(name, selector) {
            return name = "ngClass" + name, ["$animate", function ($animate) {
                function arrayDifference(tokens1, tokens2) {
                    var values = [];
                    outer:for (var i = 0; i < tokens1.length; i++) {
                        for (var token = tokens1[i], j = 0; j < tokens2.length; j++)if (token == tokens2[j])continue outer;
                        values.push(token)
                    }
                    return values
                }

                function arrayClasses(classVal) {
                    var classes = [];
                    return isArray(classVal) ? (forEach(classVal, function (v) {
                            classes = classes.concat(arrayClasses(v))
                        }), classes) : isString(classVal) ? classVal.split(" ") : isObject(classVal) ? (forEach(classVal, function (v, k) {
                                    v && (classes = classes.concat(k.split(" ")))
                                }), classes) : classVal
                }

                return {
                    restrict: "AC", link: function (scope, element, attr) {
                        function addClasses(classes) {
                            var newClasses = digestClassCounts(classes, 1);
                            attr.$addClass(newClasses)
                        }

                        function removeClasses(classes) {
                            var newClasses = digestClassCounts(classes, -1);
                            attr.$removeClass(newClasses)
                        }

                        function digestClassCounts(classes, count) {
                            var classCounts = element.data("$classCounts") || createMap(), classesToUpdate = [];
                            return forEach(classes, function (className) {
                                (count > 0 || classCounts[className]) && (classCounts[className] = (classCounts[className] || 0) + count, classCounts[className] === +(count > 0) && classesToUpdate.push(className))
                            }), element.data("$classCounts", classCounts), classesToUpdate.join(" ")
                        }

                        function updateClasses(oldClasses, newClasses) {
                            var toAdd = arrayDifference(newClasses, oldClasses), toRemove = arrayDifference(oldClasses, newClasses);
                            toAdd = digestClassCounts(toAdd, 1), toRemove = digestClassCounts(toRemove, -1), toAdd && toAdd.length && $animate.addClass(element, toAdd), toRemove && toRemove.length && $animate.removeClass(element, toRemove)
                        }

                        function ngClassWatchAction(newVal) {
                            if (selector === !0 || (1 & scope.$index) === selector) {
                                var newClasses = arrayClasses(newVal || []);
                                if (oldVal) {
                                    if (!equals(newVal, oldVal)) {
                                        var oldClasses = arrayClasses(oldVal);
                                        updateClasses(oldClasses, newClasses)
                                    }
                                } else addClasses(newClasses)
                            }
                            oldVal = isArray(newVal) ? newVal.map(function (v) {
                                    return shallowCopy(v)
                                }) : shallowCopy(newVal)
                        }

                        var oldVal;
                        scope.$watch(attr[name], ngClassWatchAction, !0), attr.$observe("class", function (value) {
                            ngClassWatchAction(scope.$eval(attr[name]))
                        }), "ngClass" !== name && scope.$watch("$index", function ($index, old$index) {
                            var mod = 1 & $index;
                            if (mod !== (1 & old$index)) {
                                var classes = arrayClasses(scope.$eval(attr[name]));
                                mod === selector ? addClasses(classes) : removeClasses(classes)
                            }
                        })
                    }
                }
            }]
        }

        function addSetValidityMethod(context) {
            function setValidity(validationErrorKey, state, controller) {
                isUndefined(state) ? createAndSet("$pending", validationErrorKey, controller) : unsetAndCleanup("$pending", validationErrorKey, controller), isBoolean(state) ? state ? (unset(ctrl.$error, validationErrorKey, controller), set(ctrl.$$success, validationErrorKey, controller)) : (set(ctrl.$error, validationErrorKey, controller), unset(ctrl.$$success, validationErrorKey, controller)) : (unset(ctrl.$error, validationErrorKey, controller), unset(ctrl.$$success, validationErrorKey, controller)), ctrl.$pending ? (cachedToggleClass(PENDING_CLASS, !0), ctrl.$valid = ctrl.$invalid = void 0, toggleValidationCss("", null)) : (cachedToggleClass(PENDING_CLASS, !1), ctrl.$valid = isObjectEmpty(ctrl.$error), ctrl.$invalid = !ctrl.$valid, toggleValidationCss("", ctrl.$valid));
                var combinedState;
                combinedState = ctrl.$pending && ctrl.$pending[validationErrorKey] ? void 0 : ctrl.$error[validationErrorKey] ? !1 : ctrl.$$success[validationErrorKey] ? !0 : null, toggleValidationCss(validationErrorKey, combinedState), ctrl.$$parentForm.$setValidity(validationErrorKey, combinedState, ctrl)
            }

            function createAndSet(name, value, controller) {
                ctrl[name] || (ctrl[name] = {}), set(ctrl[name], value, controller)
            }

            function unsetAndCleanup(name, value, controller) {
                ctrl[name] && unset(ctrl[name], value, controller), isObjectEmpty(ctrl[name]) && (ctrl[name] = void 0)
            }

            function cachedToggleClass(className, switchValue) {
                switchValue && !classCache[className] ? ($animate.addClass($element, className), classCache[className] = !0) : !switchValue && classCache[className] && ($animate.removeClass($element, className), classCache[className] = !1)
            }

            function toggleValidationCss(validationErrorKey, isValid) {
                validationErrorKey = validationErrorKey ? "-" + snake_case(validationErrorKey, "-") : "", cachedToggleClass(VALID_CLASS + validationErrorKey, isValid === !0), cachedToggleClass(INVALID_CLASS + validationErrorKey, isValid === !1)
            }

            var ctrl = context.ctrl, $element = context.$element, classCache = {}, set = context.set, unset = context.unset, $animate = context.$animate;
            classCache[INVALID_CLASS] = !(classCache[VALID_CLASS] = $element.hasClass(VALID_CLASS)), ctrl.$setValidity = setValidity
        }

        function isObjectEmpty(obj) {
            if (obj)for (var prop in obj)if (obj.hasOwnProperty(prop))return !1;
            return !0
        }

        function chromeHack(optionElement) {
            optionElement[0].hasAttribute("selected") && (optionElement[0].selected = !0)
        }

        var REGEX_STRING_REGEXP = /^\/(.+)\/([a-z]*)$/, VALIDITY_STATE_PROPERTY = "validity", hasOwnProperty = Object.prototype.hasOwnProperty, lowercase = function (string) {
            return isString(string) ? string.toLowerCase() : string
        }, uppercase = function (string) {
            return isString(string) ? string.toUpperCase() : string
        }, manualLowercase = function (s) {
            return isString(s) ? s.replace(/[A-Z]/g, function (ch) {
                    return String.fromCharCode(32 | ch.charCodeAt(0))
                }) : s
        }, manualUppercase = function (s) {
            return isString(s) ? s.replace(/[a-z]/g, function (ch) {
                    return String.fromCharCode(-33 & ch.charCodeAt(0))
                }) : s
        };
        "i" !== "I".toLowerCase() && (lowercase = manualLowercase, uppercase = manualUppercase);
        var msie, jqLite, jQuery, angularModule, slice = [].slice, splice = [].splice, push = [].push, toString = Object.prototype.toString, getPrototypeOf = Object.getPrototypeOf, ngMinErr = minErr("ng"), angular = window.angular || (window.angular = {}), uid = 0;
        msie = window.document.documentMode, noop.$inject = [], identity.$inject = [];
        var isArray = Array.isArray, TYPED_ARRAY_REGEXP = /^\[object (?:Uint8|Uint8Clamped|Uint16|Uint32|Int8|Int16|Int32|Float32|Float64)Array\]$/, trim = function (value) {
            return isString(value) ? value.trim() : value
        }, escapeForRegexp = function (s) {
            return s.replace(/([-()\[\]{}+?*.$\^|,:#<!\\])/g, "\\$1").replace(/\x08/g, "\\x08")
        }, csp = function () {
            function noUnsafeEval() {
                try {
                    return new Function(""), !1
                } catch (e) {
                    return !0
                }
            }

            if (!isDefined(csp.rules)) {
                var ngCspElement = window.document.querySelector("[ng-csp]") || window.document.querySelector("[data-ng-csp]");
                if (ngCspElement) {
                    var ngCspAttribute = ngCspElement.getAttribute("ng-csp") || ngCspElement.getAttribute("data-ng-csp");
                    csp.rules = {
                        noUnsafeEval: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-unsafe-eval"),
                        noInlineStyle: !ngCspAttribute || -1 !== ngCspAttribute.indexOf("no-inline-style")
                    }
                } else csp.rules = {noUnsafeEval: noUnsafeEval(), noInlineStyle: !1}
            }
            return csp.rules
        }, jq = function () {
            if (isDefined(jq.name_))return jq.name_;
            var el, i, prefix, name, ii = ngAttrPrefixes.length;
            for (i = 0; ii > i; ++i)if (prefix = ngAttrPrefixes[i], el = window.document.querySelector("[" + prefix.replace(":", "\\:") + "jq]")) {
                name = el.getAttribute(prefix + "jq");
                break
            }
            return jq.name_ = name
        }, ALL_COLONS = /:/g, ngAttrPrefixes = ["ng-", "data-ng-", "ng:", "x-ng-"], SNAKE_CASE_REGEXP = /[A-Z]/g, bindJQueryFired = !1, NODE_TYPE_ELEMENT = 1, NODE_TYPE_ATTRIBUTE = 2, NODE_TYPE_TEXT = 3, NODE_TYPE_COMMENT = 8, NODE_TYPE_DOCUMENT = 9, NODE_TYPE_DOCUMENT_FRAGMENT = 11, version = {
            full: "1.5.8",
            major: 1,
            minor: 5,
            dot: 8,
            codeName: "arbitrary-fallbacks"
        };
        JQLite.expando = "ng339";
        var jqCache = JQLite.cache = {}, jqId = 1, addEventListenerFn = function (element, type, fn) {
            element.addEventListener(type, fn, !1)
        }, removeEventListenerFn = function (element, type, fn) {
            element.removeEventListener(type, fn, !1)
        };
        JQLite._data = function (node) {
            return this.cache[node[this.expando]] || {}
        };
        var SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g, MOZ_HACK_REGEXP = /^moz([A-Z])/, MOUSE_EVENT_MAP = {
            mouseleave: "mouseout",
            mouseenter: "mouseover"
        }, jqLiteMinErr = minErr("jqLite"), SINGLE_TAG_REGEXP = /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/, HTML_REGEXP = /<|&#?\w+;/, TAG_NAME_REGEXP = /<([\w:-]+)/, XHTML_TAG_REGEXP = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi, wrapMap = {
            option: [1, '<select multiple="multiple">', "</select>"],
            thead: [1, "<table>", "</table>"],
            col: [2, "<table><colgroup>", "</colgroup></table>"],
            tr: [2, "<table><tbody>", "</tbody></table>"],
            td: [3, "<table><tbody><tr>", "</tr></tbody></table>"],
            _default: [0, "", ""]
        };
        wrapMap.optgroup = wrapMap.option, wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead, wrapMap.th = wrapMap.td;
        var jqLiteContains = window.Node.prototype.contains || function (arg) {
                return !!(16 & this.compareDocumentPosition(arg))
            }, JQLitePrototype = JQLite.prototype = {
            ready: function (fn) {
                function trigger() {
                    fired || (fired = !0, fn())
                }

                var fired = !1;
                "complete" === window.document.readyState ? window.setTimeout(trigger) : (this.on("DOMContentLoaded", trigger), JQLite(window).on("load", trigger))
            }, toString: function () {
                var value = [];
                return forEach(this, function (e) {
                    value.push("" + e)
                }), "[" + value.join(", ") + "]"
            }, eq: function (index) {
                return jqLite(index >= 0 ? this[index] : this[this.length + index])
            }, length: 0, push: push, sort: [].sort, splice: [].splice
        }, BOOLEAN_ATTR = {};
        forEach("multiple,selected,checked,disabled,readOnly,required,open".split(","), function (value) {
            BOOLEAN_ATTR[lowercase(value)] = value
        });
        var BOOLEAN_ELEMENTS = {};
        forEach("input,select,option,textarea,button,form,details".split(","), function (value) {
            BOOLEAN_ELEMENTS[value] = !0
        });
        var ALIASED_ATTR = {
            ngMinlength: "minlength",
            ngMaxlength: "maxlength",
            ngMin: "min",
            ngMax: "max",
            ngPattern: "pattern"
        };
        forEach({
            data: jqLiteData,
            removeData: jqLiteRemoveData,
            hasData: jqLiteHasData,
            cleanData: jqLiteCleanData
        }, function (fn, name) {
            JQLite[name] = fn
        }), forEach({
            data: jqLiteData, inheritedData: jqLiteInheritedData, scope: function (element) {
                return jqLite.data(element, "$scope") || jqLiteInheritedData(element.parentNode || element, ["$isolateScope", "$scope"])
            }, isolateScope: function (element) {
                return jqLite.data(element, "$isolateScope") || jqLite.data(element, "$isolateScopeNoTemplate")
            }, controller: jqLiteController, injector: function (element) {
                return jqLiteInheritedData(element, "$injector")
            }, removeAttr: function (element, name) {
                element.removeAttribute(name)
            }, hasClass: jqLiteHasClass, css: function (element, name, value) {
                return name = camelCase(name), isDefined(value) ? void(element.style[name] = value) : element.style[name]
            }, attr: function (element, name, value) {
                var nodeType = element.nodeType;
                if (nodeType !== NODE_TYPE_TEXT && nodeType !== NODE_TYPE_ATTRIBUTE && nodeType !== NODE_TYPE_COMMENT) {
                    var lowercasedName = lowercase(name);
                    if (BOOLEAN_ATTR[lowercasedName]) {
                        if (!isDefined(value))return element[name] || (element.attributes.getNamedItem(name) || noop).specified ? lowercasedName : void 0;
                        value ? (element[name] = !0, element.setAttribute(name, lowercasedName)) : (element[name] = !1, element.removeAttribute(lowercasedName))
                    } else if (isDefined(value)) element.setAttribute(name, value); else if (element.getAttribute) {
                        var ret = element.getAttribute(name, 2);
                        return null === ret ? void 0 : ret
                    }
                }
            }, prop: function (element, name, value) {
                return isDefined(value) ? void(element[name] = value) : element[name]
            }, text: function () {
                function getText(element, value) {
                    if (isUndefined(value)) {
                        var nodeType = element.nodeType;
                        return nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_TEXT ? element.textContent : ""
                    }
                    element.textContent = value
                }

                return getText.$dv = "", getText
            }(), val: function (element, value) {
                if (isUndefined(value)) {
                    if (element.multiple && "select" === nodeName_(element)) {
                        var result = [];
                        return forEach(element.options, function (option) {
                            option.selected && result.push(option.value || option.text)
                        }), 0 === result.length ? null : result
                    }
                    return element.value
                }
                element.value = value
            }, html: function (element, value) {
                return isUndefined(value) ? element.innerHTML : (jqLiteDealoc(element, !0), void(element.innerHTML = value))
            }, empty: jqLiteEmpty
        }, function (fn, name) {
            JQLite.prototype[name] = function (arg1, arg2) {
                var i, key, nodeCount = this.length;
                if (fn !== jqLiteEmpty && isUndefined(2 == fn.length && fn !== jqLiteHasClass && fn !== jqLiteController ? arg1 : arg2)) {
                    if (isObject(arg1)) {
                        for (i = 0; nodeCount > i; i++)if (fn === jqLiteData) fn(this[i], arg1); else for (key in arg1)fn(this[i], key, arg1[key]);
                        return this
                    }
                    for (var value = fn.$dv, jj = isUndefined(value) ? Math.min(nodeCount, 1) : nodeCount, j = 0; jj > j; j++) {
                        var nodeValue = fn(this[j], arg1, arg2);
                        value = value ? value + nodeValue : nodeValue
                    }
                    return value
                }
                for (i = 0; nodeCount > i; i++)fn(this[i], arg1, arg2);
                return this
            }
        }), forEach({
            removeData: jqLiteRemoveData,
            on: function (element, type, fn, unsupported) {
                if (isDefined(unsupported))throw jqLiteMinErr("onargs", "jqLite#on() does not support the `selector` or `eventData` parameters");
                if (jqLiteAcceptsData(element)) {
                    var expandoStore = jqLiteExpandoStore(element, !0), events = expandoStore.events, handle = expandoStore.handle;
                    handle || (handle = expandoStore.handle = createEventHandler(element, events));
                    for (var types = type.indexOf(" ") >= 0 ? type.split(" ") : [type], i = types.length, addHandler = function (type, specialHandlerWrapper, noEventListener) {
                        var eventFns = events[type];
                        eventFns || (eventFns = events[type] = [], eventFns.specialHandlerWrapper = specialHandlerWrapper, "$destroy" === type || noEventListener || addEventListenerFn(element, type, handle)), eventFns.push(fn)
                    }; i--;)type = types[i], MOUSE_EVENT_MAP[type] ? (addHandler(MOUSE_EVENT_MAP[type], specialMouseHandlerWrapper), addHandler(type, void 0, !0)) : addHandler(type)
                }
            },
            off: jqLiteOff,
            one: function (element, type, fn) {
                element = jqLite(element), element.on(type, function onFn() {
                    element.off(type, fn), element.off(type, onFn)
                }), element.on(type, fn)
            },
            replaceWith: function (element, replaceNode) {
                var index, parent = element.parentNode;
                jqLiteDealoc(element), forEach(new JQLite(replaceNode), function (node) {
                    index ? parent.insertBefore(node, index.nextSibling) : parent.replaceChild(node, element), index = node
                })
            },
            children: function (element) {
                var children = [];
                return forEach(element.childNodes, function (element) {
                    element.nodeType === NODE_TYPE_ELEMENT && children.push(element)
                }), children
            },
            contents: function (element) {
                return element.contentDocument || element.childNodes || []
            },
            append: function (element, node) {
                var nodeType = element.nodeType;
                if (nodeType === NODE_TYPE_ELEMENT || nodeType === NODE_TYPE_DOCUMENT_FRAGMENT) {
                    node = new JQLite(node);
                    for (var i = 0, ii = node.length; ii > i; i++) {
                        var child = node[i];
                        element.appendChild(child)
                    }
                }
            },
            prepend: function (element, node) {
                if (element.nodeType === NODE_TYPE_ELEMENT) {
                    var index = element.firstChild;
                    forEach(new JQLite(node), function (child) {
                        element.insertBefore(child, index)
                    })
                }
            },
            wrap: function (element, wrapNode) {
                jqLiteWrapNode(element, jqLite(wrapNode).eq(0).clone()[0])
            },
            remove: jqLiteRemove,
            detach: function (element) {
                jqLiteRemove(element, !0)
            },
            after: function (element, newElement) {
                var index = element, parent = element.parentNode;
                newElement = new JQLite(newElement);
                for (var i = 0, ii = newElement.length; ii > i; i++) {
                    var node = newElement[i];
                    parent.insertBefore(node, index.nextSibling), index = node
                }
            },
            addClass: jqLiteAddClass,
            removeClass: jqLiteRemoveClass,
            toggleClass: function (element, selector, condition) {
                selector && forEach(selector.split(" "), function (className) {
                    var classCondition = condition;
                    isUndefined(classCondition) && (classCondition = !jqLiteHasClass(element, className)), (classCondition ? jqLiteAddClass : jqLiteRemoveClass)(element, className)
                })
            },
            parent: function (element) {
                var parent = element.parentNode;
                return parent && parent.nodeType !== NODE_TYPE_DOCUMENT_FRAGMENT ? parent : null
            },
            next: function (element) {
                return element.nextElementSibling
            },
            find: function (element, selector) {
                return element.getElementsByTagName ? element.getElementsByTagName(selector) : []
            },
            clone: jqLiteClone,
            triggerHandler: function (element, event, extraParameters) {
                var dummyEvent, eventFnsCopy, handlerArgs, eventName = event.type || event, expandoStore = jqLiteExpandoStore(element), events = expandoStore && expandoStore.events, eventFns = events && events[eventName];
                eventFns && (dummyEvent = {
                    preventDefault: function () {
                        this.defaultPrevented = !0
                    }, isDefaultPrevented: function () {
                        return this.defaultPrevented === !0
                    }, stopImmediatePropagation: function () {
                        this.immediatePropagationStopped = !0
                    }, isImmediatePropagationStopped: function () {
                        return this.immediatePropagationStopped === !0
                    }, stopPropagation: noop, type: eventName, target: element
                }, event.type && (dummyEvent = extend(dummyEvent, event)), eventFnsCopy = shallowCopy(eventFns), handlerArgs = extraParameters ? [dummyEvent].concat(extraParameters) : [dummyEvent], forEach(eventFnsCopy, function (fn) {
                    dummyEvent.isImmediatePropagationStopped() || fn.apply(element, handlerArgs)
                }))
            }
        }, function (fn, name) {
            JQLite.prototype[name] = function (arg1, arg2, arg3) {
                for (var value, i = 0, ii = this.length; ii > i; i++)isUndefined(value) ? (value = fn(this[i], arg1, arg2, arg3), isDefined(value) && (value = jqLite(value))) : jqLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));
                return isDefined(value) ? value : this
            }, JQLite.prototype.bind = JQLite.prototype.on, JQLite.prototype.unbind = JQLite.prototype.off
        }), HashMap.prototype = {
            put: function (key, value) {
                this[hashKey(key, this.nextUid)] = value
            }, get: function (key) {
                return this[hashKey(key, this.nextUid)]
            }, remove: function (key) {
                var value = this[key = hashKey(key, this.nextUid)];
                return delete this[key], value
            }
        };
        var $$HashMapProvider = [function () {
            this.$get = [function () {
                return HashMap
            }]
        }], ARROW_ARG = /^([^\(]+?)=>/, FN_ARGS = /^[^\(]*\(\s*([^\)]*)\)/m, FN_ARG_SPLIT = /,/, FN_ARG = /^\s*(_?)(\S+?)\1\s*$/, STRIP_COMMENTS = /((\/\/.*$)|(\/\*[\s\S]*?\*\/))/gm, $injectorMinErr = minErr("$injector");
        createInjector.$$annotate = annotate;
        var $animateMinErr = minErr("$animate"), ELEMENT_NODE = 1, NG_ANIMATE_CLASSNAME = "ng-animate", $$CoreAnimateJsProvider = function () {
            this.$get = noop
        }, $$CoreAnimateQueueProvider = function () {
            var postDigestQueue = new HashMap, postDigestElements = [];
            this.$get = ["$$AnimateRunner", "$rootScope", function ($$AnimateRunner, $rootScope) {
                function updateData(data, classes, value) {
                    var changed = !1;
                    return classes && (classes = isString(classes) ? classes.split(" ") : isArray(classes) ? classes : [], forEach(classes, function (className) {
                        className && (changed = !0, data[className] = value)
                    })), changed
                }

                function handleCSSClassChanges() {
                    forEach(postDigestElements, function (element) {
                        var data = postDigestQueue.get(element);
                        if (data) {
                            var existing = splitClasses(element.attr("class")), toAdd = "", toRemove = "";
                            forEach(data, function (status, className) {
                                var hasClass = !!existing[className];
                                status !== hasClass && (status ? toAdd += (toAdd.length ? " " : "") + className : toRemove += (toRemove.length ? " " : "") + className)
                            }), forEach(element, function (elm) {
                                toAdd && jqLiteAddClass(elm, toAdd), toRemove && jqLiteRemoveClass(elm, toRemove)
                            }), postDigestQueue.remove(element)
                        }
                    }), postDigestElements.length = 0
                }

                function addRemoveClassesPostDigest(element, add, remove) {
                    var data = postDigestQueue.get(element) || {}, classesAdded = updateData(data, add, !0), classesRemoved = updateData(data, remove, !1);
                    (classesAdded || classesRemoved) && (postDigestQueue.put(element, data), postDigestElements.push(element), 1 === postDigestElements.length && $rootScope.$$postDigest(handleCSSClassChanges))
                }

                return {
                    enabled: noop,
                    on: noop,
                    off: noop,
                    pin: noop,
                    push: function (element, event, options, domOperation) {
                        domOperation && domOperation(), options = options || {}, options.from && element.css(options.from), options.to && element.css(options.to), (options.addClass || options.removeClass) && addRemoveClassesPostDigest(element, options.addClass, options.removeClass);
                        var runner = new $$AnimateRunner;
                        return runner.complete(), runner
                    }
                }
            }]
        }, $AnimateProvider = ["$provide", function ($provide) {
            var provider = this;
            this.$$registeredAnimations = Object.create(null), this.register = function (name, factory) {
                if (name && "." !== name.charAt(0))throw $animateMinErr("notcsel", "Expecting class selector starting with '.' got '{0}'.", name);
                var key = name + "-animation";
                provider.$$registeredAnimations[name.substr(1)] = key, $provide.factory(key, factory)
            }, this.classNameFilter = function (expression) {
                if (1 === arguments.length && (this.$$classNameFilter = expression instanceof RegExp ? expression : null, this.$$classNameFilter)) {
                    var reservedRegex = new RegExp("(\\s+|\\/)" + NG_ANIMATE_CLASSNAME + "(\\s+|\\/)");
                    if (reservedRegex.test(this.$$classNameFilter.toString()))throw $animateMinErr("nongcls", '$animateProvider.classNameFilter(regex) prohibits accepting a regex value which matches/contains the "{0}" CSS class.', NG_ANIMATE_CLASSNAME)
                }
                return this.$$classNameFilter
            }, this.$get = ["$$animateQueue", function ($$animateQueue) {
                function domInsert(element, parentElement, afterElement) {
                    if (afterElement) {
                        var afterNode = extractElementNode(afterElement);
                        !afterNode || afterNode.parentNode || afterNode.previousElementSibling || (afterElement = null)
                    }
                    afterElement ? afterElement.after(element) : parentElement.prepend(element)
                }

                return {
                    on: $$animateQueue.on,
                    off: $$animateQueue.off,
                    pin: $$animateQueue.pin,
                    enabled: $$animateQueue.enabled,
                    cancel: function (runner) {
                        runner.end && runner.end()
                    },
                    enter: function (element, parent, after, options) {
                        return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), domInsert(element, parent, after), $$animateQueue.push(element, "enter", prepareAnimateOptions(options))
                    },
                    move: function (element, parent, after, options) {
                        return parent = parent && jqLite(parent), after = after && jqLite(after), parent = parent || after.parent(), domInsert(element, parent, after), $$animateQueue.push(element, "move", prepareAnimateOptions(options))
                    },
                    leave: function (element, options) {
                        return $$animateQueue.push(element, "leave", prepareAnimateOptions(options), function () {
                            element.remove()
                        })
                    },
                    addClass: function (element, className, options) {
                        return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addclass, className), $$animateQueue.push(element, "addClass", options)
                    },
                    removeClass: function (element, className, options) {
                        return options = prepareAnimateOptions(options), options.removeClass = mergeClasses(options.removeClass, className), $$animateQueue.push(element, "removeClass", options)
                    },
                    setClass: function (element, add, remove, options) {
                        return options = prepareAnimateOptions(options), options.addClass = mergeClasses(options.addClass, add), options.removeClass = mergeClasses(options.removeClass, remove), $$animateQueue.push(element, "setClass", options)
                    },
                    animate: function (element, from, to, className, options) {
                        return options = prepareAnimateOptions(options), options.from = options.from ? extend(options.from, from) : from, options.to = options.to ? extend(options.to, to) : to, className = className || "ng-inline-animate", options.tempClasses = mergeClasses(options.tempClasses, className), $$animateQueue.push(element, "animate", options)
                    }
                }
            }]
        }], $$AnimateAsyncRunFactoryProvider = function () {
            this.$get = ["$$rAF", function ($$rAF) {
                function waitForTick(fn) {
                    waitQueue.push(fn), waitQueue.length > 1 || $$rAF(function () {
                        for (var i = 0; i < waitQueue.length; i++)waitQueue[i]();
                        waitQueue = []
                    })
                }

                var waitQueue = [];
                return function () {
                    var passed = !1;
                    return waitForTick(function () {
                        passed = !0
                    }), function (callback) {
                        passed ? callback() : waitForTick(callback)
                    }
                }
            }]
        }, $$AnimateRunnerFactoryProvider = function () {
            this.$get = ["$q", "$sniffer", "$$animateAsyncRun", "$document", "$timeout", function ($q, $sniffer, $$animateAsyncRun, $document, $timeout) {
                function AnimateRunner(host) {
                    this.setHost(host);
                    var rafTick = $$animateAsyncRun(), timeoutTick = function (fn) {
                        $timeout(fn, 0, !1)
                    };
                    this._doneCallbacks = [], this._tick = function (fn) {
                        var doc = $document[0];
                        doc && doc.hidden ? timeoutTick(fn) : rafTick(fn)
                    }, this._state = 0
                }

                var INITIAL_STATE = 0, DONE_PENDING_STATE = 1, DONE_COMPLETE_STATE = 2;
                return AnimateRunner.chain = function (chain, callback) {
                    function next() {
                        return index === chain.length ? void callback(!0) : void chain[index](function (response) {
                                return response === !1 ? void callback(!1) : (index++, void next())
                            })
                    }

                    var index = 0;
                    next()
                }, AnimateRunner.all = function (runners, callback) {
                    function onProgress(response) {
                        status = status && response, ++count === runners.length && callback(status)
                    }

                    var count = 0, status = !0;
                    forEach(runners, function (runner) {
                        runner.done(onProgress)
                    })
                }, AnimateRunner.prototype = {
                    setHost: function (host) {
                        this.host = host || {}
                    }, done: function (fn) {
                        this._state === DONE_COMPLETE_STATE ? fn() : this._doneCallbacks.push(fn)
                    }, progress: noop, getPromise: function () {
                        if (!this.promise) {
                            var self = this;
                            this.promise = $q(function (resolve, reject) {
                                self.done(function (status) {
                                    status === !1 ? reject() : resolve()
                                })
                            })
                        }
                        return this.promise
                    }, then: function (resolveHandler, rejectHandler) {
                        return this.getPromise().then(resolveHandler, rejectHandler)
                    }, "catch": function (handler) {
                        return this.getPromise()["catch"](handler)
                    }, "finally": function (handler) {
                        return this.getPromise()["finally"](handler)
                    }, pause: function () {
                        this.host.pause && this.host.pause()
                    }, resume: function () {
                        this.host.resume && this.host.resume()
                    }, end: function () {
                        this.host.end && this.host.end(), this._resolve(!0)
                    }, cancel: function () {
                        this.host.cancel && this.host.cancel(), this._resolve(!1)
                    }, complete: function (response) {
                        var self = this;
                        self._state === INITIAL_STATE && (self._state = DONE_PENDING_STATE, self._tick(function () {
                            self._resolve(response)
                        }))
                    }, _resolve: function (response) {
                        this._state !== DONE_COMPLETE_STATE && (forEach(this._doneCallbacks, function (fn) {
                            fn(response)
                        }), this._doneCallbacks.length = 0, this._state = DONE_COMPLETE_STATE)
                    }
                }, AnimateRunner
            }]
        }, $CoreAnimateCssProvider = function () {
            this.$get = ["$$rAF", "$q", "$$AnimateRunner", function ($$rAF, $q, $$AnimateRunner) {
                return function (element, initialOptions) {
                    function run() {
                        return $$rAF(function () {
                            applyAnimationContents(), closed || runner.complete(), closed = !0
                        }), runner
                    }

                    function applyAnimationContents() {
                        options.addClass && (element.addClass(options.addClass), options.addClass = null), options.removeClass && (element.removeClass(options.removeClass), options.removeClass = null), options.to && (element.css(options.to), options.to = null)
                    }

                    var options = initialOptions || {};
                    options.$$prepared || (options = copy(options)), options.cleanupStyles && (options.from = options.to = null), options.from && (element.css(options.from), options.from = null);
                    var closed, runner = new $$AnimateRunner;
                    return {start: run, end: run}
                }
            }]
        }, $compileMinErr = minErr("$compile"), _UNINITIALIZED_VALUE = new UNINITIALIZED_VALUE;
        $CompileProvider.$inject = ["$provide", "$$sanitizeUriProvider"], SimpleChange.prototype.isFirstChange = function () {
            return this.previousValue === _UNINITIALIZED_VALUE
        };
        var PREFIX_REGEXP = /^((?:x|data)[\:\-_])/i, $controllerMinErr = minErr("$controller"), CNTRL_REG = /^(\S+)(\s+as\s+([\w$]+))?$/, $$ForceReflowProvider = function () {
            this.$get = ["$document", function ($document) {
                return function (domNode) {
                    return domNode ? !domNode.nodeType && domNode instanceof jqLite && (domNode = domNode[0]) : domNode = $document[0].body, domNode.offsetWidth + 1
                }
            }]
        }, APPLICATION_JSON = "application/json", CONTENT_TYPE_APPLICATION_JSON = {"Content-Type": APPLICATION_JSON + ";charset=utf-8"}, JSON_START = /^\[|^\{(?!\{)/, JSON_ENDS = {
            "[": /]$/,
            "{": /}$/
        }, JSON_PROTECTION_PREFIX = /^\)\]\}',?\n/, $httpMinErr = minErr("$http"), $httpMinErrLegacyFn = function (method) {
            return function () {
                throw $httpMinErr("legacy", "The method `{0}` on the promise returned from `$http` has been disabled.", method)
            }
        }, $interpolateMinErr = angular.$interpolateMinErr = minErr("$interpolate");
        $interpolateMinErr.throwNoconcat = function (text) {
            throw $interpolateMinErr("noconcat", "Error while interpolating: {0}\nStrict Contextual Escaping disallows interpolations that concatenate multiple expressions when a trusted value is required.  See http://docs.angularjs.org/api/ng.$sce", text)
        }, $interpolateMinErr.interr = function (text, err) {
            return $interpolateMinErr("interr", "Can't interpolate: {0}\n{1}", text, err.toString())
        };
        var $jsonpCallbacksProvider = function () {
            this.$get = ["$window", function ($window) {
                function createCallback(callbackId) {
                    var callback = function (data) {
                        callback.data = data, callback.called = !0
                    };
                    return callback.id = callbackId, callback
                }

                var callbacks = $window.angular.callbacks, callbackMap = {};
                return {
                    createCallback: function (url) {
                        var callbackId = "_" + (callbacks.$$counter++).toString(36), callbackPath = "angular.callbacks." + callbackId, callback = createCallback(callbackId);
                        return callbackMap[callbackPath] = callbacks[callbackId] = callback, callbackPath
                    }, wasCalled: function (callbackPath) {
                        return callbackMap[callbackPath].called
                    }, getResponse: function (callbackPath) {
                        return callbackMap[callbackPath].data
                    }, removeCallback: function (callbackPath) {
                        var callback = callbackMap[callbackPath];
                        delete callbacks[callback.id], delete callbackMap[callbackPath]
                    }
                }
            }]
        }, PATH_MATCH = /^([^\?#]*)(\?([^#]*))?(#(.*))?$/, DEFAULT_PORTS = {
            http: 80,
            https: 443,
            ftp: 21
        }, $locationMinErr = minErr("$location"), locationPrototype = {
            $$absUrl: "",
            $$html5: !1,
            $$replace: !1,
            absUrl: locationGetter("$$absUrl"),
            url: function (url) {
                if (isUndefined(url))return this.$$url;
                var match = PATH_MATCH.exec(url);
                return (match[1] || "" === url) && this.path(decodeURIComponent(match[1])), (match[2] || match[1] || "" === url) && this.search(match[3] || ""), this.hash(match[5] || ""), this
            },
            protocol: locationGetter("$$protocol"),
            host: locationGetter("$$host"),
            port: locationGetter("$$port"),
            path: locationGetterSetter("$$path", function (path) {
                return path = null !== path ? path.toString() : "", "/" == path.charAt(0) ? path : "/" + path
            }),
            search: function (search, paramValue) {
                switch (arguments.length) {
                    case 0:
                        return this.$$search;
                    case 1:
                        if (isString(search) || isNumber(search)) search = search.toString(), this.$$search = parseKeyValue(search); else {
                            if (!isObject(search))throw $locationMinErr("isrcharg", "The first argument of the `$location#search()` call must be a string or an object.");
                            search = copy(search, {}), forEach(search, function (value, key) {
                                null == value && delete search[key]
                            }), this.$$search = search
                        }
                        break;
                    default:
                        isUndefined(paramValue) || null === paramValue ? delete this.$$search[search] : this.$$search[search] = paramValue
                }
                return this.$$compose(), this
            },
            hash: locationGetterSetter("$$hash", function (hash) {
                return null !== hash ? hash.toString() : ""
            }),
            replace: function () {
                return this.$$replace = !0, this
            }
        };
        forEach([LocationHashbangInHtml5Url, LocationHashbangUrl, LocationHtml5Url], function (Location) {
            Location.prototype = Object.create(locationPrototype), Location.prototype.state = function (state) {
                if (!arguments.length)return this.$$state;
                if (Location !== LocationHtml5Url || !this.$$html5)throw $locationMinErr("nostate", "History API state support is available only in HTML5 mode and only in browsers supporting HTML5 History API");
                return this.$$state = isUndefined(state) ? null : state, this
            }
        });
        var $parseMinErr = minErr("$parse"), CALL = Function.prototype.call, APPLY = Function.prototype.apply, BIND = Function.prototype.bind, OPERATORS = createMap();
        forEach("+ - * / % === !== == != < > <= >= && || ! = |".split(" "), function (operator) {
            OPERATORS[operator] = !0;
        });
        var ESCAPE = {n: "\n", f: "\f", r: "\r", t: "	", v: "", "'": "'", '"': '"'}, Lexer = function (options) {
            this.options = options
        };
        Lexer.prototype = {
            constructor: Lexer, lex: function (text) {
                for (this.text = text, this.index = 0, this.tokens = []; this.index < this.text.length;) {
                    var ch = this.text.charAt(this.index);
                    if ('"' === ch || "'" === ch) this.readString(ch); else if (this.isNumber(ch) || "." === ch && this.isNumber(this.peek())) this.readNumber(); else if (this.isIdentifierStart(this.peekMultichar())) this.readIdent(); else if (this.is(ch, "(){}[].,;:?")) this.tokens.push({
                        index: this.index,
                        text: ch
                    }), this.index++; else if (this.isWhitespace(ch)) this.index++; else {
                        var ch2 = ch + this.peek(), ch3 = ch2 + this.peek(2), op1 = OPERATORS[ch], op2 = OPERATORS[ch2], op3 = OPERATORS[ch3];
                        if (op1 || op2 || op3) {
                            var token = op3 ? ch3 : op2 ? ch2 : ch;
                            this.tokens.push({index: this.index, text: token, operator: !0}), this.index += token.length
                        } else this.throwError("Unexpected next character ", this.index, this.index + 1)
                    }
                }
                return this.tokens
            }, is: function (ch, chars) {
                return -1 !== chars.indexOf(ch)
            }, peek: function (i) {
                var num = i || 1;
                return this.index + num < this.text.length ? this.text.charAt(this.index + num) : !1
            }, isNumber: function (ch) {
                return ch >= "0" && "9" >= ch && "string" == typeof ch
            }, isWhitespace: function (ch) {
                return " " === ch || "\r" === ch || "	" === ch || "\n" === ch || "" === ch || " " === ch
            }, isIdentifierStart: function (ch) {
                return this.options.isIdentifierStart ? this.options.isIdentifierStart(ch, this.codePointAt(ch)) : this.isValidIdentifierStart(ch)
            }, isValidIdentifierStart: function (ch) {
                return ch >= "a" && "z" >= ch || ch >= "A" && "Z" >= ch || "_" === ch || "$" === ch
            }, isIdentifierContinue: function (ch) {
                return this.options.isIdentifierContinue ? this.options.isIdentifierContinue(ch, this.codePointAt(ch)) : this.isValidIdentifierContinue(ch)
            }, isValidIdentifierContinue: function (ch, cp) {
                return this.isValidIdentifierStart(ch, cp) || this.isNumber(ch)
            }, codePointAt: function (ch) {
                return 1 === ch.length ? ch.charCodeAt(0) : (ch.charCodeAt(0) << 10) + ch.charCodeAt(1) - 56613888
            }, peekMultichar: function () {
                var ch = this.text.charAt(this.index), peek = this.peek();
                if (!peek)return ch;
                var cp1 = ch.charCodeAt(0), cp2 = peek.charCodeAt(0);
                return cp1 >= 55296 && 56319 >= cp1 && cp2 >= 56320 && 57343 >= cp2 ? ch + peek : ch
            }, isExpOperator: function (ch) {
                return "-" === ch || "+" === ch || this.isNumber(ch)
            }, throwError: function (error, start, end) {
                end = end || this.index;
                var colStr = isDefined(start) ? "s " + start + "-" + this.index + " [" + this.text.substring(start, end) + "]" : " " + end;
                throw $parseMinErr("lexerr", "Lexer Error: {0} at column{1} in expression [{2}].", error, colStr, this.text)
            }, readNumber: function () {
                for (var number = "", start = this.index; this.index < this.text.length;) {
                    var ch = lowercase(this.text.charAt(this.index));
                    if ("." == ch || this.isNumber(ch)) number += ch; else {
                        var peekCh = this.peek();
                        if ("e" == ch && this.isExpOperator(peekCh)) number += ch; else if (this.isExpOperator(ch) && peekCh && this.isNumber(peekCh) && "e" == number.charAt(number.length - 1)) number += ch; else {
                            if (!this.isExpOperator(ch) || peekCh && this.isNumber(peekCh) || "e" != number.charAt(number.length - 1))break;
                            this.throwError("Invalid exponent")
                        }
                    }
                    this.index++
                }
                this.tokens.push({index: start, text: number, constant: !0, value: Number(number)})
            }, readIdent: function () {
                var start = this.index;
                for (this.index += this.peekMultichar().length; this.index < this.text.length;) {
                    var ch = this.peekMultichar();
                    if (!this.isIdentifierContinue(ch))break;
                    this.index += ch.length
                }
                this.tokens.push({index: start, text: this.text.slice(start, this.index), identifier: !0})
            }, readString: function (quote) {
                var start = this.index;
                this.index++;
                for (var string = "", rawString = quote, escape = !1; this.index < this.text.length;) {
                    var ch = this.text.charAt(this.index);
                    if (rawString += ch, escape) {
                        if ("u" === ch) {
                            var hex = this.text.substring(this.index + 1, this.index + 5);
                            hex.match(/[\da-f]{4}/i) || this.throwError("Invalid unicode escape [\\u" + hex + "]"), this.index += 4, string += String.fromCharCode(parseInt(hex, 16))
                        } else {
                            var rep = ESCAPE[ch];
                            string += rep || ch
                        }
                        escape = !1
                    } else if ("\\" === ch) escape = !0; else {
                        if (ch === quote)return this.index++, void this.tokens.push({
                            index: start,
                            text: rawString,
                            constant: !0,
                            value: string
                        });
                        string += ch
                    }
                    this.index++
                }
                this.throwError("Unterminated quote", start)
            }
        };
        var AST = function (lexer, options) {
            this.lexer = lexer, this.options = options
        };
        AST.Program = "Program", AST.ExpressionStatement = "ExpressionStatement", AST.AssignmentExpression = "AssignmentExpression", AST.ConditionalExpression = "ConditionalExpression", AST.LogicalExpression = "LogicalExpression", AST.BinaryExpression = "BinaryExpression", AST.UnaryExpression = "UnaryExpression", AST.CallExpression = "CallExpression", AST.MemberExpression = "MemberExpression", AST.Identifier = "Identifier", AST.Literal = "Literal", AST.ArrayExpression = "ArrayExpression", AST.Property = "Property", AST.ObjectExpression = "ObjectExpression", AST.ThisExpression = "ThisExpression", AST.LocalsExpression = "LocalsExpression", AST.NGValueParameter = "NGValueParameter", AST.prototype = {
            ast: function (text) {
                this.text = text, this.tokens = this.lexer.lex(text);
                var value = this.program();
                return 0 !== this.tokens.length && this.throwError("is an unexpected token", this.tokens[0]), value
            }, program: function () {
                for (var body = []; ;)if (this.tokens.length > 0 && !this.peek("}", ")", ";", "]") && body.push(this.expressionStatement()), !this.expect(";"))return {
                    type: AST.Program,
                    body: body
                }
            }, expressionStatement: function () {
                return {type: AST.ExpressionStatement, expression: this.filterChain()}
            }, filterChain: function () {
                for (var token, left = this.expression(); token = this.expect("|");)left = this.filter(left);
                return left
            }, expression: function () {
                return this.assignment()
            }, assignment: function () {
                var result = this.ternary();
                return this.expect("=") && (result = {
                    type: AST.AssignmentExpression,
                    left: result,
                    right: this.assignment(),
                    operator: "="
                }), result
            }, ternary: function () {
                var alternate, consequent, test = this.logicalOR();
                return this.expect("?") && (alternate = this.expression(), this.consume(":")) ? (consequent = this.expression(), {
                        type: AST.ConditionalExpression,
                        test: test,
                        alternate: alternate,
                        consequent: consequent
                    }) : test
            }, logicalOR: function () {
                for (var left = this.logicalAND(); this.expect("||");)left = {
                    type: AST.LogicalExpression,
                    operator: "||",
                    left: left,
                    right: this.logicalAND()
                };
                return left
            }, logicalAND: function () {
                for (var left = this.equality(); this.expect("&&");)left = {
                    type: AST.LogicalExpression,
                    operator: "&&",
                    left: left,
                    right: this.equality()
                };
                return left
            }, equality: function () {
                for (var token, left = this.relational(); token = this.expect("==", "!=", "===", "!==");)left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.relational()
                };
                return left
            }, relational: function () {
                for (var token, left = this.additive(); token = this.expect("<", ">", "<=", ">=");)left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.additive()
                };
                return left
            }, additive: function () {
                for (var token, left = this.multiplicative(); token = this.expect("+", "-");)left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.multiplicative()
                };
                return left
            }, multiplicative: function () {
                for (var token, left = this.unary(); token = this.expect("*", "/", "%");)left = {
                    type: AST.BinaryExpression,
                    operator: token.text,
                    left: left,
                    right: this.unary()
                };
                return left
            }, unary: function () {
                var token;
                return (token = this.expect("+", "-", "!")) ? {
                        type: AST.UnaryExpression,
                        operator: token.text,
                        prefix: !0,
                        argument: this.unary()
                    } : this.primary()
            }, primary: function () {
                var primary;
                this.expect("(") ? (primary = this.filterChain(), this.consume(")")) : this.expect("[") ? primary = this.arrayDeclaration() : this.expect("{") ? primary = this.object() : this.selfReferential.hasOwnProperty(this.peek().text) ? primary = copy(this.selfReferential[this.consume().text]) : this.options.literals.hasOwnProperty(this.peek().text) ? primary = {
                                        type: AST.Literal,
                                        value: this.options.literals[this.consume().text]
                                    } : this.peek().identifier ? primary = this.identifier() : this.peek().constant ? primary = this.constant() : this.throwError("not a primary expression", this.peek());
                for (var next; next = this.expect("(", "[", ".");)"(" === next.text ? (primary = {
                        type: AST.CallExpression,
                        callee: primary,
                        arguments: this.parseArguments()
                    }, this.consume(")")) : "[" === next.text ? (primary = {
                            type: AST.MemberExpression,
                            object: primary,
                            property: this.expression(),
                            computed: !0
                        }, this.consume("]")) : "." === next.text ? primary = {
                                type: AST.MemberExpression,
                                object: primary,
                                property: this.identifier(),
                                computed: !1
                            } : this.throwError("IMPOSSIBLE");
                return primary
            }, filter: function (baseExpression) {
                for (var args = [baseExpression], result = {
                    type: AST.CallExpression,
                    callee: this.identifier(),
                    arguments: args,
                    filter: !0
                }; this.expect(":");)args.push(this.expression());
                return result
            }, parseArguments: function () {
                var args = [];
                if (")" !== this.peekToken().text)do args.push(this.filterChain()); while (this.expect(","));
                return args
            }, identifier: function () {
                var token = this.consume();
                return token.identifier || this.throwError("is not a valid identifier", token), {
                    type: AST.Identifier,
                    name: token.text
                }
            }, constant: function () {
                return {type: AST.Literal, value: this.consume().value}
            }, arrayDeclaration: function () {
                var elements = [];
                if ("]" !== this.peekToken().text)do {
                    if (this.peek("]"))break;
                    elements.push(this.expression())
                } while (this.expect(","));
                return this.consume("]"), {type: AST.ArrayExpression, elements: elements}
            }, object: function () {
                var property, properties = [];
                if ("}" !== this.peekToken().text)do {
                    if (this.peek("}"))break;
                    property = {
                        type: AST.Property,
                        kind: "init"
                    }, this.peek().constant ? (property.key = this.constant(), property.computed = !1, this.consume(":"), property.value = this.expression()) : this.peek().identifier ? (property.key = this.identifier(), property.computed = !1, this.peek(":") ? (this.consume(":"), property.value = this.expression()) : property.value = property.key) : this.peek("[") ? (this.consume("["), property.key = this.expression(), this.consume("]"), property.computed = !0, this.consume(":"), property.value = this.expression()) : this.throwError("invalid key", this.peek()), properties.push(property)
                } while (this.expect(","));
                return this.consume("}"), {type: AST.ObjectExpression, properties: properties}
            }, throwError: function (msg, token) {
                throw $parseMinErr("syntax", "Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].", token.text, msg, token.index + 1, this.text, this.text.substring(token.index))
            }, consume: function (e1) {
                if (0 === this.tokens.length)throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                var token = this.expect(e1);
                return token || this.throwError("is unexpected, expecting [" + e1 + "]", this.peek()), token
            }, peekToken: function () {
                if (0 === this.tokens.length)throw $parseMinErr("ueoe", "Unexpected end of expression: {0}", this.text);
                return this.tokens[0]
            }, peek: function (e1, e2, e3, e4) {
                return this.peekAhead(0, e1, e2, e3, e4)
            }, peekAhead: function (i, e1, e2, e3, e4) {
                if (this.tokens.length > i) {
                    var token = this.tokens[i], t = token.text;
                    if (t === e1 || t === e2 || t === e3 || t === e4 || !e1 && !e2 && !e3 && !e4)return token
                }
                return !1
            }, expect: function (e1, e2, e3, e4) {
                var token = this.peek(e1, e2, e3, e4);
                return token ? (this.tokens.shift(), token) : !1
            }, selfReferential: {"this": {type: AST.ThisExpression}, $locals: {type: AST.LocalsExpression}}
        }, ASTCompiler.prototype = {
            compile: function (expression, expensiveChecks) {
                var self = this, ast = this.astBuilder.ast(expression);
                this.state = {
                    nextId: 0,
                    filters: {},
                    expensiveChecks: expensiveChecks,
                    fn: {vars: [], body: [], own: {}},
                    assign: {vars: [], body: [], own: {}},
                    inputs: []
                }, findConstantAndWatchExpressions(ast, self.$filter);
                var assignable, extra = "";
                if (this.stage = "assign", assignable = assignableAST(ast)) {
                    this.state.computing = "assign";
                    var result = this.nextId();
                    this.recurse(assignable, result), this.return_(result), extra = "fn.assign=" + this.generateFunction("assign", "s,v,l")
                }
                var toWatch = getInputs(ast.body);
                self.stage = "inputs", forEach(toWatch, function (watch, key) {
                    var fnKey = "fn" + key;
                    self.state[fnKey] = {vars: [], body: [], own: {}}, self.state.computing = fnKey;
                    var intoId = self.nextId();
                    self.recurse(watch, intoId), self.return_(intoId), self.state.inputs.push(fnKey), watch.watchId = key
                }), this.state.computing = "fn", this.stage = "main", this.recurse(ast);
                var fnString = '"' + this.USE + " " + this.STRICT + '";\n' + this.filterPrefix() + "var fn=" + this.generateFunction("fn", "s,l,a,i") + extra + this.watchFns() + "return fn;", fn = new Function("$filter", "ensureSafeMemberName", "ensureSafeObject", "ensureSafeFunction", "getStringValue", "ensureSafeAssignContext", "ifDefined", "plus", "text", fnString)(this.$filter, ensureSafeMemberName, ensureSafeObject, ensureSafeFunction, getStringValue, ensureSafeAssignContext, ifDefined, plusFn, expression);
                return this.state = this.stage = void 0, fn.literal = isLiteral(ast), fn.constant = isConstant(ast), fn
            }, USE: "use", STRICT: "strict", watchFns: function () {
                var result = [], fns = this.state.inputs, self = this;
                return forEach(fns, function (name) {
                    result.push("var " + name + "=" + self.generateFunction(name, "s"))
                }), fns.length && result.push("fn.inputs=[" + fns.join(",") + "];"), result.join("")
            }, generateFunction: function (name, params) {
                return "function(" + params + "){" + this.varsPrefix(name) + this.body(name) + "};"
            }, filterPrefix: function () {
                var parts = [], self = this;
                return forEach(this.state.filters, function (id, filter) {
                    parts.push(id + "=$filter(" + self.escape(filter) + ")")
                }), parts.length ? "var " + parts.join(",") + ";" : ""
            }, varsPrefix: function (section) {
                return this.state[section].vars.length ? "var " + this.state[section].vars.join(",") + ";" : ""
            }, body: function (section) {
                return this.state[section].body.join("")
            }, recurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                var left, right, args, expression, computed, self = this;
                if (recursionFn = recursionFn || noop, !skipWatchIdCheck && isDefined(ast.watchId))return intoId = intoId || this.nextId(), void this.if_("i", this.lazyAssign(intoId, this.computedMember("i", ast.watchId)), this.lazyRecurse(ast, intoId, nameId, recursionFn, create, !0));
                switch (ast.type) {
                    case AST.Program:
                        forEach(ast.body, function (expression, pos) {
                            self.recurse(expression.expression, void 0, void 0, function (expr) {
                                right = expr
                            }), pos !== ast.body.length - 1 ? self.current().body.push(right, ";") : self.return_(right)
                        });
                        break;
                    case AST.Literal:
                        expression = this.escape(ast.value), this.assign(intoId, expression), recursionFn(expression);
                        break;
                    case AST.UnaryExpression:
                        this.recurse(ast.argument, void 0, void 0, function (expr) {
                            right = expr
                        }), expression = ast.operator + "(" + this.ifDefined(right, 0) + ")", this.assign(intoId, expression), recursionFn(expression);
                        break;
                    case AST.BinaryExpression:
                        this.recurse(ast.left, void 0, void 0, function (expr) {
                            left = expr
                        }), this.recurse(ast.right, void 0, void 0, function (expr) {
                            right = expr
                        }), expression = "+" === ast.operator ? this.plus(left, right) : "-" === ast.operator ? this.ifDefined(left, 0) + ast.operator + this.ifDefined(right, 0) : "(" + left + ")" + ast.operator + "(" + right + ")", this.assign(intoId, expression), recursionFn(expression);
                        break;
                    case AST.LogicalExpression:
                        intoId = intoId || this.nextId(), self.recurse(ast.left, intoId), self.if_("&&" === ast.operator ? intoId : self.not(intoId), self.lazyRecurse(ast.right, intoId)), recursionFn(intoId);
                        break;
                    case AST.ConditionalExpression:
                        intoId = intoId || this.nextId(), self.recurse(ast.test, intoId), self.if_(intoId, self.lazyRecurse(ast.alternate, intoId), self.lazyRecurse(ast.consequent, intoId)), recursionFn(intoId);
                        break;
                    case AST.Identifier:
                        intoId = intoId || this.nextId(), nameId && (nameId.context = "inputs" === self.stage ? "s" : this.assign(this.nextId(), this.getHasOwnProperty("l", ast.name) + "?l:s"), nameId.computed = !1, nameId.name = ast.name), ensureSafeMemberName(ast.name), self.if_("inputs" === self.stage || self.not(self.getHasOwnProperty("l", ast.name)), function () {
                            self.if_("inputs" === self.stage || "s", function () {
                                create && 1 !== create && self.if_(self.not(self.nonComputedMember("s", ast.name)), self.lazyAssign(self.nonComputedMember("s", ast.name), "{}")), self.assign(intoId, self.nonComputedMember("s", ast.name))
                            })
                        }, intoId && self.lazyAssign(intoId, self.nonComputedMember("l", ast.name))), (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.name)) && self.addEnsureSafeObject(intoId), recursionFn(intoId);
                        break;
                    case AST.MemberExpression:
                        left = nameId && (nameId.context = this.nextId()) || this.nextId(), intoId = intoId || this.nextId(), self.recurse(ast.object, left, void 0, function () {
                            self.if_(self.notNull(left), function () {
                                create && 1 !== create && self.addEnsureSafeAssignContext(left), ast.computed ? (right = self.nextId(), self.recurse(ast.property, right), self.getStringValue(right), self.addEnsureSafeMemberName(right), create && 1 !== create && self.if_(self.not(self.computedMember(left, right)), self.lazyAssign(self.computedMember(left, right), "{}")), expression = self.ensureSafeObject(self.computedMember(left, right)), self.assign(intoId, expression), nameId && (nameId.computed = !0, nameId.name = right)) : (ensureSafeMemberName(ast.property.name), create && 1 !== create && self.if_(self.not(self.nonComputedMember(left, ast.property.name)), self.lazyAssign(self.nonComputedMember(left, ast.property.name), "{}")), expression = self.nonComputedMember(left, ast.property.name), (self.state.expensiveChecks || isPossiblyDangerousMemberName(ast.property.name)) && (expression = self.ensureSafeObject(expression)), self.assign(intoId, expression), nameId && (nameId.computed = !1, nameId.name = ast.property.name))
                            }, function () {
                                self.assign(intoId, "undefined")
                            }), recursionFn(intoId)
                        }, !!create);
                        break;
                    case AST.CallExpression:
                        intoId = intoId || this.nextId(), ast.filter ? (right = self.filter(ast.callee.name), args = [], forEach(ast.arguments, function (expr) {
                                var argument = self.nextId();
                                self.recurse(expr, argument), args.push(argument)
                            }), expression = right + "(" + args.join(",") + ")", self.assign(intoId, expression), recursionFn(intoId)) : (right = self.nextId(), left = {}, args = [], self.recurse(ast.callee, right, left, function () {
                                self.if_(self.notNull(right), function () {
                                    self.addEnsureSafeFunction(right), forEach(ast.arguments, function (expr) {
                                        self.recurse(expr, self.nextId(), void 0, function (argument) {
                                            args.push(self.ensureSafeObject(argument))
                                        })
                                    }), left.name ? (self.state.expensiveChecks || self.addEnsureSafeObject(left.context), expression = self.member(left.context, left.name, left.computed) + "(" + args.join(",") + ")") : expression = right + "(" + args.join(",") + ")", expression = self.ensureSafeObject(expression), self.assign(intoId, expression)
                                }, function () {
                                    self.assign(intoId, "undefined")
                                }), recursionFn(intoId)
                            }));
                        break;
                    case AST.AssignmentExpression:
                        if (right = this.nextId(), left = {}, !isAssignable(ast.left))throw $parseMinErr("lval", "Trying to assign a value to a non l-value");
                        this.recurse(ast.left, void 0, left, function () {
                            self.if_(self.notNull(left.context), function () {
                                self.recurse(ast.right, right), self.addEnsureSafeObject(self.member(left.context, left.name, left.computed)), self.addEnsureSafeAssignContext(left.context), expression = self.member(left.context, left.name, left.computed) + ast.operator + right, self.assign(intoId, expression), recursionFn(intoId || expression)
                            })
                        }, 1);
                        break;
                    case AST.ArrayExpression:
                        args = [], forEach(ast.elements, function (expr) {
                            self.recurse(expr, self.nextId(), void 0, function (argument) {
                                args.push(argument)
                            })
                        }), expression = "[" + args.join(",") + "]", this.assign(intoId, expression), recursionFn(expression);
                        break;
                    case AST.ObjectExpression:
                        args = [], computed = !1, forEach(ast.properties, function (property) {
                            property.computed && (computed = !0)
                        }), computed ? (intoId = intoId || this.nextId(), this.assign(intoId, "{}"), forEach(ast.properties, function (property) {
                                property.computed ? (left = self.nextId(), self.recurse(property.key, left)) : left = property.key.type === AST.Identifier ? property.key.name : "" + property.key.value, right = self.nextId(), self.recurse(property.value, right), self.assign(self.member(intoId, left, property.computed), right)
                            })) : (forEach(ast.properties, function (property) {
                                self.recurse(property.value, ast.constant ? void 0 : self.nextId(), void 0, function (expr) {
                                    args.push(self.escape(property.key.type === AST.Identifier ? property.key.name : "" + property.key.value) + ":" + expr)
                                })
                            }), expression = "{" + args.join(",") + "}", this.assign(intoId, expression)), recursionFn(intoId || expression);
                        break;
                    case AST.ThisExpression:
                        this.assign(intoId, "s"), recursionFn("s");
                        break;
                    case AST.LocalsExpression:
                        this.assign(intoId, "l"), recursionFn("l");
                        break;
                    case AST.NGValueParameter:
                        this.assign(intoId, "v"), recursionFn("v")
                }
            }, getHasOwnProperty: function (element, property) {
                var key = element + "." + property, own = this.current().own;
                return own.hasOwnProperty(key) || (own[key] = this.nextId(!1, element + "&&(" + this.escape(property) + " in " + element + ")")), own[key]
            }, assign: function (id, value) {
                return id ? (this.current().body.push(id, "=", value, ";"), id) : void 0
            }, filter: function (filterName) {
                return this.state.filters.hasOwnProperty(filterName) || (this.state.filters[filterName] = this.nextId(!0)), this.state.filters[filterName]
            }, ifDefined: function (id, defaultValue) {
                return "ifDefined(" + id + "," + this.escape(defaultValue) + ")"
            }, plus: function (left, right) {
                return "plus(" + left + "," + right + ")"
            }, return_: function (id) {
                this.current().body.push("return ", id, ";")
            }, if_: function (test, alternate, consequent) {
                if (test === !0) alternate(); else {
                    var body = this.current().body;
                    body.push("if(", test, "){"), alternate(), body.push("}"), consequent && (body.push("else{"), consequent(), body.push("}"))
                }
            }, not: function (expression) {
                return "!(" + expression + ")"
            }, notNull: function (expression) {
                return expression + "!=null"
            }, nonComputedMember: function (left, right) {
                var SAFE_IDENTIFIER = /[$_a-zA-Z][$_a-zA-Z0-9]*/, UNSAFE_CHARACTERS = /[^$_a-zA-Z0-9]/g;
                return SAFE_IDENTIFIER.test(right) ? left + "." + right : left + '["' + right.replace(UNSAFE_CHARACTERS, this.stringEscapeFn) + '"]'
            }, computedMember: function (left, right) {
                return left + "[" + right + "]"
            }, member: function (left, right, computed) {
                return computed ? this.computedMember(left, right) : this.nonComputedMember(left, right)
            }, addEnsureSafeObject: function (item) {
                this.current().body.push(this.ensureSafeObject(item), ";")
            }, addEnsureSafeMemberName: function (item) {
                this.current().body.push(this.ensureSafeMemberName(item), ";")
            }, addEnsureSafeFunction: function (item) {
                this.current().body.push(this.ensureSafeFunction(item), ";")
            }, addEnsureSafeAssignContext: function (item) {
                this.current().body.push(this.ensureSafeAssignContext(item), ";")
            }, ensureSafeObject: function (item) {
                return "ensureSafeObject(" + item + ",text)"
            }, ensureSafeMemberName: function (item) {
                return "ensureSafeMemberName(" + item + ",text)"
            }, ensureSafeFunction: function (item) {
                return "ensureSafeFunction(" + item + ",text)"
            }, getStringValue: function (item) {
                this.assign(item, "getStringValue(" + item + ")")
            }, ensureSafeAssignContext: function (item) {
                return "ensureSafeAssignContext(" + item + ",text)"
            }, lazyRecurse: function (ast, intoId, nameId, recursionFn, create, skipWatchIdCheck) {
                var self = this;
                return function () {
                    self.recurse(ast, intoId, nameId, recursionFn, create, skipWatchIdCheck)
                }
            }, lazyAssign: function (id, value) {
                var self = this;
                return function () {
                    self.assign(id, value)
                }
            }, stringEscapeRegex: /[^ a-zA-Z0-9]/g, stringEscapeFn: function (c) {
                return "\\u" + ("0000" + c.charCodeAt(0).toString(16)).slice(-4)
            }, escape: function (value) {
                if (isString(value))return "'" + value.replace(this.stringEscapeRegex, this.stringEscapeFn) + "'";
                if (isNumber(value))return value.toString();
                if (value === !0)return "true";
                if (value === !1)return "false";
                if (null === value)return "null";
                if ("undefined" == typeof value)return "undefined";
                throw $parseMinErr("esc", "IMPOSSIBLE")
            }, nextId: function (skip, init) {
                var id = "v" + this.state.nextId++;
                return skip || this.current().vars.push(id + (init ? "=" + init : "")), id
            }, current: function () {
                return this.state[this.state.computing]
            }
        }, ASTInterpreter.prototype = {
            compile: function (expression, expensiveChecks) {
                var self = this, ast = this.astBuilder.ast(expression);
                this.expression = expression, this.expensiveChecks = expensiveChecks, findConstantAndWatchExpressions(ast, self.$filter);
                var assignable, assign;
                (assignable = assignableAST(ast)) && (assign = this.recurse(assignable));
                var inputs, toWatch = getInputs(ast.body);
                toWatch && (inputs = [], forEach(toWatch, function (watch, key) {
                    var input = self.recurse(watch);
                    watch.input = input, inputs.push(input), watch.watchId = key
                }));
                var expressions = [];
                forEach(ast.body, function (expression) {
                    expressions.push(self.recurse(expression.expression))
                });
                var fn = 0 === ast.body.length ? noop : 1 === ast.body.length ? expressions[0] : function (scope, locals) {
                            var lastValue;
                            return forEach(expressions, function (exp) {
                                lastValue = exp(scope, locals)
                            }), lastValue
                        };
                return assign && (fn.assign = function (scope, value, locals) {
                    return assign(scope, locals, value)
                }), inputs && (fn.inputs = inputs), fn.literal = isLiteral(ast), fn.constant = isConstant(ast), fn
            }, recurse: function (ast, context, create) {
                var left, right, args, self = this;
                if (ast.input)return this.inputs(ast.input, ast.watchId);
                switch (ast.type) {
                    case AST.Literal:
                        return this.value(ast.value, context);
                    case AST.UnaryExpression:
                        return right = this.recurse(ast.argument), this["unary" + ast.operator](right, context);
                    case AST.BinaryExpression:
                        return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);
                    case AST.LogicalExpression:
                        return left = this.recurse(ast.left), right = this.recurse(ast.right), this["binary" + ast.operator](left, right, context);
                    case AST.ConditionalExpression:
                        return this["ternary?:"](this.recurse(ast.test), this.recurse(ast.alternate), this.recurse(ast.consequent), context);
                    case AST.Identifier:
                        return ensureSafeMemberName(ast.name, self.expression), self.identifier(ast.name, self.expensiveChecks || isPossiblyDangerousMemberName(ast.name), context, create, self.expression);
                    case AST.MemberExpression:
                        return left = this.recurse(ast.object, !1, !!create), ast.computed || (ensureSafeMemberName(ast.property.name, self.expression), right = ast.property.name), ast.computed && (right = this.recurse(ast.property)), ast.computed ? this.computedMember(left, right, context, create, self.expression) : this.nonComputedMember(left, right, self.expensiveChecks, context, create, self.expression);
                    case AST.CallExpression:
                        return args = [], forEach(ast.arguments, function (expr) {
                            args.push(self.recurse(expr))
                        }), ast.filter && (right = this.$filter(ast.callee.name)), ast.filter || (right = this.recurse(ast.callee, !0)), ast.filter ? function (scope, locals, assign, inputs) {
                                for (var values = [], i = 0; i < args.length; ++i)values.push(args[i](scope, locals, assign, inputs));
                                var value = right.apply(void 0, values, inputs);
                                return context ? {context: void 0, name: void 0, value: value} : value
                            } : function (scope, locals, assign, inputs) {
                                var value, rhs = right(scope, locals, assign, inputs);
                                if (null != rhs.value) {
                                    ensureSafeObject(rhs.context, self.expression), ensureSafeFunction(rhs.value, self.expression);
                                    for (var values = [], i = 0; i < args.length; ++i)values.push(ensureSafeObject(args[i](scope, locals, assign, inputs), self.expression));
                                    value = ensureSafeObject(rhs.value.apply(rhs.context, values), self.expression)
                                }
                                return context ? {value: value} : value
                            };
                    case AST.AssignmentExpression:
                        return left = this.recurse(ast.left, !0, 1), right = this.recurse(ast.right), function (scope, locals, assign, inputs) {
                            var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs);
                            return ensureSafeObject(lhs.value, self.expression), ensureSafeAssignContext(lhs.context), lhs.context[lhs.name] = rhs, context ? {value: rhs} : rhs
                        };
                    case AST.ArrayExpression:
                        return args = [], forEach(ast.elements, function (expr) {
                            args.push(self.recurse(expr))
                        }), function (scope, locals, assign, inputs) {
                            for (var value = [], i = 0; i < args.length; ++i)value.push(args[i](scope, locals, assign, inputs));
                            return context ? {value: value} : value
                        };
                    case AST.ObjectExpression:
                        return args = [], forEach(ast.properties, function (property) {
                            property.computed ? args.push({
                                    key: self.recurse(property.key),
                                    computed: !0,
                                    value: self.recurse(property.value)
                                }) : args.push({
                                    key: property.key.type === AST.Identifier ? property.key.name : "" + property.key.value,
                                    computed: !1,
                                    value: self.recurse(property.value)
                                })
                        }), function (scope, locals, assign, inputs) {
                            for (var value = {}, i = 0; i < args.length; ++i)args[i].computed ? value[args[i].key(scope, locals, assign, inputs)] = args[i].value(scope, locals, assign, inputs) : value[args[i].key] = args[i].value(scope, locals, assign, inputs);
                            return context ? {value: value} : value
                        };
                    case AST.ThisExpression:
                        return function (scope) {
                            return context ? {value: scope} : scope
                        };
                    case AST.LocalsExpression:
                        return function (scope, locals) {
                            return context ? {value: locals} : locals
                        };
                    case AST.NGValueParameter:
                        return function (scope, locals, assign) {
                            return context ? {value: assign} : assign
                        }
                }
            }, "unary+": function (argument, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = argument(scope, locals, assign, inputs);
                    return arg = isDefined(arg) ? +arg : 0, context ? {value: arg} : arg
                }
            }, "unary-": function (argument, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = argument(scope, locals, assign, inputs);
                    return arg = isDefined(arg) ? -arg : 0, context ? {value: arg} : arg
                }
            }, "unary!": function (argument, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = !argument(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary+": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = plusFn(lhs, rhs);
                    return context ? {value: arg} : arg
                }
            }, "binary-": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs), rhs = right(scope, locals, assign, inputs), arg = (isDefined(lhs) ? lhs : 0) - (isDefined(rhs) ? rhs : 0);
                    return context ? {value: arg} : arg
                }
            }, "binary*": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) * right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary/": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) / right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary%": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) % right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary===": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) === right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary!==": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) !== right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary==": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) == right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary!=": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) != right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary<": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) < right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary>": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) > right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary<=": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) <= right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary>=": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) >= right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary&&": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) && right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "binary||": function (left, right, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = left(scope, locals, assign, inputs) || right(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, "ternary?:": function (test, alternate, consequent, context) {
                return function (scope, locals, assign, inputs) {
                    var arg = test(scope, locals, assign, inputs) ? alternate(scope, locals, assign, inputs) : consequent(scope, locals, assign, inputs);
                    return context ? {value: arg} : arg
                }
            }, value: function (value, context) {
                return function () {
                    return context ? {context: void 0, name: void 0, value: value} : value
                }
            }, identifier: function (name, expensiveChecks, context, create, expression) {
                return function (scope, locals, assign, inputs) {
                    var base = locals && name in locals ? locals : scope;
                    create && 1 !== create && base && !base[name] && (base[name] = {});
                    var value = base ? base[name] : void 0;
                    return expensiveChecks && ensureSafeObject(value, expression), context ? {
                            context: base,
                            name: name,
                            value: value
                        } : value
                }
            }, computedMember: function (left, right, context, create, expression) {
                return function (scope, locals, assign, inputs) {
                    var rhs, value, lhs = left(scope, locals, assign, inputs);
                    return null != lhs && (rhs = right(scope, locals, assign, inputs), rhs = getStringValue(rhs), ensureSafeMemberName(rhs, expression), create && 1 !== create && (ensureSafeAssignContext(lhs), lhs && !lhs[rhs] && (lhs[rhs] = {})), value = lhs[rhs], ensureSafeObject(value, expression)), context ? {
                            context: lhs,
                            name: rhs,
                            value: value
                        } : value
                }
            }, nonComputedMember: function (left, right, expensiveChecks, context, create, expression) {
                return function (scope, locals, assign, inputs) {
                    var lhs = left(scope, locals, assign, inputs);
                    create && 1 !== create && (ensureSafeAssignContext(lhs), lhs && !lhs[right] && (lhs[right] = {}));
                    var value = null != lhs ? lhs[right] : void 0;
                    return (expensiveChecks || isPossiblyDangerousMemberName(right)) && ensureSafeObject(value, expression), context ? {
                            context: lhs,
                            name: right,
                            value: value
                        } : value
                }
            }, inputs: function (input, watchId) {
                return function (scope, value, locals, inputs) {
                    return inputs ? inputs[watchId] : input(scope, value, locals)
                }
            }
        };
        var Parser = function (lexer, $filter, options) {
            this.lexer = lexer, this.$filter = $filter, this.options = options, this.ast = new AST(lexer, options), this.astCompiler = options.csp ? new ASTInterpreter(this.ast, $filter) : new ASTCompiler(this.ast, $filter)
        };
        Parser.prototype = {
            constructor: Parser, parse: function (text) {
                return this.astCompiler.compile(text, this.options.expensiveChecks)
            }
        };
        var objectValueOf = Object.prototype.valueOf, $sceMinErr = minErr("$sce"), SCE_CONTEXTS = {
            HTML: "html",
            CSS: "css",
            URL: "url",
            RESOURCE_URL: "resourceUrl",
            JS: "js"
        }, $templateRequestMinErr = minErr("$compile"), urlParsingNode = window.document.createElement("a"), originUrl = urlResolve(window.location.href);
        $$CookieReader.$inject = ["$document"], $FilterProvider.$inject = ["$provide"];
        var MAX_DIGITS = 22, DECIMAL_SEP = ".", ZERO_CHAR = "0";
        currencyFilter.$inject = ["$locale"], numberFilter.$inject = ["$locale"];
        var DATE_FORMATS = {
            yyyy: dateGetter("FullYear", 4, 0, !1, !0),
            yy: dateGetter("FullYear", 2, 0, !0, !0),
            y: dateGetter("FullYear", 1, 0, !1, !0),
            MMMM: dateStrGetter("Month"),
            MMM: dateStrGetter("Month", !0),
            MM: dateGetter("Month", 2, 1),
            M: dateGetter("Month", 1, 1),
            LLLL: dateStrGetter("Month", !1, !0),
            dd: dateGetter("Date", 2),
            d: dateGetter("Date", 1),
            HH: dateGetter("Hours", 2),
            H: dateGetter("Hours", 1),
            hh: dateGetter("Hours", 2, -12),
            h: dateGetter("Hours", 1, -12),
            mm: dateGetter("Minutes", 2),
            m: dateGetter("Minutes", 1),
            ss: dateGetter("Seconds", 2),
            s: dateGetter("Seconds", 1),
            sss: dateGetter("Milliseconds", 3),
            EEEE: dateStrGetter("Day"),
            EEE: dateStrGetter("Day", !0),
            a: ampmGetter,
            Z: timeZoneGetter,
            ww: weekGetter(2),
            w: weekGetter(1),
            G: eraGetter,
            GG: eraGetter,
            GGG: eraGetter,
            GGGG: longEraGetter
        }, DATE_FORMATS_SPLIT = /((?:[^yMLdHhmsaZEwG']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|L+|d+|H+|h+|m+|s+|a|Z|G+|w+))(.*)/, NUMBER_STRING = /^\-?\d+$/;
        dateFilter.$inject = ["$locale"];
        var lowercaseFilter = valueFn(lowercase), uppercaseFilter = valueFn(uppercase);
        orderByFilter.$inject = ["$parse"];
        var htmlAnchorDirective = valueFn({
            restrict: "E", compile: function (element, attr) {
                return attr.href || attr.xlinkHref ? void 0 : function (scope, element) {
                        if ("a" === element[0].nodeName.toLowerCase()) {
                            var href = "[object SVGAnimatedString]" === toString.call(element.prop("href")) ? "xlink:href" : "href";
                            element.on("click", function (event) {
                                element.attr(href) || event.preventDefault()
                            })
                        }
                    }
            }
        }), ngAttributeAliasDirectives = {};
        forEach(BOOLEAN_ATTR, function (propName, attrName) {
            function defaultLinkFn(scope, element, attr) {
                scope.$watch(attr[normalized], function (value) {
                    attr.$set(attrName, !!value)
                })
            }

            if ("multiple" != propName) {
                var normalized = directiveNormalize("ng-" + attrName), linkFn = defaultLinkFn;
                "checked" === propName && (linkFn = function (scope, element, attr) {
                    attr.ngModel !== attr[normalized] && defaultLinkFn(scope, element, attr)
                }), ngAttributeAliasDirectives[normalized] = function () {
                    return {restrict: "A", priority: 100, link: linkFn}
                }
            }
        }), forEach(ALIASED_ATTR, function (htmlAttr, ngAttr) {
            ngAttributeAliasDirectives[ngAttr] = function () {
                return {
                    priority: 100, link: function (scope, element, attr) {
                        if ("ngPattern" === ngAttr && "/" == attr.ngPattern.charAt(0)) {
                            var match = attr.ngPattern.match(REGEX_STRING_REGEXP);
                            if (match)return void attr.$set("ngPattern", new RegExp(match[1], match[2]))
                        }
                        scope.$watch(attr[ngAttr], function (value) {
                            attr.$set(ngAttr, value)
                        })
                    }
                }
            }
        }), forEach(["src", "srcset", "href"], function (attrName) {
            var normalized = directiveNormalize("ng-" + attrName);
            ngAttributeAliasDirectives[normalized] = function () {
                return {
                    priority: 99, link: function (scope, element, attr) {
                        var propName = attrName, name = attrName;
                        "href" === attrName && "[object SVGAnimatedString]" === toString.call(element.prop("href")) && (name = "xlinkHref", attr.$attr[name] = "xlink:href", propName = null), attr.$observe(normalized, function (value) {
                            return value ? (attr.$set(name, value), void(msie && propName && element.prop(propName, attr[name]))) : void("href" === attrName && attr.$set(name, null))
                        })
                    }
                }
            }
        });
        var nullFormCtrl = {
            $addControl: noop,
            $$renameControl: nullFormRenameControl,
            $removeControl: noop,
            $setValidity: noop,
            $setDirty: noop,
            $setPristine: noop,
            $setSubmitted: noop
        }, SUBMITTED_CLASS = "ng-submitted";
        FormController.$inject = ["$element", "$attrs", "$scope", "$animate", "$interpolate"];
        var formDirectiveFactory = function (isNgForm) {
            return ["$timeout", "$parse", function ($timeout, $parse) {
                function getSetter(expression) {
                    return "" === expression ? $parse('this[""]').assign : $parse(expression).assign || noop
                }

                var formDirective = {
                    name: "form",
                    restrict: isNgForm ? "EAC" : "E",
                    require: ["form", "^^?form"],
                    controller: FormController,
                    compile: function (formElement, attr) {
                        formElement.addClass(PRISTINE_CLASS).addClass(VALID_CLASS);
                        var nameAttr = attr.name ? "name" : isNgForm && attr.ngForm ? "ngForm" : !1;
                        return {
                            pre: function (scope, formElement, attr, ctrls) {
                                var controller = ctrls[0];
                                if (!("action" in attr)) {
                                    var handleFormSubmission = function (event) {
                                        scope.$apply(function () {
                                            controller.$commitViewValue(), controller.$setSubmitted()
                                        }), event.preventDefault()
                                    };
                                    addEventListenerFn(formElement[0], "submit", handleFormSubmission), formElement.on("$destroy", function () {
                                        $timeout(function () {
                                            removeEventListenerFn(formElement[0], "submit", handleFormSubmission)
                                        }, 0, !1)
                                    })
                                }
                                var parentFormCtrl = ctrls[1] || controller.$$parentForm;
                                parentFormCtrl.$addControl(controller);
                                var setter = nameAttr ? getSetter(controller.$name) : noop;
                                nameAttr && (setter(scope, controller), attr.$observe(nameAttr, function (newValue) {
                                    controller.$name !== newValue && (setter(scope, void 0), controller.$$parentForm.$$renameControl(controller, newValue), (setter = getSetter(controller.$name))(scope, controller))
                                })), formElement.on("$destroy", function () {
                                    controller.$$parentForm.$removeControl(controller), setter(scope, void 0), extend(controller, nullFormCtrl)
                                })
                            }
                        }
                    }
                };
                return formDirective
            }]
        }, formDirective = formDirectiveFactory(), ngFormDirective = formDirectiveFactory(!0), ISO_DATE_REGEXP = /^\d{4,}-[01]\d-[0-3]\dT[0-2]\d:[0-5]\d:[0-5]\d\.\d+(?:[+-][0-2]\d:[0-5]\d|Z)$/, URL_REGEXP = /^[a-z][a-z\d.+-]*:\/*(?:[^:@]+(?::[^@]+)?@)?(?:[^\s:\/?#]+|\[[a-f\d:]+\])(?::\d+)?(?:\/[^?#]*)?(?:\?[^#]*)?(?:#.*)?$/i, EMAIL_REGEXP = /^(?=.{1,254}$)(?=.{1,64}@)[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+(\.[-!#$%&'*+\/0-9=?A-Z^_`a-z{|}~]+)*@[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?(\.[A-Za-z0-9]([A-Za-z0-9-]{0,61}[A-Za-z0-9])?)*$/, NUMBER_REGEXP = /^\s*(\-|\+)?(\d+|(\d*(\.\d*)))([eE][+-]?\d+)?\s*$/, DATE_REGEXP = /^(\d{4,})-(\d{2})-(\d{2})$/, DATETIMELOCAL_REGEXP = /^(\d{4,})-(\d\d)-(\d\d)T(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, WEEK_REGEXP = /^(\d{4,})-W(\d\d)$/, MONTH_REGEXP = /^(\d{4,})-(\d\d)$/, TIME_REGEXP = /^(\d\d):(\d\d)(?::(\d\d)(\.\d{1,3})?)?$/, PARTIAL_VALIDATION_EVENTS = "keydown wheel mousedown", PARTIAL_VALIDATION_TYPES = createMap();
        forEach("date,datetime-local,month,time,week".split(","), function (type) {
            PARTIAL_VALIDATION_TYPES[type] = !0
        });
        var inputType = {
            text: textInputType,
            date: createDateInputType("date", DATE_REGEXP, createDateParser(DATE_REGEXP, ["yyyy", "MM", "dd"]), "yyyy-MM-dd"),
            "datetime-local": createDateInputType("datetimelocal", DATETIMELOCAL_REGEXP, createDateParser(DATETIMELOCAL_REGEXP, ["yyyy", "MM", "dd", "HH", "mm", "ss", "sss"]), "yyyy-MM-ddTHH:mm:ss.sss"),
            time: createDateInputType("time", TIME_REGEXP, createDateParser(TIME_REGEXP, ["HH", "mm", "ss", "sss"]), "HH:mm:ss.sss"),
            week: createDateInputType("week", WEEK_REGEXP, weekParser, "yyyy-Www"),
            month: createDateInputType("month", MONTH_REGEXP, createDateParser(MONTH_REGEXP, ["yyyy", "MM"]), "yyyy-MM"),
            number: numberInputType,
            url: urlInputType,
            email: emailInputType,
            radio: radioInputType,
            checkbox: checkboxInputType,
            hidden: noop,
            button: noop,
            submit: noop,
            reset: noop,
            file: noop
        }, inputDirective = ["$browser", "$sniffer", "$filter", "$parse", function ($browser, $sniffer, $filter, $parse) {
            return {
                restrict: "E", require: ["?ngModel"], link: {
                    pre: function (scope, element, attr, ctrls) {
                        ctrls[0] && (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrls[0], $sniffer, $browser, $filter, $parse)
                    }
                }
            }
        }], CONSTANT_VALUE_REGEXP = /^(true|false|\d+)$/, ngValueDirective = function () {
            return {
                restrict: "A", priority: 100, compile: function (tpl, tplAttr) {
                    return CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue) ? function (scope, elm, attr) {
                            attr.$set("value", scope.$eval(attr.ngValue))
                        } : function (scope, elm, attr) {
                            scope.$watch(attr.ngValue, function (value) {
                                attr.$set("value", value)
                            })
                        }
                }
            }
        }, ngBindDirective = ["$compile", function ($compile) {
            return {
                restrict: "AC", compile: function (templateElement) {
                    return $compile.$$addBindingClass(templateElement), function (scope, element, attr) {
                        $compile.$$addBindingInfo(element, attr.ngBind), element = element[0], scope.$watch(attr.ngBind, function (value) {
                            element.textContent = isUndefined(value) ? "" : value
                        })
                    }
                }
            }
        }], ngBindTemplateDirective = ["$interpolate", "$compile", function ($interpolate, $compile) {
            return {
                compile: function (templateElement) {
                    return $compile.$$addBindingClass(templateElement), function (scope, element, attr) {
                        var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));
                        $compile.$$addBindingInfo(element, interpolateFn.expressions), element = element[0], attr.$observe("ngBindTemplate", function (value) {
                            element.textContent = isUndefined(value) ? "" : value
                        })
                    }
                }
            }
        }], ngBindHtmlDirective = ["$sce", "$parse", "$compile", function ($sce, $parse, $compile) {
            return {
                restrict: "A", compile: function (tElement, tAttrs) {
                    var ngBindHtmlGetter = $parse(tAttrs.ngBindHtml), ngBindHtmlWatch = $parse(tAttrs.ngBindHtml, function (val) {
                        return $sce.valueOf(val)
                    });
                    return $compile.$$addBindingClass(tElement), function (scope, element, attr) {
                        $compile.$$addBindingInfo(element, attr.ngBindHtml), scope.$watch(ngBindHtmlWatch, function () {
                            var value = ngBindHtmlGetter(scope);
                            element.html($sce.getTrustedHtml(value) || "")
                        })
                    }
                }
            }
        }], ngChangeDirective = valueFn({
            restrict: "A",
            require: "ngModel",
            link: function (scope, element, attr, ctrl) {
                ctrl.$viewChangeListeners.push(function () {
                    scope.$eval(attr.ngChange)
                })
            }
        }), ngClassDirective = classDirective("", !0), ngClassOddDirective = classDirective("Odd", 0), ngClassEvenDirective = classDirective("Even", 1), ngCloakDirective = ngDirective({
            compile: function (element, attr) {
                attr.$set("ngCloak", void 0), element.removeClass("ng-cloak")
            }
        }), ngControllerDirective = [function () {
            return {restrict: "A", scope: !0, controller: "@", priority: 500}
        }], ngEventDirectives = {}, forceAsyncEvents = {blur: !0, focus: !0};
        forEach("click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur copy cut paste".split(" "), function (eventName) {
            var directiveName = directiveNormalize("ng-" + eventName);
            ngEventDirectives[directiveName] = ["$parse", "$rootScope", function ($parse, $rootScope) {
                return {
                    restrict: "A", compile: function ($element, attr) {
                        var fn = $parse(attr[directiveName], null, !0);
                        return function (scope, element) {
                            element.on(eventName, function (event) {
                                var callback = function () {
                                    fn(scope, {$event: event})
                                };
                                forceAsyncEvents[eventName] && $rootScope.$$phase ? scope.$evalAsync(callback) : scope.$apply(callback)
                            })
                        }
                    }
                }
            }]
        });
        var ngIfDirective = ["$animate", "$compile", function ($animate, $compile) {
            return {
                multiElement: !0,
                transclude: "element",
                priority: 600,
                terminal: !0,
                restrict: "A",
                $$tlb: !0,
                link: function ($scope, $element, $attr, ctrl, $transclude) {
                    var block, childScope, previousElements;
                    $scope.$watch($attr.ngIf, function (value) {
                        value ? childScope || $transclude(function (clone, newScope) {
                                childScope = newScope, clone[clone.length++] = $compile.$$createComment("end ngIf", $attr.ngIf), block = {clone: clone}, $animate.enter(clone, $element.parent(), $element)
                            }) : (previousElements && (previousElements.remove(), previousElements = null), childScope && (childScope.$destroy(), childScope = null), block && (previousElements = getBlockNodes(block.clone), $animate.leave(previousElements).then(function () {
                                previousElements = null
                            }), block = null))
                    })
                }
            }
        }], ngIncludeDirective = ["$templateRequest", "$anchorScroll", "$animate", function ($templateRequest, $anchorScroll, $animate) {
            return {
                restrict: "ECA",
                priority: 400,
                terminal: !0,
                transclude: "element",
                controller: angular.noop,
                compile: function (element, attr) {
                    var srcExp = attr.ngInclude || attr.src, onloadExp = attr.onload || "", autoScrollExp = attr.autoscroll;
                    return function (scope, $element, $attr, ctrl, $transclude) {
                        var currentScope, previousElement, currentElement, changeCounter = 0, cleanupLastIncludeContent = function () {
                            previousElement && (previousElement.remove(), previousElement = null), currentScope && (currentScope.$destroy(), currentScope = null), currentElement && ($animate.leave(currentElement).then(function () {
                                previousElement = null
                            }), previousElement = currentElement, currentElement = null)
                        };
                        scope.$watch(srcExp, function (src) {
                            var afterAnimation = function () {
                                !isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll()
                            }, thisChangeId = ++changeCounter;
                            src ? ($templateRequest(src, !0).then(function (response) {
                                    if (!scope.$$destroyed && thisChangeId === changeCounter) {
                                        var newScope = scope.$new();
                                        ctrl.template = response;
                                        var clone = $transclude(newScope, function (clone) {
                                            cleanupLastIncludeContent(), $animate.enter(clone, null, $element).then(afterAnimation)
                                        });
                                        currentScope = newScope, currentElement = clone, currentScope.$emit("$includeContentLoaded", src), scope.$eval(onloadExp)
                                    }
                                }, function () {
                                    scope.$$destroyed || thisChangeId === changeCounter && (cleanupLastIncludeContent(), scope.$emit("$includeContentError", src))
                                }), scope.$emit("$includeContentRequested", src)) : (cleanupLastIncludeContent(), ctrl.template = null)
                        })
                    }
                }
            }
        }], ngIncludeFillContentDirective = ["$compile", function ($compile) {
            return {
                restrict: "ECA",
                priority: -400,
                require: "ngInclude",
                link: function (scope, $element, $attr, ctrl) {
                    return toString.call($element[0]).match(/SVG/) ? ($element.empty(), void $compile(jqLiteBuildFragment(ctrl.template, window.document).childNodes)(scope, function (clone) {
                            $element.append(clone)
                        }, {futureParentElement: $element})) : ($element.html(ctrl.template), void $compile($element.contents())(scope))
                }
            }
        }], ngInitDirective = ngDirective({
            priority: 450, compile: function () {
                return {
                    pre: function (scope, element, attrs) {
                        scope.$eval(attrs.ngInit)
                    }
                }
            }
        }), ngListDirective = function () {
            return {
                restrict: "A", priority: 100, require: "ngModel", link: function (scope, element, attr, ctrl) {
                    var ngList = element.attr(attr.$attr.ngList) || ", ", trimValues = "false" !== attr.ngTrim, separator = trimValues ? trim(ngList) : ngList, parse = function (viewValue) {
                        if (!isUndefined(viewValue)) {
                            var list = [];
                            return viewValue && forEach(viewValue.split(separator), function (value) {
                                value && list.push(trimValues ? trim(value) : value)
                            }), list
                        }
                    };
                    ctrl.$parsers.push(parse), ctrl.$formatters.push(function (value) {
                        return isArray(value) ? value.join(ngList) : void 0
                    }), ctrl.$isEmpty = function (value) {
                        return !value || !value.length
                    }
                }
            }
        }, VALID_CLASS = "ng-valid", INVALID_CLASS = "ng-invalid", PRISTINE_CLASS = "ng-pristine", DIRTY_CLASS = "ng-dirty", UNTOUCHED_CLASS = "ng-untouched", TOUCHED_CLASS = "ng-touched", PENDING_CLASS = "ng-pending", EMPTY_CLASS = "ng-empty", NOT_EMPTY_CLASS = "ng-not-empty", ngModelMinErr = minErr("ngModel"), NgModelController = ["$scope", "$exceptionHandler", "$attrs", "$element", "$parse", "$animate", "$timeout", "$rootScope", "$q", "$interpolate", function ($scope, $exceptionHandler, $attr, $element, $parse, $animate, $timeout, $rootScope, $q, $interpolate) {
            this.$viewValue = Number.NaN, this.$modelValue = Number.NaN, this.$$rawModelValue = void 0, this.$validators = {}, this.$asyncValidators = {}, this.$parsers = [], this.$formatters = [], this.$viewChangeListeners = [], this.$untouched = !0, this.$touched = !1, this.$pristine = !0, this.$dirty = !1, this.$valid = !0, this.$invalid = !1, this.$error = {}, this.$$success = {}, this.$pending = void 0, this.$name = $interpolate($attr.name || "", !1)($scope), this.$$parentForm = nullFormCtrl;
            var parserValid, parsedNgModel = $parse($attr.ngModel), parsedNgModelAssign = parsedNgModel.assign, ngModelGet = parsedNgModel, ngModelSet = parsedNgModelAssign, pendingDebounce = null, ctrl = this;
            this.$$setOptions = function (options) {
                if (ctrl.$options = options, options && options.getterSetter) {
                    var invokeModelGetter = $parse($attr.ngModel + "()"), invokeModelSetter = $parse($attr.ngModel + "($$$p)");
                    ngModelGet = function ($scope) {
                        var modelValue = parsedNgModel($scope);
                        return isFunction(modelValue) && (modelValue = invokeModelGetter($scope)), modelValue
                    }, ngModelSet = function ($scope, newValue) {
                        isFunction(parsedNgModel($scope)) ? invokeModelSetter($scope, {$$$p: newValue}) : parsedNgModelAssign($scope, newValue)
                    }
                } else if (!parsedNgModel.assign)throw ngModelMinErr("nonassign", "Expression '{0}' is non-assignable. Element: {1}", $attr.ngModel, startingTag($element))
            }, this.$render = noop, this.$isEmpty = function (value) {
                return isUndefined(value) || "" === value || null === value || value !== value
            }, this.$$updateEmptyClasses = function (value) {
                ctrl.$isEmpty(value) ? ($animate.removeClass($element, NOT_EMPTY_CLASS), $animate.addClass($element, EMPTY_CLASS)) : ($animate.removeClass($element, EMPTY_CLASS), $animate.addClass($element, NOT_EMPTY_CLASS))
            };
            var currentValidationRunId = 0;
            addSetValidityMethod({
                ctrl: this, $element: $element, set: function (object, property) {
                    object[property] = !0
                }, unset: function (object, property) {
                    delete object[property]
                }, $animate: $animate
            }), this.$setPristine = function () {
                ctrl.$dirty = !1, ctrl.$pristine = !0, $animate.removeClass($element, DIRTY_CLASS), $animate.addClass($element, PRISTINE_CLASS)
            }, this.$setDirty = function () {
                ctrl.$dirty = !0, ctrl.$pristine = !1, $animate.removeClass($element, PRISTINE_CLASS), $animate.addClass($element, DIRTY_CLASS), ctrl.$$parentForm.$setDirty()
            }, this.$setUntouched = function () {
                ctrl.$touched = !1, ctrl.$untouched = !0, $animate.setClass($element, UNTOUCHED_CLASS, TOUCHED_CLASS)
            }, this.$setTouched = function () {
                ctrl.$touched = !0, ctrl.$untouched = !1, $animate.setClass($element, TOUCHED_CLASS, UNTOUCHED_CLASS)
            }, this.$rollbackViewValue = function () {
                $timeout.cancel(pendingDebounce), ctrl.$viewValue = ctrl.$$lastCommittedViewValue, ctrl.$render()
            }, this.$validate = function () {
                if (!isNumber(ctrl.$modelValue) || !isNaN(ctrl.$modelValue)) {
                    var viewValue = ctrl.$$lastCommittedViewValue, modelValue = ctrl.$$rawModelValue, prevValid = ctrl.$valid, prevModelValue = ctrl.$modelValue, allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                    ctrl.$$runValidators(modelValue, viewValue, function (allValid) {
                        allowInvalid || prevValid === allValid || (ctrl.$modelValue = allValid ? modelValue : void 0, ctrl.$modelValue !== prevModelValue && ctrl.$$writeModelToScope())
                    })
                }
            }, this.$$runValidators = function (modelValue, viewValue, doneCallback) {
                function processParseErrors() {
                    var errorKey = ctrl.$$parserName || "parse";
                    return isUndefined(parserValid) ? (setValidity(errorKey, null), !0) : (parserValid || (forEach(ctrl.$validators, function (v, name) {
                            setValidity(name, null)
                        }), forEach(ctrl.$asyncValidators, function (v, name) {
                            setValidity(name, null)
                        })), setValidity(errorKey, parserValid), parserValid)
                }

                function processSyncValidators() {
                    var syncValidatorsValid = !0;
                    return forEach(ctrl.$validators, function (validator, name) {
                        var result = validator(modelValue, viewValue);
                        syncValidatorsValid = syncValidatorsValid && result, setValidity(name, result)
                    }), syncValidatorsValid ? !0 : (forEach(ctrl.$asyncValidators, function (v, name) {
                            setValidity(name, null)
                        }), !1)
                }

                function processAsyncValidators() {
                    var validatorPromises = [], allValid = !0;
                    forEach(ctrl.$asyncValidators, function (validator, name) {
                        var promise = validator(modelValue, viewValue);
                        if (!isPromiseLike(promise))throw ngModelMinErr("nopromise", "Expected asynchronous validator to return a promise but got '{0}' instead.", promise);
                        setValidity(name, void 0), validatorPromises.push(promise.then(function () {
                            setValidity(name, !0)
                        }, function () {
                            allValid = !1, setValidity(name, !1)
                        }))
                    }), validatorPromises.length ? $q.all(validatorPromises).then(function () {
                            validationDone(allValid)
                        }, noop) : validationDone(!0)
                }

                function setValidity(name, isValid) {
                    localValidationRunId === currentValidationRunId && ctrl.$setValidity(name, isValid)
                }

                function validationDone(allValid) {
                    localValidationRunId === currentValidationRunId && doneCallback(allValid)
                }

                currentValidationRunId++;
                var localValidationRunId = currentValidationRunId;
                return processParseErrors() && processSyncValidators() ? void processAsyncValidators() : void validationDone(!1)
            }, this.$commitViewValue = function () {
                var viewValue = ctrl.$viewValue;
                $timeout.cancel(pendingDebounce), (ctrl.$$lastCommittedViewValue !== viewValue || "" === viewValue && ctrl.$$hasNativeValidators) && (ctrl.$$updateEmptyClasses(viewValue), ctrl.$$lastCommittedViewValue = viewValue, ctrl.$pristine && this.$setDirty(), this.$$parseAndValidate())
            }, this.$$parseAndValidate = function () {
                function writeToModelIfNeeded() {
                    ctrl.$modelValue !== prevModelValue && ctrl.$$writeModelToScope()
                }

                var viewValue = ctrl.$$lastCommittedViewValue, modelValue = viewValue;
                if (parserValid = isUndefined(modelValue) ? void 0 : !0)for (var i = 0; i < ctrl.$parsers.length; i++)if (modelValue = ctrl.$parsers[i](modelValue), isUndefined(modelValue)) {
                    parserValid = !1;
                    break
                }
                isNumber(ctrl.$modelValue) && isNaN(ctrl.$modelValue) && (ctrl.$modelValue = ngModelGet($scope));
                var prevModelValue = ctrl.$modelValue, allowInvalid = ctrl.$options && ctrl.$options.allowInvalid;
                ctrl.$$rawModelValue = modelValue, allowInvalid && (ctrl.$modelValue = modelValue, writeToModelIfNeeded()), ctrl.$$runValidators(modelValue, ctrl.$$lastCommittedViewValue, function (allValid) {
                    allowInvalid || (ctrl.$modelValue = allValid ? modelValue : void 0, writeToModelIfNeeded())
                })
            }, this.$$writeModelToScope = function () {
                ngModelSet($scope, ctrl.$modelValue), forEach(ctrl.$viewChangeListeners, function (listener) {
                    try {
                        listener()
                    } catch (e) {
                        $exceptionHandler(e)
                    }
                })
            }, this.$setViewValue = function (value, trigger) {
                ctrl.$viewValue = value, (!ctrl.$options || ctrl.$options.updateOnDefault) && ctrl.$$debounceViewValueCommit(trigger)
            }, this.$$debounceViewValueCommit = function (trigger) {
                var debounce, debounceDelay = 0, options = ctrl.$options;
                options && isDefined(options.debounce) && (debounce = options.debounce, isNumber(debounce) ? debounceDelay = debounce : isNumber(debounce[trigger]) ? debounceDelay = debounce[trigger] : isNumber(debounce["default"]) && (debounceDelay = debounce["default"])), $timeout.cancel(pendingDebounce), debounceDelay ? pendingDebounce = $timeout(function () {
                        ctrl.$commitViewValue()
                    }, debounceDelay) : $rootScope.$$phase ? ctrl.$commitViewValue() : $scope.$apply(function () {
                            ctrl.$commitViewValue()
                        })
            }, $scope.$watch(function () {
                var modelValue = ngModelGet($scope);
                if (modelValue !== ctrl.$modelValue && (ctrl.$modelValue === ctrl.$modelValue || modelValue === modelValue)) {
                    ctrl.$modelValue = ctrl.$$rawModelValue = modelValue, parserValid = void 0;
                    for (var formatters = ctrl.$formatters, idx = formatters.length, viewValue = modelValue; idx--;)viewValue = formatters[idx](viewValue);
                    ctrl.$viewValue !== viewValue && (ctrl.$$updateEmptyClasses(viewValue), ctrl.$viewValue = ctrl.$$lastCommittedViewValue = viewValue, ctrl.$render(), ctrl.$$runValidators(modelValue, viewValue, noop))
                }
                return modelValue
            })
        }], ngModelDirective = ["$rootScope", function ($rootScope) {
            return {
                restrict: "A",
                require: ["ngModel", "^?form", "^?ngModelOptions"],
                controller: NgModelController,
                priority: 1,
                compile: function (element) {
                    return element.addClass(PRISTINE_CLASS).addClass(UNTOUCHED_CLASS).addClass(VALID_CLASS), {
                        pre: function (scope, element, attr, ctrls) {
                            var modelCtrl = ctrls[0], formCtrl = ctrls[1] || modelCtrl.$$parentForm;
                            modelCtrl.$$setOptions(ctrls[2] && ctrls[2].$options), formCtrl.$addControl(modelCtrl), attr.$observe("name", function (newValue) {
                                modelCtrl.$name !== newValue && modelCtrl.$$parentForm.$$renameControl(modelCtrl, newValue)
                            }), scope.$on("$destroy", function () {
                                modelCtrl.$$parentForm.$removeControl(modelCtrl)
                            })
                        }, post: function (scope, element, attr, ctrls) {
                            var modelCtrl = ctrls[0];
                            modelCtrl.$options && modelCtrl.$options.updateOn && element.on(modelCtrl.$options.updateOn, function (ev) {
                                modelCtrl.$$debounceViewValueCommit(ev && ev.type)
                            }), element.on("blur", function () {
                                modelCtrl.$touched || ($rootScope.$$phase ? scope.$evalAsync(modelCtrl.$setTouched) : scope.$apply(modelCtrl.$setTouched))
                            })
                        }
                    }
                }
            }
        }], DEFAULT_REGEXP = /(\s+|^)default(\s+|$)/, ngModelOptionsDirective = function () {
            return {
                restrict: "A", controller: ["$scope", "$attrs", function ($scope, $attrs) {
                    var that = this;
                    this.$options = copy($scope.$eval($attrs.ngModelOptions)), isDefined(this.$options.updateOn) ? (this.$options.updateOnDefault = !1, this.$options.updateOn = trim(this.$options.updateOn.replace(DEFAULT_REGEXP, function () {
                            return that.$options.updateOnDefault = !0, " "
                        }))) : this.$options.updateOnDefault = !0
                }]
            }
        }, ngNonBindableDirective = ngDirective({
            terminal: !0,
            priority: 1e3
        }), ngOptionsMinErr = minErr("ngOptions"), NG_OPTIONS_REGEXP = /^\s*([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+group\s+by\s+([\s\S]+?))?(?:\s+disable\s+when\s+([\s\S]+?))?\s+for\s+(?:([\$\w][\$\w]*)|(?:\(\s*([\$\w][\$\w]*)\s*,\s*([\$\w][\$\w]*)\s*\)))\s+in\s+([\s\S]+?)(?:\s+track\s+by\s+([\s\S]+?))?$/, ngOptionsDirective = ["$compile", "$document", "$parse", function ($compile, $document, $parse) {
            function parseOptionsExpression(optionsExp, selectElement, scope) {
                function Option(selectValue, viewValue, label, group, disabled) {
                    this.selectValue = selectValue, this.viewValue = viewValue, this.label = label, this.group = group, this.disabled = disabled
                }

                function getOptionValuesKeys(optionValues) {
                    var optionValuesKeys;
                    if (!keyName && isArrayLike(optionValues)) optionValuesKeys = optionValues; else {
                        optionValuesKeys = [];
                        for (var itemKey in optionValues)optionValues.hasOwnProperty(itemKey) && "$" !== itemKey.charAt(0) && optionValuesKeys.push(itemKey)
                    }
                    return optionValuesKeys
                }

                var match = optionsExp.match(NG_OPTIONS_REGEXP);
                if (!match)throw ngOptionsMinErr("iexp", "Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}", optionsExp, startingTag(selectElement));
                var valueName = match[5] || match[7], keyName = match[6], selectAs = / as /.test(match[0]) && match[1], trackBy = match[9], valueFn = $parse(match[2] ? match[1] : valueName), selectAsFn = selectAs && $parse(selectAs), viewValueFn = selectAsFn || valueFn, trackByFn = trackBy && $parse(trackBy), getTrackByValueFn = trackBy ? function (value, locals) {
                        return trackByFn(scope, locals)
                    } : function (value) {
                        return hashKey(value)
                    }, getTrackByValue = function (value, key) {
                    return getTrackByValueFn(value, getLocals(value, key))
                }, displayFn = $parse(match[2] || match[1]), groupByFn = $parse(match[3] || ""), disableWhenFn = $parse(match[4] || ""), valuesFn = $parse(match[8]), locals = {}, getLocals = keyName ? function (value, key) {
                        return locals[keyName] = key, locals[valueName] = value, locals
                    } : function (value) {
                        return locals[valueName] = value, locals
                    };
                return {
                    trackBy: trackBy,
                    getTrackByValue: getTrackByValue,
                    getWatchables: $parse(valuesFn, function (optionValues) {
                        var watchedArray = [];
                        optionValues = optionValues || [];
                        for (var optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; optionValuesLength > index; index++) {
                            var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), selectValue = getTrackByValueFn(value, locals);
                            if (watchedArray.push(selectValue), match[2] || match[1]) {
                                var label = displayFn(scope, locals);
                                watchedArray.push(label)
                            }
                            if (match[4]) {
                                var disableWhen = disableWhenFn(scope, locals);
                                watchedArray.push(disableWhen)
                            }
                        }
                        return watchedArray
                    }),
                    getOptions: function () {
                        for (var optionItems = [], selectValueMap = {}, optionValues = valuesFn(scope) || [], optionValuesKeys = getOptionValuesKeys(optionValues), optionValuesLength = optionValuesKeys.length, index = 0; optionValuesLength > index; index++) {
                            var key = optionValues === optionValuesKeys ? index : optionValuesKeys[index], value = optionValues[key], locals = getLocals(value, key), viewValue = viewValueFn(scope, locals), selectValue = getTrackByValueFn(viewValue, locals), label = displayFn(scope, locals), group = groupByFn(scope, locals), disabled = disableWhenFn(scope, locals), optionItem = new Option(selectValue, viewValue, label, group, disabled);
                            optionItems.push(optionItem), selectValueMap[selectValue] = optionItem
                        }
                        return {
                            items: optionItems,
                            selectValueMap: selectValueMap,
                            getOptionFromViewValue: function (value) {
                                return selectValueMap[getTrackByValue(value)]
                            },
                            getViewValueFromOption: function (option) {
                                return trackBy ? angular.copy(option.viewValue) : option.viewValue
                            }
                        }
                    }
                }
            }

            function ngOptionsPostLink(scope, selectElement, attr, ctrls) {
                function addOptionElement(option, parent) {
                    var optionElement = optionTemplate.cloneNode(!1);
                    parent.appendChild(optionElement), updateOptionElement(option, optionElement)
                }

                function updateOptionElement(option, element) {
                    option.element = element, element.disabled = option.disabled, option.label !== element.label && (element.label = option.label, element.textContent = option.label), option.value !== element.value && (element.value = option.selectValue)
                }

                function updateOptions() {
                    var previousValue = options && selectCtrl.readValue();
                    if (options)for (var i = options.items.length - 1; i >= 0; i--) {
                        var option = options.items[i];
                        jqLiteRemove(isDefined(option.group) ? option.element.parentNode : option.element)
                    }
                    options = ngOptions.getOptions();
                    var groupElementMap = {};
                    if (providedEmptyOption && selectElement.prepend(emptyOption), options.items.forEach(function (option) {
                            var groupElement;
                            isDefined(option.group) ? (groupElement = groupElementMap[option.group], groupElement || (groupElement = optGroupTemplate.cloneNode(!1), listFragment.appendChild(groupElement), groupElement.label = null === option.group ? "null" : option.group, groupElementMap[option.group] = groupElement), addOptionElement(option, groupElement)) : addOptionElement(option, listFragment)
                        }), selectElement[0].appendChild(listFragment), ngModelCtrl.$render(), !ngModelCtrl.$isEmpty(previousValue)) {
                        var nextValue = selectCtrl.readValue(), isNotPrimitive = ngOptions.trackBy || multiple;
                        (isNotPrimitive ? equals(previousValue, nextValue) : previousValue === nextValue) || (ngModelCtrl.$setViewValue(nextValue), ngModelCtrl.$render())
                    }
                }

                for (var emptyOption, selectCtrl = ctrls[0], ngModelCtrl = ctrls[1], multiple = attr.multiple, i = 0, children = selectElement.children(), ii = children.length; ii > i; i++)if ("" === children[i].value) {
                    emptyOption = children.eq(i);
                    break
                }
                var providedEmptyOption = !!emptyOption, unknownOption = jqLite(optionTemplate.cloneNode(!1));
                unknownOption.val("?");
                var options, ngOptions = parseOptionsExpression(attr.ngOptions, selectElement, scope), listFragment = $document[0].createDocumentFragment(), renderEmptyOption = function () {
                    providedEmptyOption || selectElement.prepend(emptyOption), selectElement.val(""), emptyOption.prop("selected", !0), emptyOption.attr("selected", !0)
                }, removeEmptyOption = function () {
                    providedEmptyOption || emptyOption.remove()
                }, renderUnknownOption = function () {
                    selectElement.prepend(unknownOption), selectElement.val("?"), unknownOption.prop("selected", !0), unknownOption.attr("selected", !0)
                }, removeUnknownOption = function () {
                    unknownOption.remove()
                };
                multiple ? (ngModelCtrl.$isEmpty = function (value) {
                        return !value || 0 === value.length
                    }, selectCtrl.writeValue = function (value) {
                        options.items.forEach(function (option) {
                            option.element.selected = !1
                        }), value && value.forEach(function (item) {
                            var option = options.getOptionFromViewValue(item);
                            option && (option.element.selected = !0)
                        })
                    }, selectCtrl.readValue = function () {
                        var selectedValues = selectElement.val() || [], selections = [];
                        return forEach(selectedValues, function (value) {
                            var option = options.selectValueMap[value];
                            option && !option.disabled && selections.push(options.getViewValueFromOption(option))
                        }), selections
                    }, ngOptions.trackBy && scope.$watchCollection(function () {
                        return isArray(ngModelCtrl.$viewValue) ? ngModelCtrl.$viewValue.map(function (value) {
                                return ngOptions.getTrackByValue(value)
                            }) : void 0
                    }, function () {
                        ngModelCtrl.$render()
                    })) : (selectCtrl.writeValue = function (value) {
                        var option = options.getOptionFromViewValue(value);
                        option ? (selectElement[0].value !== option.selectValue && (removeUnknownOption(), removeEmptyOption(), selectElement[0].value = option.selectValue, option.element.selected = !0), option.element.setAttribute("selected", "selected")) : null === value || providedEmptyOption ? (removeUnknownOption(), renderEmptyOption()) : (removeEmptyOption(), renderUnknownOption())
                    }, selectCtrl.readValue = function () {
                        var selectedOption = options.selectValueMap[selectElement.val()];
                        return selectedOption && !selectedOption.disabled ? (removeEmptyOption(), removeUnknownOption(), options.getViewValueFromOption(selectedOption)) : null
                    }, ngOptions.trackBy && scope.$watch(function () {
                        return ngOptions.getTrackByValue(ngModelCtrl.$viewValue)
                    }, function () {
                        ngModelCtrl.$render()
                    })), providedEmptyOption ? (emptyOption.remove(), $compile(emptyOption)(scope), emptyOption.removeClass("ng-scope")) : emptyOption = jqLite(optionTemplate.cloneNode(!1)), selectElement.empty(), updateOptions(), scope.$watchCollection(ngOptions.getWatchables, updateOptions)
            }

            var optionTemplate = window.document.createElement("option"), optGroupTemplate = window.document.createElement("optgroup");
            return {
                restrict: "A", terminal: !0, require: ["select", "ngModel"], link: {
                    pre: function (scope, selectElement, attr, ctrls) {
                        ctrls[0].registerOption = noop
                    }, post: ngOptionsPostLink
                }
            }
        }], ngPluralizeDirective = ["$locale", "$interpolate", "$log", function ($locale, $interpolate, $log) {
            var BRACE = /{}/g, IS_WHEN = /^when(Minus)?(.+)$/;
            return {
                link: function (scope, element, attr) {
                    function updateElementText(newText) {
                        element.text(newText || "")
                    }

                    var lastCount, numberExp = attr.count, whenExp = attr.$attr.when && element.attr(attr.$attr.when), offset = attr.offset || 0, whens = scope.$eval(whenExp) || {}, whensExpFns = {}, startSymbol = $interpolate.startSymbol(), endSymbol = $interpolate.endSymbol(), braceReplacement = startSymbol + numberExp + "-" + offset + endSymbol, watchRemover = angular.noop;
                    forEach(attr, function (expression, attributeName) {
                        var tmpMatch = IS_WHEN.exec(attributeName);
                        if (tmpMatch) {
                            var whenKey = (tmpMatch[1] ? "-" : "") + lowercase(tmpMatch[2]);
                            whens[whenKey] = element.attr(attr.$attr[attributeName])
                        }
                    }), forEach(whens, function (expression, key) {
                        whensExpFns[key] = $interpolate(expression.replace(BRACE, braceReplacement))
                    }), scope.$watch(numberExp, function (newVal) {
                        var count = parseFloat(newVal), countIsNaN = isNaN(count);
                        if (countIsNaN || count in whens || (count = $locale.pluralCat(count - offset)), count !== lastCount && !(countIsNaN && isNumber(lastCount) && isNaN(lastCount))) {
                            watchRemover();
                            var whenExpFn = whensExpFns[count];
                            isUndefined(whenExpFn) ? (null != newVal && $log.debug("ngPluralize: no rule defined for '" + count + "' in " + whenExp), watchRemover = noop, updateElementText()) : watchRemover = scope.$watch(whenExpFn, updateElementText), lastCount = count
                        }
                    })
                }
            }
        }], ngRepeatDirective = ["$parse", "$animate", "$compile", function ($parse, $animate, $compile) {
            var NG_REMOVED = "$$NG_REMOVED", ngRepeatMinErr = minErr("ngRepeat"), updateScope = function (scope, index, valueIdentifier, value, keyIdentifier, key, arrayLength) {
                scope[valueIdentifier] = value, keyIdentifier && (scope[keyIdentifier] = key), scope.$index = index, scope.$first = 0 === index, scope.$last = index === arrayLength - 1, scope.$middle = !(scope.$first || scope.$last), scope.$odd = !(scope.$even = 0 === (1 & index))
            }, getBlockStart = function (block) {
                return block.clone[0]
            }, getBlockEnd = function (block) {
                return block.clone[block.clone.length - 1]
            };
            return {
                restrict: "A",
                multiElement: !0,
                transclude: "element",
                priority: 1e3,
                terminal: !0,
                $$tlb: !0,
                compile: function ($element, $attr) {
                    var expression = $attr.ngRepeat, ngRepeatEndComment = $compile.$$createComment("end ngRepeat", expression), match = expression.match(/^\s*([\s\S]+?)\s+in\s+([\s\S]+?)(?:\s+as\s+([\s\S]+?))?(?:\s+track\s+by\s+([\s\S]+?))?\s*$/);
                    if (!match)throw ngRepeatMinErr("iexp", "Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.", expression);
                    var lhs = match[1], rhs = match[2], aliasAs = match[3], trackByExp = match[4];
                    if (match = lhs.match(/^(?:(\s*[\$\w]+)|\(\s*([\$\w]+)\s*,\s*([\$\w]+)\s*\))$/), !match)throw ngRepeatMinErr("iidexp", "'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.", lhs);
                    var valueIdentifier = match[3] || match[1], keyIdentifier = match[2];
                    if (aliasAs && (!/^[$a-zA-Z_][$a-zA-Z0-9_]*$/.test(aliasAs) || /^(null|undefined|this|\$index|\$first|\$middle|\$last|\$even|\$odd|\$parent|\$root|\$id)$/.test(aliasAs)))throw ngRepeatMinErr("badident", "alias '{0}' is invalid --- must be a valid JS identifier which is not a reserved name.", aliasAs);
                    var trackByExpGetter, trackByIdExpFn, trackByIdArrayFn, trackByIdObjFn, hashFnLocals = {$id: hashKey};
                    return trackByExp ? trackByExpGetter = $parse(trackByExp) : (trackByIdArrayFn = function (key, value) {
                            return hashKey(value)
                        }, trackByIdObjFn = function (key) {
                            return key
                        }), function ($scope, $element, $attr, ctrl, $transclude) {
                        trackByExpGetter && (trackByIdExpFn = function (key, value, index) {
                            return keyIdentifier && (hashFnLocals[keyIdentifier] = key), hashFnLocals[valueIdentifier] = value, hashFnLocals.$index = index, trackByExpGetter($scope, hashFnLocals)
                        });
                        var lastBlockMap = createMap();
                        $scope.$watchCollection(rhs, function (collection) {
                            var index, length, nextNode, collectionLength, key, value, trackById, trackByIdFn, collectionKeys, block, nextBlockOrder, elementsToRemove, previousNode = $element[0], nextBlockMap = createMap();
                            if (aliasAs && ($scope[aliasAs] = collection), isArrayLike(collection)) collectionKeys = collection, trackByIdFn = trackByIdExpFn || trackByIdArrayFn; else {
                                trackByIdFn = trackByIdExpFn || trackByIdObjFn, collectionKeys = [];
                                for (var itemKey in collection)hasOwnProperty.call(collection, itemKey) && "$" !== itemKey.charAt(0) && collectionKeys.push(itemKey)
                            }
                            for (collectionLength = collectionKeys.length, nextBlockOrder = new Array(collectionLength), index = 0; collectionLength > index; index++)if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], trackById = trackByIdFn(key, value, index), lastBlockMap[trackById]) block = lastBlockMap[trackById], delete lastBlockMap[trackById], nextBlockMap[trackById] = block, nextBlockOrder[index] = block; else {
                                if (nextBlockMap[trackById])throw forEach(nextBlockOrder, function (block) {
                                    block && block.scope && (lastBlockMap[block.id] = block)
                                }), ngRepeatMinErr("dupes", "Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}, Duplicate value: {2}", expression, trackById, value);
                                nextBlockOrder[index] = {
                                    id: trackById,
                                    scope: void 0,
                                    clone: void 0
                                }, nextBlockMap[trackById] = !0
                            }
                            for (var blockKey in lastBlockMap) {
                                if (block = lastBlockMap[blockKey], elementsToRemove = getBlockNodes(block.clone), $animate.leave(elementsToRemove), elementsToRemove[0].parentNode)for (index = 0, length = elementsToRemove.length; length > index; index++)elementsToRemove[index][NG_REMOVED] = !0;
                                block.scope.$destroy()
                            }
                            for (index = 0; collectionLength > index; index++)if (key = collection === collectionKeys ? index : collectionKeys[index], value = collection[key], block = nextBlockOrder[index], block.scope) {
                                nextNode = previousNode;
                                do nextNode = nextNode.nextSibling; while (nextNode && nextNode[NG_REMOVED]);
                                getBlockStart(block) != nextNode && $animate.move(getBlockNodes(block.clone), null, previousNode), previousNode = getBlockEnd(block), updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength)
                            } else $transclude(function (clone, scope) {
                                block.scope = scope;
                                var endNode = ngRepeatEndComment.cloneNode(!1);
                                clone[clone.length++] = endNode, $animate.enter(clone, null, previousNode), previousNode = endNode, block.clone = clone, nextBlockMap[block.id] = block, updateScope(block.scope, index, valueIdentifier, value, keyIdentifier, key, collectionLength)
                            });
                            lastBlockMap = nextBlockMap
                        })
                    }
                }
            }
        }], NG_HIDE_CLASS = "ng-hide", NG_HIDE_IN_PROGRESS_CLASS = "ng-hide-animate", ngShowDirective = ["$animate", function ($animate) {
            return {
                restrict: "A", multiElement: !0, link: function (scope, element, attr) {
                    scope.$watch(attr.ngShow, function (value) {
                        $animate[value ? "removeClass" : "addClass"](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS})
                    })
                }
            }
        }], ngHideDirective = ["$animate", function ($animate) {
            return {
                restrict: "A", multiElement: !0, link: function (scope, element, attr) {
                    scope.$watch(attr.ngHide, function (value) {
                        $animate[value ? "addClass" : "removeClass"](element, NG_HIDE_CLASS, {tempClasses: NG_HIDE_IN_PROGRESS_CLASS})
                    })
                }
            }
        }], ngStyleDirective = ngDirective(function (scope, element, attr) {
            scope.$watch(attr.ngStyle, function (newStyles, oldStyles) {
                oldStyles && newStyles !== oldStyles && forEach(oldStyles, function (val, style) {
                    element.css(style, "")
                }), newStyles && element.css(newStyles)
            }, !0)
        }), ngSwitchDirective = ["$animate", "$compile", function ($animate, $compile) {
            return {
                require: "ngSwitch", controller: ["$scope", function () {
                    this.cases = {}
                }], link: function (scope, element, attr, ngSwitchController) {
                    var watchExpr = attr.ngSwitch || attr.on, selectedTranscludes = [], selectedElements = [], previousLeaveAnimations = [], selectedScopes = [], spliceFactory = function (array, index) {
                        return function () {
                            array.splice(index, 1)
                        }
                    };
                    scope.$watch(watchExpr, function (value) {
                        var i, ii;
                        for (i = 0, ii = previousLeaveAnimations.length; ii > i; ++i)$animate.cancel(previousLeaveAnimations[i]);
                        for (previousLeaveAnimations.length = 0, i = 0, ii = selectedScopes.length; ii > i; ++i) {
                            var selected = getBlockNodes(selectedElements[i].clone);
                            selectedScopes[i].$destroy();
                            var promise = previousLeaveAnimations[i] = $animate.leave(selected);
                            promise.then(spliceFactory(previousLeaveAnimations, i))
                        }
                        selectedElements.length = 0, selectedScopes.length = 0, (selectedTranscludes = ngSwitchController.cases["!" + value] || ngSwitchController.cases["?"]) && forEach(selectedTranscludes, function (selectedTransclude) {
                            selectedTransclude.transclude(function (caseElement, selectedScope) {
                                selectedScopes.push(selectedScope);
                                var anchor = selectedTransclude.element;
                                caseElement[caseElement.length++] = $compile.$$createComment("end ngSwitchWhen");
                                var block = {clone: caseElement};
                                selectedElements.push(block), $animate.enter(caseElement, anchor.parent(), anchor)
                            })
                        })
                    })
                }
            }
        }], ngSwitchWhenDirective = ngDirective({
            transclude: "element",
            priority: 1200,
            require: "^ngSwitch",
            multiElement: !0,
            link: function (scope, element, attrs, ctrl, $transclude) {
                ctrl.cases["!" + attrs.ngSwitchWhen] = ctrl.cases["!" + attrs.ngSwitchWhen] || [], ctrl.cases["!" + attrs.ngSwitchWhen].push({
                    transclude: $transclude,
                    element: element
                })
            }
        }), ngSwitchDefaultDirective = ngDirective({
            transclude: "element",
            priority: 1200,
            require: "^ngSwitch",
            multiElement: !0,
            link: function (scope, element, attr, ctrl, $transclude) {
                ctrl.cases["?"] = ctrl.cases["?"] || [], ctrl.cases["?"].push({
                    transclude: $transclude,
                    element: element
                })
            }
        }), ngTranscludeMinErr = minErr("ngTransclude"), ngTranscludeDirective = ["$compile", function ($compile) {
            return {
                restrict: "EAC", terminal: !0, compile: function (tElement) {
                    var fallbackLinkFn = $compile(tElement.contents());
                    return tElement.empty(), function ($scope, $element, $attrs, controller, $transclude) {
                        function ngTranscludeCloneAttachFn(clone, transcludedScope) {
                            clone.length ? $element.append(clone) : (useFallbackContent(), transcludedScope.$destroy())
                        }

                        function useFallbackContent() {
                            fallbackLinkFn($scope, function (clone) {
                                $element.append(clone)
                            })
                        }

                        if (!$transclude)throw ngTranscludeMinErr("orphan", "Illegal use of ngTransclude directive in the template! No parent directive that requires a transclusion found. Element: {0}", startingTag($element));
                        $attrs.ngTransclude === $attrs.$attr.ngTransclude && ($attrs.ngTransclude = "");
                        var slotName = $attrs.ngTransclude || $attrs.ngTranscludeSlot;
                        $transclude(ngTranscludeCloneAttachFn, null, slotName), slotName && !$transclude.isSlotFilled(slotName) && useFallbackContent()
                    }
                }
            }
        }], scriptDirective = ["$templateCache", function ($templateCache) {
            return {
                restrict: "E", terminal: !0, compile: function (element, attr) {
                    if ("text/ng-template" == attr.type) {
                        var templateUrl = attr.id, text = element[0].text;
                        $templateCache.put(templateUrl, text)
                    }
                }
            }
        }], noopNgModelController = {
            $setViewValue: noop,
            $render: noop
        }, SelectController = ["$element", "$scope", function ($element, $scope) {
            var self = this, optionsMap = new HashMap;
            self.ngModelCtrl = noopNgModelController, self.unknownOption = jqLite(window.document.createElement("option")), self.renderUnknownOption = function (val) {
                var unknownVal = "? " + hashKey(val) + " ?";
                self.unknownOption.val(unknownVal), $element.prepend(self.unknownOption), $element.val(unknownVal)
            }, $scope.$on("$destroy", function () {
                self.renderUnknownOption = noop
            }), self.removeUnknownOption = function () {
                self.unknownOption.parent() && self.unknownOption.remove()
            }, self.readValue = function () {
                return self.removeUnknownOption(), $element.val()
            }, self.writeValue = function (value) {
                self.hasOption(value) ? (self.removeUnknownOption(), $element.val(value), "" === value && self.emptyOption.prop("selected", !0)) : null == value && self.emptyOption ? (self.removeUnknownOption(), $element.val("")) : self.renderUnknownOption(value)
            }, self.addOption = function (value, element) {
                if (element[0].nodeType !== NODE_TYPE_COMMENT) {
                    assertNotHasOwnProperty(value, '"option value"'), "" === value && (self.emptyOption = element);
                    var count = optionsMap.get(value) || 0;
                    optionsMap.put(value, count + 1), self.ngModelCtrl.$render(), chromeHack(element)
                }
            }, self.removeOption = function (value) {
                var count = optionsMap.get(value);
                count && (1 === count ? (optionsMap.remove(value), "" === value && (self.emptyOption = void 0)) : optionsMap.put(value, count - 1))
            }, self.hasOption = function (value) {
                return !!optionsMap.get(value)
            }, self.registerOption = function (optionScope, optionElement, optionAttrs, interpolateValueFn, interpolateTextFn) {
                if (interpolateValueFn) {
                    var oldVal;
                    optionAttrs.$observe("value", function (newVal) {
                        isDefined(oldVal) && self.removeOption(oldVal), oldVal = newVal, self.addOption(newVal, optionElement)
                    })
                } else interpolateTextFn ? optionScope.$watch(interpolateTextFn, function (newVal, oldVal) {
                        optionAttrs.$set("value", newVal), oldVal !== newVal && self.removeOption(oldVal), self.addOption(newVal, optionElement)
                    }) : self.addOption(optionAttrs.value, optionElement);
                optionElement.on("$destroy", function () {
                    self.removeOption(optionAttrs.value), self.ngModelCtrl.$render()
                })
            }
        }], selectDirective = function () {
            function selectPreLink(scope, element, attr, ctrls) {
                var ngModelCtrl = ctrls[1];
                if (ngModelCtrl) {
                    var selectCtrl = ctrls[0];
                    if (selectCtrl.ngModelCtrl = ngModelCtrl, element.on("change", function () {
                            scope.$apply(function () {
                                ngModelCtrl.$setViewValue(selectCtrl.readValue())
                            })
                        }), attr.multiple) {
                        selectCtrl.readValue = function () {
                            var array = [];
                            return forEach(element.find("option"), function (option) {
                                option.selected && array.push(option.value)
                            }), array
                        }, selectCtrl.writeValue = function (value) {
                            var items = new HashMap(value);
                            forEach(element.find("option"), function (option) {
                                option.selected = isDefined(items.get(option.value))
                            })
                        };
                        var lastView, lastViewRef = NaN;
                        scope.$watch(function () {
                            lastViewRef !== ngModelCtrl.$viewValue || equals(lastView, ngModelCtrl.$viewValue) || (lastView = shallowCopy(ngModelCtrl.$viewValue), ngModelCtrl.$render()), lastViewRef = ngModelCtrl.$viewValue
                        }), ngModelCtrl.$isEmpty = function (value) {
                            return !value || 0 === value.length
                        }
                    }
                }
            }

            function selectPostLink(scope, element, attrs, ctrls) {
                var ngModelCtrl = ctrls[1];
                if (ngModelCtrl) {
                    var selectCtrl = ctrls[0];
                    ngModelCtrl.$render = function () {
                        selectCtrl.writeValue(ngModelCtrl.$viewValue)
                    }
                }
            }

            return {
                restrict: "E",
                require: ["select", "?ngModel"],
                controller: SelectController,
                priority: 1,
                link: {pre: selectPreLink, post: selectPostLink}
            }
        }, optionDirective = ["$interpolate", function ($interpolate) {
            return {
                restrict: "E", priority: 100, compile: function (element, attr) {
                    if (isDefined(attr.value))var interpolateValueFn = $interpolate(attr.value, !0); else {
                        var interpolateTextFn = $interpolate(element.text(), !0);
                        interpolateTextFn || attr.$set("value", element.text())
                    }
                    return function (scope, element, attr) {
                        var selectCtrlName = "$selectController", parent = element.parent(), selectCtrl = parent.data(selectCtrlName) || parent.parent().data(selectCtrlName);
                        selectCtrl && selectCtrl.registerOption(scope, element, attr, interpolateValueFn, interpolateTextFn)
                    }
                }
            }
        }], styleDirective = valueFn({restrict: "E", terminal: !1}), requiredDirective = function () {
            return {
                restrict: "A", require: "?ngModel", link: function (scope, elm, attr, ctrl) {
                    ctrl && (attr.required = !0, ctrl.$validators.required = function (modelValue, viewValue) {
                        return !attr.required || !ctrl.$isEmpty(viewValue)
                    }, attr.$observe("required", function () {
                        ctrl.$validate()
                    }))
                }
            }
        }, patternDirective = function () {
            return {
                restrict: "A", require: "?ngModel", link: function (scope, elm, attr, ctrl) {
                    if (ctrl) {
                        var regexp, patternExp = attr.ngPattern || attr.pattern;
                        attr.$observe("pattern", function (regex) {
                            if (isString(regex) && regex.length > 0 && (regex = new RegExp("^" + regex + "$")), regex && !regex.test)throw minErr("ngPattern")("noregexp", "Expected {0} to be a RegExp but was {1}. Element: {2}", patternExp, regex, startingTag(elm));
                            regexp = regex || void 0, ctrl.$validate()
                        }), ctrl.$validators.pattern = function (modelValue, viewValue) {
                            return ctrl.$isEmpty(viewValue) || isUndefined(regexp) || regexp.test(viewValue)
                        }
                    }
                }
            }
        }, maxlengthDirective = function () {
            return {
                restrict: "A", require: "?ngModel", link: function (scope, elm, attr, ctrl) {
                    if (ctrl) {
                        var maxlength = -1;
                        attr.$observe("maxlength", function (value) {
                            var intVal = toInt(value);
                            maxlength = isNaN(intVal) ? -1 : intVal, ctrl.$validate()
                        }), ctrl.$validators.maxlength = function (modelValue, viewValue) {
                            return 0 > maxlength || ctrl.$isEmpty(viewValue) || viewValue.length <= maxlength
                        }
                    }
                }
            }
        }, minlengthDirective = function () {
            return {
                restrict: "A", require: "?ngModel", link: function (scope, elm, attr, ctrl) {
                    if (ctrl) {
                        var minlength = 0;
                        attr.$observe("minlength", function (value) {
                            minlength = toInt(value) || 0, ctrl.$validate()
                        }), ctrl.$validators.minlength = function (modelValue, viewValue) {
                            return ctrl.$isEmpty(viewValue) || viewValue.length >= minlength
                        }
                    }
                }
            }
        };
        return window.angular.bootstrap ? void(window.console && console.log("WARNING: Tried to load angular more than once.")) : (bindJQuery(), publishExternalAPI(angular), angular.module("ngLocale", [], ["$provide", function ($provide) {
                function getDecimals(n) {
                    n += "";
                    var i = n.indexOf(".");
                    return -1 == i ? 0 : n.length - i - 1
                }

                function getVF(n, opt_precision) {
                    var v = opt_precision;
                    void 0 === v && (v = Math.min(getDecimals(n), 3));
                    var base = Math.pow(10, v), f = (n * base | 0) % base;
                    return {v: v, f: f}
                }

                var PLURAL_CATEGORY = {ZERO: "zero", ONE: "one", TWO: "two", FEW: "few", MANY: "many", OTHER: "other"};
                $provide.value("$locale", {
                    DATETIME_FORMATS: {
                        AMPMS: ["AM", "PM"],
                        DAY: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
                        ERANAMES: ["Before Christ", "Anno Domini"],
                        ERAS: ["BC", "AD"],
                        FIRSTDAYOFWEEK: 6,
                        MONTH: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                        SHORTDAY: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
                        SHORTMONTH: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
                        STANDALONEMONTH: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
                        WEEKENDRANGE: [5, 6],
                        fullDate: "EEEE, MMMM d, y",
                        longDate: "MMMM d, y",
                        medium: "MMM d, y h:mm:ss a",
                        mediumDate: "MMM d, y",
                        mediumTime: "h:mm:ss a",
                        "short": "M/d/yy h:mm a",
                        shortDate: "M/d/yy",
                        shortTime: "h:mm a"
                    },
                    NUMBER_FORMATS: {
                        CURRENCY_SYM: "$",
                        DECIMAL_SEP: ".",
                        GROUP_SEP: ",",
                        PATTERNS: [{
                            gSize: 3,
                            lgSize: 3,
                            maxFrac: 3,
                            minFrac: 0,
                            minInt: 1,
                            negPre: "-",
                            negSuf: "",
                            posPre: "",
                            posSuf: ""
                        }, {
                            gSize: 3,
                            lgSize: 3,
                            maxFrac: 2,
                            minFrac: 2,
                            minInt: 1,
                            negPre: "-¤",
                            negSuf: "",
                            posPre: "¤",
                            posSuf: ""
                        }]
                    },
                    id: "en-us",
                    localeID: "en_US",
                    pluralCat: function (n, opt_precision) {
                        var i = 0 | n, vf = getVF(n, opt_precision);
                        return 1 == i && 0 == vf.v ? PLURAL_CATEGORY.ONE : PLURAL_CATEGORY.OTHER
                    }
                })
            }]), void jqLite(window.document).ready(function () {
                angularInit(window.document, bootstrap)
            }))
    }(window), !window.angular.$$csp().noInlineStyle && window.angular.element(document.head).prepend('<style type="text/css">@charset "UTF-8";[ng\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide:not(.ng-hide-animate){display:none !important;}ng\\:form{display:block;}.ng-animate-shim{visibility:hidden;}.ng-anchor{position:absolute;}</style>'), "undefined" == typeof jQuery)throw new Error("Bootstrap's JavaScript requires jQuery");
+function ($) {
    "use strict";
    var version = $.fn.jquery.split(" ")[0].split(".");
    if (version[0] < 2 && version[1] < 9 || 1 == version[0] && 9 == version[1] && version[2] < 1 || version[0] > 3)throw new Error("Bootstrap's JavaScript requires jQuery version 1.9.1 or higher, but lower than version 4")
}(jQuery), +function ($) {
    "use strict";
    function transitionEnd() {
        var el = document.createElement("bootstrap"), transEndEventNames = {
            WebkitTransition: "webkitTransitionEnd",
            MozTransition: "transitionend",
            OTransition: "oTransitionEnd otransitionend",
            transition: "transitionend"
        };
        for (var name in transEndEventNames)if (void 0 !== el.style[name])return {end: transEndEventNames[name]};
        return !1
    }

    $.fn.emulateTransitionEnd = function (duration) {
        var called = !1, $el = this;
        $(this).one("bsTransitionEnd", function () {
            called = !0
        });
        var callback = function () {
            called || $($el).trigger($.support.transition.end)
        };
        return setTimeout(callback, duration), this
    }, $(function () {
        $.support.transition = transitionEnd(), $.support.transition && ($.event.special.bsTransitionEnd = {
            bindType: $.support.transition.end,
            delegateType: $.support.transition.end,
            handle: function (e) {
                return $(e.target).is(this) ? e.handleObj.handler.apply(this, arguments) : void 0
            }
        })
    })
}(jQuery), +function ($) {
    "use strict";
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this), data = $this.data("bs.alert");
            data || $this.data("bs.alert", data = new Alert(this)), "string" == typeof option && data[option].call($this)
        })
    }

    var dismiss = '[data-dismiss="alert"]', Alert = function (el) {
        $(el).on("click", dismiss, this.close)
    };
    Alert.VERSION = "3.3.7", Alert.TRANSITION_DURATION = 150, Alert.prototype.close = function (e) {
        function removeElement() {
            $parent.detach().trigger("closed.bs.alert").remove()
        }

        var $this = $(this), selector = $this.attr("data-target");
        selector || (selector = $this.attr("href"), selector = selector && selector.replace(/.*(?=#[^\s]*$)/, ""));
        var $parent = $("#" === selector ? [] : selector);
        e && e.preventDefault(), $parent.length || ($parent = $this.closest(".alert")), $parent.trigger(e = $.Event("close.bs.alert")), e.isDefaultPrevented() || ($parent.removeClass("in"), $.support.transition && $parent.hasClass("fade") ? $parent.one("bsTransitionEnd", removeElement).emulateTransitionEnd(Alert.TRANSITION_DURATION) : removeElement())
    };
    var old = $.fn.alert;
    $.fn.alert = Plugin, $.fn.alert.Constructor = Alert, $.fn.alert.noConflict = function () {
        return $.fn.alert = old, this
    }, $(document).on("click.bs.alert.data-api", dismiss, Alert.prototype.close)
}(jQuery), +function ($) {
    "use strict";
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this), data = $this.data("bs.button"), options = "object" == typeof option && option;
            data || $this.data("bs.button", data = new Button(this, options)), "toggle" == option ? data.toggle() : option && data.setState(option)
        })
    }

    var Button = function (element, options) {
        this.$element = $(element), this.options = $.extend({}, Button.DEFAULTS, options), this.isLoading = !1
    };
    Button.VERSION = "3.3.7", Button.DEFAULTS = {loadingText: "loading..."}, Button.prototype.setState = function (state) {
        var d = "disabled", $el = this.$element, val = $el.is("input") ? "val" : "html", data = $el.data();
        state += "Text", null == data.resetText && $el.data("resetText", $el[val]()), setTimeout($.proxy(function () {
            $el[val](null == data[state] ? this.options[state] : data[state]), "loadingText" == state ? (this.isLoading = !0, $el.addClass(d).attr(d, d).prop(d, !0)) : this.isLoading && (this.isLoading = !1, $el.removeClass(d).removeAttr(d).prop(d, !1))
        }, this), 0)
    }, Button.prototype.toggle = function () {
        var changed = !0, $parent = this.$element.closest('[data-toggle="buttons"]');
        if ($parent.length) {
            var $input = this.$element.find("input");
            "radio" == $input.prop("type") ? ($input.prop("checked") && (changed = !1), $parent.find(".active").removeClass("active"), this.$element.addClass("active")) : "checkbox" == $input.prop("type") && ($input.prop("checked") !== this.$element.hasClass("active") && (changed = !1), this.$element.toggleClass("active")), $input.prop("checked", this.$element.hasClass("active")), changed && $input.trigger("change")
        } else this.$element.attr("aria-pressed", !this.$element.hasClass("active")), this.$element.toggleClass("active")
    };
    var old = $.fn.button;
    $.fn.button = Plugin, $.fn.button.Constructor = Button, $.fn.button.noConflict = function () {
        return $.fn.button = old, this
    }, $(document).on("click.bs.button.data-api", '[data-toggle^="button"]', function (e) {
        var $btn = $(e.target).closest(".btn");
        Plugin.call($btn, "toggle"), $(e.target).is('input[type="radio"], input[type="checkbox"]') || (e.preventDefault(), $btn.is("input,button") ? $btn.trigger("focus") : $btn.find("input:visible,button:visible").first().trigger("focus"))
    }).on("focus.bs.button.data-api blur.bs.button.data-api", '[data-toggle^="button"]', function (e) {
        $(e.target).closest(".btn").toggleClass("focus", /^focus(in)?$/.test(e.type))
    })
}(jQuery), +function ($) {
    "use strict";
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this), data = $this.data("bs.carousel"), options = $.extend({}, Carousel.DEFAULTS, $this.data(), "object" == typeof option && option), action = "string" == typeof option ? option : options.slide;
            data || $this.data("bs.carousel", data = new Carousel(this, options)), "number" == typeof option ? data.to(option) : action ? data[action]() : options.interval && data.pause().cycle()
        })
    }

    var Carousel = function (element, options) {
        this.$element = $(element), this.$indicators = this.$element.find(".carousel-indicators"), this.options = options, this.paused = null, this.sliding = null, this.interval = null, this.$active = null, this.$items = null, this.options.keyboard && this.$element.on("keydown.bs.carousel", $.proxy(this.keydown, this)), "hover" == this.options.pause && !("ontouchstart" in document.documentElement) && this.$element.on("mouseenter.bs.carousel", $.proxy(this.pause, this)).on("mouseleave.bs.carousel", $.proxy(this.cycle, this))
    };
    Carousel.VERSION = "3.3.7", Carousel.TRANSITION_DURATION = 600, Carousel.DEFAULTS = {
        interval: 5e3,
        pause: "hover",
        wrap: !0,
        keyboard: !0
    }, Carousel.prototype.keydown = function (e) {
        if (!/input|textarea/i.test(e.target.tagName)) {
            switch (e.which) {
                case 37:
                    this.prev();
                    break;
                case 39:
                    this.next();
                    break;
                default:
                    return
            }
            e.preventDefault()
        }
    }, Carousel.prototype.cycle = function (e) {
        return e || (this.paused = !1), this.interval && clearInterval(this.interval), this.options.interval && !this.paused && (this.interval = setInterval($.proxy(this.next, this), this.options.interval)), this
    }, Carousel.prototype.getItemIndex = function (item) {
        return this.$items = item.parent().children(".item"), this.$items.index(item || this.$active)
    }, Carousel.prototype.getItemForDirection = function (direction, active) {
        var activeIndex = this.getItemIndex(active), willWrap = "prev" == direction && 0 === activeIndex || "next" == direction && activeIndex == this.$items.length - 1;
        if (willWrap && !this.options.wrap)return active;
        var delta = "prev" == direction ? -1 : 1, itemIndex = (activeIndex + delta) % this.$items.length;
        return this.$items.eq(itemIndex)
    }, Carousel.prototype.to = function (pos) {
        var that = this, activeIndex = this.getItemIndex(this.$active = this.$element.find(".item.active"));
        return pos > this.$items.length - 1 || 0 > pos ? void 0 : this.sliding ? this.$element.one("slid.bs.carousel", function () {
                    that.to(pos)
                }) : activeIndex == pos ? this.pause().cycle() : this.slide(pos > activeIndex ? "next" : "prev", this.$items.eq(pos))
    }, Carousel.prototype.pause = function (e) {
        return e || (this.paused = !0), this.$element.find(".next, .prev").length && $.support.transition && (this.$element.trigger($.support.transition.end), this.cycle(!0)), this.interval = clearInterval(this.interval), this
    }, Carousel.prototype.next = function () {
        return this.sliding ? void 0 : this.slide("next")
    }, Carousel.prototype.prev = function () {
        return this.sliding ? void 0 : this.slide("prev")
    }, Carousel.prototype.slide = function (type, next) {
        var $active = this.$element.find(".item.active"), $next = next || this.getItemForDirection(type, $active), isCycling = this.interval, direction = "next" == type ? "left" : "right", that = this;
        if ($next.hasClass("active"))return this.sliding = !1;
        var relatedTarget = $next[0], slideEvent = $.Event("slide.bs.carousel", {
            relatedTarget: relatedTarget,
            direction: direction
        });
        if (this.$element.trigger(slideEvent), !slideEvent.isDefaultPrevented()) {
            if (this.sliding = !0, isCycling && this.pause(), this.$indicators.length) {
                this.$indicators.find(".active").removeClass("active");
                var $nextIndicator = $(this.$indicators.children()[this.getItemIndex($next)]);
                $nextIndicator && $nextIndicator.addClass("active")
            }
            var slidEvent = $.Event("slid.bs.carousel", {relatedTarget: relatedTarget, direction: direction});
            return $.support.transition && this.$element.hasClass("slide") ? ($next.addClass(type), $next[0].offsetWidth, $active.addClass(direction), $next.addClass(direction), $active.one("bsTransitionEnd", function () {
                    $next.removeClass([type, direction].join(" ")).addClass("active"), $active.removeClass(["active", direction].join(" ")), that.sliding = !1, setTimeout(function () {
                        that.$element.trigger(slidEvent)
                    }, 0)
                }).emulateTransitionEnd(Carousel.TRANSITION_DURATION)) : ($active.removeClass("active"), $next.addClass("active"), this.sliding = !1, this.$element.trigger(slidEvent)), isCycling && this.cycle(), this
        }
    };
    var old = $.fn.carousel;
    $.fn.carousel = Plugin, $.fn.carousel.Constructor = Carousel, $.fn.carousel.noConflict = function () {
        return $.fn.carousel = old, this
    };
    var clickHandler = function (e) {
        var href, $this = $(this), $target = $($this.attr("data-target") || (href = $this.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, ""));
        if ($target.hasClass("carousel")) {
            var options = $.extend({}, $target.data(), $this.data()), slideIndex = $this.attr("data-slide-to");
            slideIndex && (options.interval = !1), Plugin.call($target, options), slideIndex && $target.data("bs.carousel").to(slideIndex), e.preventDefault()
        }
    };
    $(document).on("click.bs.carousel.data-api", "[data-slide]", clickHandler).on("click.bs.carousel.data-api", "[data-slide-to]", clickHandler), $(window).on("load", function () {
        $('[data-ride="carousel"]').each(function () {
            var $carousel = $(this);
            Plugin.call($carousel, $carousel.data())
        })
    })
}(jQuery), +function ($) {
    "use strict";
    function getTargetFromTrigger($trigger) {
        var href, target = $trigger.attr("data-target") || (href = $trigger.attr("href")) && href.replace(/.*(?=#[^\s]+$)/, "");
        return $(target)
    }

    function Plugin(option) {
        return this.each(function () {
            var $this = $(this), data = $this.data("bs.collapse"), options = $.extend({}, Collapse.DEFAULTS, $this.data(), "object" == typeof option && option);
            !data && options.toggle && /show|hide/.test(option) && (options.toggle = !1), data || $this.data("bs.collapse", data = new Collapse(this, options)), "string" == typeof option && data[option]()
        })
    }

    var Collapse = function (element, options) {
        this.$element = $(element), this.options = $.extend({}, Collapse.DEFAULTS, options), this.$trigger = $('[data-toggle="collapse"][href="#' + element.id + '"],[data-toggle="collapse"][data-target="#' + element.id + '"]'), this.transitioning = null, this.options.parent ? this.$parent = this.getParent() : this.addAriaAndCollapsedClass(this.$element, this.$trigger), this.options.toggle && this.toggle()
    };
    Collapse.VERSION = "3.3.7", Collapse.TRANSITION_DURATION = 350, Collapse.DEFAULTS = {toggle: !0}, Collapse.prototype.dimension = function () {
        var hasWidth = this.$element.hasClass("width");
        return hasWidth ? "width" : "height"
    }, Collapse.prototype.show = function () {
        if (!this.transitioning && !this.$element.hasClass("in")) {
            var activesData, actives = this.$parent && this.$parent.children(".panel").children(".in, .collapsing");
            if (!(actives && actives.length && (activesData = actives.data("bs.collapse"), activesData && activesData.transitioning))) {
                var startEvent = $.Event("show.bs.collapse");
                if (this.$element.trigger(startEvent), !startEvent.isDefaultPrevented()) {
                    actives && actives.length && (Plugin.call(actives, "hide"), activesData || actives.data("bs.collapse", null));
                    var dimension = this.dimension();
                    this.$element.removeClass("collapse").addClass("collapsing")[dimension](0).attr("aria-expanded", !0), this.$trigger.removeClass("collapsed").attr("aria-expanded", !0), this.transitioning = 1;
                    var complete = function () {
                        this.$element.removeClass("collapsing").addClass("collapse in")[dimension](""), this.transitioning = 0, this.$element.trigger("shown.bs.collapse")
                    };
                    if (!$.support.transition)return complete.call(this);
                    var scrollSize = $.camelCase(["scroll", dimension].join("-"));
                    this.$element.one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION)[dimension](this.$element[0][scrollSize])
                }
            }
        }
    }, Collapse.prototype.hide = function () {
        if (!this.transitioning && this.$element.hasClass("in")) {
            var startEvent = $.Event("hide.bs.collapse");
            if (this.$element.trigger(startEvent), !startEvent.isDefaultPrevented()) {
                var dimension = this.dimension();
                this.$element[dimension](this.$element[dimension]())[0].offsetHeight, this.$element.addClass("collapsing").removeClass("collapse in").attr("aria-expanded", !1), this.$trigger.addClass("collapsed").attr("aria-expanded", !1), this.transitioning = 1;
                var complete = function () {
                    this.transitioning = 0, this.$element.removeClass("collapsing").addClass("collapse").trigger("hidden.bs.collapse")
                };
                return $.support.transition ? void this.$element[dimension](0).one("bsTransitionEnd", $.proxy(complete, this)).emulateTransitionEnd(Collapse.TRANSITION_DURATION) : complete.call(this)
            }
        }
    }, Collapse.prototype.toggle = function () {
        this[this.$element.hasClass("in") ? "hide" : "show"]()
    }, Collapse.prototype.getParent = function () {
        return $(this.options.parent).find('[data-toggle="collapse"][data-parent="' + this.options.parent + '"]').each($.proxy(function (i, element) {
            var $element = $(element);
            this.addAriaAndCollapsedClass(getTargetFromTrigger($element), $element)
        }, this)).end()
    }, Collapse.prototype.addAriaAndCollapsedClass = function ($element, $trigger) {
        var isOpen = $element.hasClass("in");
        $element.attr("aria-expanded", isOpen), $trigger.toggleClass("collapsed", !isOpen).attr("aria-expanded", isOpen)
    };
    var old = $.fn.collapse;
    $.fn.collapse = Plugin, $.fn.collapse.Constructor = Collapse, $.fn.collapse.noConflict = function () {
        return $.fn.collapse = old, this
    }, $(document).on("click.bs.collapse.data-api", '[data-toggle="collapse"]', function (e) {
        var $this = $(this);
        $this.attr("data-target") || e.preventDefault();
        var $target = getTargetFromTrigger($this), data = $target.data("bs.collapse"), option = data ? "toggle" : $this.data();
        Plugin.call($target, option)
    })
}(jQuery), +function ($) {
    "use strict";
    function getParent($this) {
        var selector = $this.attr("data-target");
        selector || (selector = $this.attr("href"),
            selector = selector && /#[A-Za-z]/.test(selector) && selector.replace(/.*(?=#[^\s]*$)/, ""));
        var $parent = selector && $(selector);
        return $parent && $parent.length ? $parent : $this.parent()
    }

    function clearMenus(e) {
        e && 3 === e.which || ($(backdrop).remove(), $(toggle).each(function () {
            var $this = $(this), $parent = getParent($this), relatedTarget = {relatedTarget: this};
            $parent.hasClass("open") && (e && "click" == e.type && /input|textarea/i.test(e.target.tagName) && $.contains($parent[0], e.target) || ($parent.trigger(e = $.Event("hide.bs.dropdown", relatedTarget)), e.isDefaultPrevented() || ($this.attr("aria-expanded", "false"), $parent.removeClass("open").trigger($.Event("hidden.bs.dropdown", relatedTarget)))))
        }))
    }

    function Plugin(option) {
        return this.each(function () {
            var $this = $(this), data = $this.data("bs.dropdown");
            data || $this.data("bs.dropdown", data = new Dropdown(this)), "string" == typeof option && data[option].call($this)
        })
    }

    var backdrop = ".dropdown-backdrop", toggle = '[data-toggle="dropdown"]', Dropdown = function (element) {
        $(element).on("click.bs.dropdown", this.toggle)
    };
    Dropdown.VERSION = "3.3.7", Dropdown.prototype.toggle = function (e) {
        var $this = $(this);
        if (!$this.is(".disabled, :disabled")) {
            var $parent = getParent($this), isActive = $parent.hasClass("open");
            if (clearMenus(), !isActive) {
                "ontouchstart" in document.documentElement && !$parent.closest(".navbar-nav").length && $(document.createElement("div")).addClass("dropdown-backdrop").insertAfter($(this)).on("click", clearMenus);
                var relatedTarget = {relatedTarget: this};
                if ($parent.trigger(e = $.Event("show.bs.dropdown", relatedTarget)), e.isDefaultPrevented())return;
                $this.trigger("focus").attr("aria-expanded", "true"), $parent.toggleClass("open").trigger($.Event("shown.bs.dropdown", relatedTarget))
            }
            return !1
        }
    }, Dropdown.prototype.keydown = function (e) {
        if (/(38|40|27|32)/.test(e.which) && !/input|textarea/i.test(e.target.tagName)) {
            var $this = $(this);
            if (e.preventDefault(), e.stopPropagation(), !$this.is(".disabled, :disabled")) {
                var $parent = getParent($this), isActive = $parent.hasClass("open");
                if (!isActive && 27 != e.which || isActive && 27 == e.which)return 27 == e.which && $parent.find(toggle).trigger("focus"), $this.trigger("click");
                var desc = " li:not(.disabled):visible a", $items = $parent.find(".dropdown-menu" + desc);
                if ($items.length) {
                    var index = $items.index(e.target);
                    38 == e.which && index > 0 && index--, 40 == e.which && index < $items.length - 1 && index++, ~index || (index = 0), $items.eq(index).trigger("focus")
                }
            }
        }
    };
    var old = $.fn.dropdown;
    $.fn.dropdown = Plugin, $.fn.dropdown.Constructor = Dropdown, $.fn.dropdown.noConflict = function () {
        return $.fn.dropdown = old, this
    }, $(document).on("click.bs.dropdown.data-api", clearMenus).on("click.bs.dropdown.data-api", ".dropdown form", function (e) {
        e.stopPropagation()
    }).on("click.bs.dropdown.data-api", toggle, Dropdown.prototype.toggle).on("keydown.bs.dropdown.data-api", toggle, Dropdown.prototype.keydown).on("keydown.bs.dropdown.data-api", ".dropdown-menu", Dropdown.prototype.keydown)
}(jQuery), +function ($) {
    "use strict";
    function Plugin(option, _relatedTarget) {
        return this.each(function () {
            var $this = $(this), data = $this.data("bs.modal"), options = $.extend({}, Modal.DEFAULTS, $this.data(), "object" == typeof option && option);
            data || $this.data("bs.modal", data = new Modal(this, options)), "string" == typeof option ? data[option](_relatedTarget) : options.show && data.show(_relatedTarget)
        })
    }

    var Modal = function (element, options) {
        this.options = options, this.$body = $(document.body), this.$element = $(element), this.$dialog = this.$element.find(".modal-dialog"), this.$backdrop = null, this.isShown = null, this.originalBodyPad = null, this.scrollbarWidth = 0, this.ignoreBackdropClick = !1, this.options.remote && this.$element.find(".modal-content").load(this.options.remote, $.proxy(function () {
            this.$element.trigger("loaded.bs.modal")
        }, this))
    };
    Modal.VERSION = "3.3.7", Modal.TRANSITION_DURATION = 300, Modal.BACKDROP_TRANSITION_DURATION = 150, Modal.DEFAULTS = {
        backdrop: !0,
        keyboard: !0,
        show: !0
    }, Modal.prototype.toggle = function (_relatedTarget) {
        return this.isShown ? this.hide() : this.show(_relatedTarget)
    }, Modal.prototype.show = function (_relatedTarget) {
        var that = this, e = $.Event("show.bs.modal", {relatedTarget: _relatedTarget});
        this.$element.trigger(e), this.isShown || e.isDefaultPrevented() || (this.isShown = !0, this.checkScrollbar(), this.setScrollbar(), this.$body.addClass("modal-open"), this.escape(), this.resize(), this.$element.on("click.dismiss.bs.modal", '[data-dismiss="modal"]', $.proxy(this.hide, this)), this.$dialog.on("mousedown.dismiss.bs.modal", function () {
            that.$element.one("mouseup.dismiss.bs.modal", function (e) {
                $(e.target).is(that.$element) && (that.ignoreBackdropClick = !0)
            })
        }), this.backdrop(function () {
            var transition = $.support.transition && that.$element.hasClass("fade");
            that.$element.parent().length || that.$element.appendTo(that.$body), that.$element.show().scrollTop(0), that.adjustDialog(), transition && that.$element[0].offsetWidth, that.$element.addClass("in"), that.enforceFocus();
            var e = $.Event("shown.bs.modal", {relatedTarget: _relatedTarget});
            transition ? that.$dialog.one("bsTransitionEnd", function () {
                    that.$element.trigger("focus").trigger(e)
                }).emulateTransitionEnd(Modal.TRANSITION_DURATION) : that.$element.trigger("focus").trigger(e)
        }))
    }, Modal.prototype.hide = function (e) {
        e && e.preventDefault(), e = $.Event("hide.bs.modal"), this.$element.trigger(e), this.isShown && !e.isDefaultPrevented() && (this.isShown = !1, this.escape(), this.resize(), $(document).off("focusin.bs.modal"), this.$element.removeClass("in").off("click.dismiss.bs.modal").off("mouseup.dismiss.bs.modal"), this.$dialog.off("mousedown.dismiss.bs.modal"), $.support.transition && this.$element.hasClass("fade") ? this.$element.one("bsTransitionEnd", $.proxy(this.hideModal, this)).emulateTransitionEnd(Modal.TRANSITION_DURATION) : this.hideModal())
    }, Modal.prototype.enforceFocus = function () {
        $(document).off("focusin.bs.modal").on("focusin.bs.modal", $.proxy(function (e) {
            document === e.target || this.$element[0] === e.target || this.$element.has(e.target).length || this.$element.trigger("focus")
        }, this))
    }, Modal.prototype.escape = function () {
        this.isShown && this.options.keyboard ? this.$element.on("keydown.dismiss.bs.modal", $.proxy(function (e) {
                27 == e.which && this.hide()
            }, this)) : this.isShown || this.$element.off("keydown.dismiss.bs.modal")
    }, Modal.prototype.resize = function () {
        this.isShown ? $(window).on("resize.bs.modal", $.proxy(this.handleUpdate, this)) : $(window).off("resize.bs.modal")
    }, Modal.prototype.hideModal = function () {
        var that = this;
        this.$element.hide(), this.backdrop(function () {
            that.$body.removeClass("modal-open"), that.resetAdjustments(), that.resetScrollbar(), that.$element.trigger("hidden.bs.modal")
        })
    }, Modal.prototype.removeBackdrop = function () {
        this.$backdrop && this.$backdrop.remove(), this.$backdrop = null
    }, Modal.prototype.backdrop = function (callback) {
        var that = this, animate = this.$element.hasClass("fade") ? "fade" : "";
        if (this.isShown && this.options.backdrop) {
            var doAnimate = $.support.transition && animate;
            if (this.$backdrop = $(document.createElement("div")).addClass("modal-backdrop " + animate).appendTo(this.$body), this.$element.on("click.dismiss.bs.modal", $.proxy(function (e) {
                    return this.ignoreBackdropClick ? void(this.ignoreBackdropClick = !1) : void(e.target === e.currentTarget && ("static" == this.options.backdrop ? this.$element[0].focus() : this.hide()))
                }, this)), doAnimate && this.$backdrop[0].offsetWidth, this.$backdrop.addClass("in"), !callback)return;
            doAnimate ? this.$backdrop.one("bsTransitionEnd", callback).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callback()
        } else if (!this.isShown && this.$backdrop) {
            this.$backdrop.removeClass("in");
            var callbackRemove = function () {
                that.removeBackdrop(), callback && callback()
            };
            $.support.transition && this.$element.hasClass("fade") ? this.$backdrop.one("bsTransitionEnd", callbackRemove).emulateTransitionEnd(Modal.BACKDROP_TRANSITION_DURATION) : callbackRemove()
        } else callback && callback()
    }, Modal.prototype.handleUpdate = function () {
        this.adjustDialog()
    }, Modal.prototype.adjustDialog = function () {
        var modalIsOverflowing = this.$element[0].scrollHeight > document.documentElement.clientHeight;
        this.$element.css({
            paddingLeft: !this.bodyIsOverflowing && modalIsOverflowing ? this.scrollbarWidth : "",
            paddingRight: this.bodyIsOverflowing && !modalIsOverflowing ? this.scrollbarWidth : ""
        })
    }, Modal.prototype.resetAdjustments = function () {
        this.$element.css({paddingLeft: "", paddingRight: ""})
    }, Modal.prototype.checkScrollbar = function () {
        var fullWindowWidth = window.innerWidth;
        if (!fullWindowWidth) {
            var documentElementRect = document.documentElement.getBoundingClientRect();
            fullWindowWidth = documentElementRect.right - Math.abs(documentElementRect.left)
        }
        this.bodyIsOverflowing = document.body.clientWidth < fullWindowWidth, this.scrollbarWidth = this.measureScrollbar()
    }, Modal.prototype.setScrollbar = function () {
        var bodyPad = parseInt(this.$body.css("padding-right") || 0, 10);
        this.originalBodyPad = document.body.style.paddingRight || "", this.bodyIsOverflowing && this.$body.css("padding-right", bodyPad + this.scrollbarWidth)
    }, Modal.prototype.resetScrollbar = function () {
        this.$body.css("padding-right", this.originalBodyPad)
    }, Modal.prototype.measureScrollbar = function () {
        var scrollDiv = document.createElement("div");
        scrollDiv.className = "modal-scrollbar-measure", this.$body.append(scrollDiv);
        var scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        return this.$body[0].removeChild(scrollDiv), scrollbarWidth
    };
    var old = $.fn.modal;
    $.fn.modal = Plugin, $.fn.modal.Constructor = Modal, $.fn.modal.noConflict = function () {
        return $.fn.modal = old, this
    }, $(document).on("click.bs.modal.data-api", '[data-toggle="modal"]', function (e) {
        var $this = $(this), href = $this.attr("href"), $target = $($this.attr("data-target") || href && href.replace(/.*(?=#[^\s]+$)/, "")), option = $target.data("bs.modal") ? "toggle" : $.extend({remote: !/#/.test(href) && href}, $target.data(), $this.data());
        $this.is("a") && e.preventDefault(), $target.one("show.bs.modal", function (showEvent) {
            showEvent.isDefaultPrevented() || $target.one("hidden.bs.modal", function () {
                $this.is(":visible") && $this.trigger("focus")
            })
        }), Plugin.call($target, option, this)
    })
}(jQuery), +function ($) {
    "use strict";
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this), data = $this.data("bs.tooltip"), options = "object" == typeof option && option;
            (data || !/destroy|hide/.test(option)) && (data || $this.data("bs.tooltip", data = new Tooltip(this, options)), "string" == typeof option && data[option]())
        })
    }

    var Tooltip = function (element, options) {
        this.type = null, this.options = null, this.enabled = null, this.timeout = null, this.hoverState = null, this.$element = null, this.inState = null, this.init("tooltip", element, options)
    };
    Tooltip.VERSION = "3.3.7", Tooltip.TRANSITION_DURATION = 150, Tooltip.DEFAULTS = {
        animation: !0,
        placement: "top",
        selector: !1,
        template: '<div class="tooltip" role="tooltip"><div class="tooltip-arrow"></div><div class="tooltip-inner"></div></div>',
        trigger: "hover focus",
        title: "",
        delay: 0,
        html: !1,
        container: !1,
        viewport: {selector: "body", padding: 0}
    }, Tooltip.prototype.init = function (type, element, options) {
        if (this.enabled = !0, this.type = type, this.$element = $(element), this.options = this.getOptions(options), this.$viewport = this.options.viewport && $($.isFunction(this.options.viewport) ? this.options.viewport.call(this, this.$element) : this.options.viewport.selector || this.options.viewport), this.inState = {
                click: !1,
                hover: !1,
                focus: !1
            }, this.$element[0] instanceof document.constructor && !this.options.selector)throw new Error("`selector` option must be specified when initializing " + this.type + " on the window.document object!");
        for (var triggers = this.options.trigger.split(" "), i = triggers.length; i--;) {
            var trigger = triggers[i];
            if ("click" == trigger) this.$element.on("click." + this.type, this.options.selector, $.proxy(this.toggle, this)); else if ("manual" != trigger) {
                var eventIn = "hover" == trigger ? "mouseenter" : "focusin", eventOut = "hover" == trigger ? "mouseleave" : "focusout";
                this.$element.on(eventIn + "." + this.type, this.options.selector, $.proxy(this.enter, this)), this.$element.on(eventOut + "." + this.type, this.options.selector, $.proxy(this.leave, this))
            }
        }
        this.options.selector ? this._options = $.extend({}, this.options, {
                trigger: "manual",
                selector: ""
            }) : this.fixTitle()
    }, Tooltip.prototype.getDefaults = function () {
        return Tooltip.DEFAULTS
    }, Tooltip.prototype.getOptions = function (options) {
        return options = $.extend({}, this.getDefaults(), this.$element.data(), options), options.delay && "number" == typeof options.delay && (options.delay = {
            show: options.delay,
            hide: options.delay
        }), options
    }, Tooltip.prototype.getDelegateOptions = function () {
        var options = {}, defaults = this.getDefaults();
        return this._options && $.each(this._options, function (key, value) {
            defaults[key] != value && (options[key] = value)
        }), options
    }, Tooltip.prototype.enter = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        return self || (self = new this.constructor(obj.currentTarget, this.getDelegateOptions()), $(obj.currentTarget).data("bs." + this.type, self)), obj instanceof $.Event && (self.inState["focusin" == obj.type ? "focus" : "hover"] = !0), self.tip().hasClass("in") || "in" == self.hoverState ? void(self.hoverState = "in") : (clearTimeout(self.timeout), self.hoverState = "in", self.options.delay && self.options.delay.show ? void(self.timeout = setTimeout(function () {
                    "in" == self.hoverState && self.show()
                }, self.options.delay.show)) : self.show())
    }, Tooltip.prototype.isInStateTrue = function () {
        for (var key in this.inState)if (this.inState[key])return !0;
        return !1
    }, Tooltip.prototype.leave = function (obj) {
        var self = obj instanceof this.constructor ? obj : $(obj.currentTarget).data("bs." + this.type);
        return self || (self = new this.constructor(obj.currentTarget, this.getDelegateOptions()), $(obj.currentTarget).data("bs." + this.type, self)), obj instanceof $.Event && (self.inState["focusout" == obj.type ? "focus" : "hover"] = !1), self.isInStateTrue() ? void 0 : (clearTimeout(self.timeout), self.hoverState = "out", self.options.delay && self.options.delay.hide ? void(self.timeout = setTimeout(function () {
                    "out" == self.hoverState && self.hide()
                }, self.options.delay.hide)) : self.hide())
    }, Tooltip.prototype.show = function () {
        var e = $.Event("show.bs." + this.type);
        if (this.hasContent() && this.enabled) {
            this.$element.trigger(e);
            var inDom = $.contains(this.$element[0].ownerDocument.documentElement, this.$element[0]);
            if (e.isDefaultPrevented() || !inDom)return;
            var that = this, $tip = this.tip(), tipId = this.getUID(this.type);
            this.setContent(), $tip.attr("id", tipId), this.$element.attr("aria-describedby", tipId), this.options.animation && $tip.addClass("fade");
            var placement = "function" == typeof this.options.placement ? this.options.placement.call(this, $tip[0], this.$element[0]) : this.options.placement, autoToken = /\s?auto?\s?/i, autoPlace = autoToken.test(placement);
            autoPlace && (placement = placement.replace(autoToken, "") || "top"), $tip.detach().css({
                top: 0,
                left: 0,
                display: "block"
            }).addClass(placement).data("bs." + this.type, this), this.options.container ? $tip.appendTo(this.options.container) : $tip.insertAfter(this.$element), this.$element.trigger("inserted.bs." + this.type);
            var pos = this.getPosition(), actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight;
            if (autoPlace) {
                var orgPlacement = placement, viewportDim = this.getPosition(this.$viewport);
                placement = "bottom" == placement && pos.bottom + actualHeight > viewportDim.bottom ? "top" : "top" == placement && pos.top - actualHeight < viewportDim.top ? "bottom" : "right" == placement && pos.right + actualWidth > viewportDim.width ? "left" : "left" == placement && pos.left - actualWidth < viewportDim.left ? "right" : placement, $tip.removeClass(orgPlacement).addClass(placement)
            }
            var calculatedOffset = this.getCalculatedOffset(placement, pos, actualWidth, actualHeight);
            this.applyPlacement(calculatedOffset, placement);
            var complete = function () {
                var prevHoverState = that.hoverState;
                that.$element.trigger("shown.bs." + that.type), that.hoverState = null, "out" == prevHoverState && that.leave(that)
            };
            $.support.transition && this.$tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete()
        }
    }, Tooltip.prototype.applyPlacement = function (offset, placement) {
        var $tip = this.tip(), width = $tip[0].offsetWidth, height = $tip[0].offsetHeight, marginTop = parseInt($tip.css("margin-top"), 10), marginLeft = parseInt($tip.css("margin-left"), 10);
        isNaN(marginTop) && (marginTop = 0), isNaN(marginLeft) && (marginLeft = 0), offset.top += marginTop, offset.left += marginLeft, $.offset.setOffset($tip[0], $.extend({
            using: function (props) {
                $tip.css({top: Math.round(props.top), left: Math.round(props.left)})
            }
        }, offset), 0), $tip.addClass("in");
        var actualWidth = $tip[0].offsetWidth, actualHeight = $tip[0].offsetHeight;
        "top" == placement && actualHeight != height && (offset.top = offset.top + height - actualHeight);
        var delta = this.getViewportAdjustedDelta(placement, offset, actualWidth, actualHeight);
        delta.left ? offset.left += delta.left : offset.top += delta.top;
        var isVertical = /top|bottom/.test(placement), arrowDelta = isVertical ? 2 * delta.left - width + actualWidth : 2 * delta.top - height + actualHeight, arrowOffsetPosition = isVertical ? "offsetWidth" : "offsetHeight";
        $tip.offset(offset), this.replaceArrow(arrowDelta, $tip[0][arrowOffsetPosition], isVertical)
    }, Tooltip.prototype.replaceArrow = function (delta, dimension, isVertical) {
        this.arrow().css(isVertical ? "left" : "top", 50 * (1 - delta / dimension) + "%").css(isVertical ? "top" : "left", "")
    }, Tooltip.prototype.setContent = function () {
        var $tip = this.tip(), title = this.getTitle();
        $tip.find(".tooltip-inner")[this.options.html ? "html" : "text"](title), $tip.removeClass("fade in top bottom left right")
    }, Tooltip.prototype.hide = function (callback) {
        function complete() {
            "in" != that.hoverState && $tip.detach(), that.$element && that.$element.removeAttr("aria-describedby").trigger("hidden.bs." + that.type), callback && callback()
        }

        var that = this, $tip = $(this.$tip), e = $.Event("hide.bs." + this.type);
        return this.$element.trigger(e), e.isDefaultPrevented() ? void 0 : ($tip.removeClass("in"), $.support.transition && $tip.hasClass("fade") ? $tip.one("bsTransitionEnd", complete).emulateTransitionEnd(Tooltip.TRANSITION_DURATION) : complete(), this.hoverState = null, this)
    }, Tooltip.prototype.fixTitle = function () {
        var $e = this.$element;
        ($e.attr("title") || "string" != typeof $e.attr("data-original-title")) && $e.attr("data-original-title", $e.attr("title") || "").attr("title", "")
    }, Tooltip.prototype.hasContent = function () {
        return this.getTitle()
    }, Tooltip.prototype.getPosition = function ($element) {
        $element = $element || this.$element;
        var el = $element[0], isBody = "BODY" == el.tagName, elRect = el.getBoundingClientRect();
        null == elRect.width && (elRect = $.extend({}, elRect, {
            width: elRect.right - elRect.left,
            height: elRect.bottom - elRect.top
        }));
        var isSvg = window.SVGElement && el instanceof window.SVGElement, elOffset = isBody ? {
                top: 0,
                left: 0
            } : isSvg ? null : $element.offset(), scroll = {scroll: isBody ? document.documentElement.scrollTop || document.body.scrollTop : $element.scrollTop()}, outerDims = isBody ? {
                width: $(window).width(),
                height: $(window).height()
            } : null;
        return $.extend({}, elRect, scroll, outerDims, elOffset)
    }, Tooltip.prototype.getCalculatedOffset = function (placement, pos, actualWidth, actualHeight) {
        return "bottom" == placement ? {
                top: pos.top + pos.height,
                left: pos.left + pos.width / 2 - actualWidth / 2
            } : "top" == placement ? {
                    top: pos.top - actualHeight,
                    left: pos.left + pos.width / 2 - actualWidth / 2
                } : "left" == placement ? {
                        top: pos.top + pos.height / 2 - actualHeight / 2,
                        left: pos.left - actualWidth
                    } : {top: pos.top + pos.height / 2 - actualHeight / 2, left: pos.left + pos.width}
    }, Tooltip.prototype.getViewportAdjustedDelta = function (placement, pos, actualWidth, actualHeight) {
        var delta = {top: 0, left: 0};
        if (!this.$viewport)return delta;
        var viewportPadding = this.options.viewport && this.options.viewport.padding || 0, viewportDimensions = this.getPosition(this.$viewport);
        if (/right|left/.test(placement)) {
            var topEdgeOffset = pos.top - viewportPadding - viewportDimensions.scroll, bottomEdgeOffset = pos.top + viewportPadding - viewportDimensions.scroll + actualHeight;
            topEdgeOffset < viewportDimensions.top ? delta.top = viewportDimensions.top - topEdgeOffset : bottomEdgeOffset > viewportDimensions.top + viewportDimensions.height && (delta.top = viewportDimensions.top + viewportDimensions.height - bottomEdgeOffset)
        } else {
            var leftEdgeOffset = pos.left - viewportPadding, rightEdgeOffset = pos.left + viewportPadding + actualWidth;
            leftEdgeOffset < viewportDimensions.left ? delta.left = viewportDimensions.left - leftEdgeOffset : rightEdgeOffset > viewportDimensions.right && (delta.left = viewportDimensions.left + viewportDimensions.width - rightEdgeOffset)
        }
        return delta
    }, Tooltip.prototype.getTitle = function () {
        var title, $e = this.$element, o = this.options;
        return title = $e.attr("data-original-title") || ("function" == typeof o.title ? o.title.call($e[0]) : o.title)
    }, Tooltip.prototype.getUID = function (prefix) {
        do prefix += ~~(1e6 * Math.random()); while (document.getElementById(prefix));
        return prefix
    }, Tooltip.prototype.tip = function () {
        if (!this.$tip && (this.$tip = $(this.options.template), 1 != this.$tip.length))throw new Error(this.type + " `template` option must consist of exactly 1 top-level element!");
        return this.$tip
    }, Tooltip.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find(".tooltip-arrow")
    }, Tooltip.prototype.enable = function () {
        this.enabled = !0
    }, Tooltip.prototype.disable = function () {
        this.enabled = !1
    }, Tooltip.prototype.toggleEnabled = function () {
        this.enabled = !this.enabled
    }, Tooltip.prototype.toggle = function (e) {
        var self = this;
        e && (self = $(e.currentTarget).data("bs." + this.type), self || (self = new this.constructor(e.currentTarget, this.getDelegateOptions()), $(e.currentTarget).data("bs." + this.type, self))), e ? (self.inState.click = !self.inState.click, self.isInStateTrue() ? self.enter(self) : self.leave(self)) : self.tip().hasClass("in") ? self.leave(self) : self.enter(self)
    }, Tooltip.prototype.destroy = function () {
        var that = this;
        clearTimeout(this.timeout), this.hide(function () {
            that.$element.off("." + that.type).removeData("bs." + that.type), that.$tip && that.$tip.detach(), that.$tip = null, that.$arrow = null, that.$viewport = null, that.$element = null
        })
    };
    var old = $.fn.tooltip;
    $.fn.tooltip = Plugin, $.fn.tooltip.Constructor = Tooltip, $.fn.tooltip.noConflict = function () {
        return $.fn.tooltip = old, this
    }
}(jQuery), +function ($) {
    "use strict";
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this), data = $this.data("bs.popover"), options = "object" == typeof option && option;
            (data || !/destroy|hide/.test(option)) && (data || $this.data("bs.popover", data = new Popover(this, options)), "string" == typeof option && data[option]())
        })
    }

    var Popover = function (element, options) {
        this.init("popover", element, options)
    };
    if (!$.fn.tooltip)throw new Error("Popover requires tooltip.js");
    Popover.VERSION = "3.3.7", Popover.DEFAULTS = $.extend({}, $.fn.tooltip.Constructor.DEFAULTS, {
        placement: "right",
        trigger: "click",
        content: "",
        template: '<div class="popover" role="tooltip"><div class="arrow"></div><h3 class="popover-title"></h3><div class="popover-content"></div></div>'
    }), Popover.prototype = $.extend({}, $.fn.tooltip.Constructor.prototype), Popover.prototype.constructor = Popover, Popover.prototype.getDefaults = function () {
        return Popover.DEFAULTS
    }, Popover.prototype.setContent = function () {
        var $tip = this.tip(), title = this.getTitle(), content = this.getContent();
        $tip.find(".popover-title")[this.options.html ? "html" : "text"](title), $tip.find(".popover-content").children().detach().end()[this.options.html ? "string" == typeof content ? "html" : "append" : "text"](content), $tip.removeClass("fade top bottom left right in"), $tip.find(".popover-title").html() || $tip.find(".popover-title").hide()
    }, Popover.prototype.hasContent = function () {
        return this.getTitle() || this.getContent()
    }, Popover.prototype.getContent = function () {
        var $e = this.$element, o = this.options;
        return $e.attr("data-content") || ("function" == typeof o.content ? o.content.call($e[0]) : o.content)
    }, Popover.prototype.arrow = function () {
        return this.$arrow = this.$arrow || this.tip().find(".arrow")
    };
    var old = $.fn.popover;
    $.fn.popover = Plugin, $.fn.popover.Constructor = Popover, $.fn.popover.noConflict = function () {
        return $.fn.popover = old, this
    }
}(jQuery), +function ($) {
    "use strict";
    function ScrollSpy(element, options) {
        this.$body = $(document.body), this.$scrollElement = $($(element).is(document.body) ? window : element), this.options = $.extend({}, ScrollSpy.DEFAULTS, options), this.selector = (this.options.target || "") + " .nav li > a", this.offsets = [], this.targets = [], this.activeTarget = null, this.scrollHeight = 0, this.$scrollElement.on("scroll.bs.scrollspy", $.proxy(this.process, this)), this.refresh(), this.process()
    }

    function Plugin(option) {
        return this.each(function () {
            var $this = $(this), data = $this.data("bs.scrollspy"), options = "object" == typeof option && option;
            data || $this.data("bs.scrollspy", data = new ScrollSpy(this, options)), "string" == typeof option && data[option]()
        })
    }

    ScrollSpy.VERSION = "3.3.7", ScrollSpy.DEFAULTS = {offset: 10}, ScrollSpy.prototype.getScrollHeight = function () {
        return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight)
    }, ScrollSpy.prototype.refresh = function () {
        var that = this, offsetMethod = "offset", offsetBase = 0;
        this.offsets = [], this.targets = [], this.scrollHeight = this.getScrollHeight(), $.isWindow(this.$scrollElement[0]) || (offsetMethod = "position", offsetBase = this.$scrollElement.scrollTop()), this.$body.find(this.selector).map(function () {
            var $el = $(this), href = $el.data("target") || $el.attr("href"), $href = /^#./.test(href) && $(href);
            return $href && $href.length && $href.is(":visible") && [[$href[offsetMethod]().top + offsetBase, href]] || null
        }).sort(function (a, b) {
            return a[0] - b[0]
        }).each(function () {
            that.offsets.push(this[0]), that.targets.push(this[1])
        })
    }, ScrollSpy.prototype.process = function () {
        var i, scrollTop = this.$scrollElement.scrollTop() + this.options.offset, scrollHeight = this.getScrollHeight(), maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height(), offsets = this.offsets, targets = this.targets, activeTarget = this.activeTarget;
        if (this.scrollHeight != scrollHeight && this.refresh(), scrollTop >= maxScroll)return activeTarget != (i = targets[targets.length - 1]) && this.activate(i);
        if (activeTarget && scrollTop < offsets[0])return this.activeTarget = null, this.clear();
        for (i = offsets.length; i--;)activeTarget != targets[i] && scrollTop >= offsets[i] && (void 0 === offsets[i + 1] || scrollTop < offsets[i + 1]) && this.activate(targets[i])
    }, ScrollSpy.prototype.activate = function (target) {
        this.activeTarget = target, this.clear();
        var selector = this.selector + '[data-target="' + target + '"],' + this.selector + '[href="' + target + '"]', active = $(selector).parents("li").addClass("active");
        active.parent(".dropdown-menu").length && (active = active.closest("li.dropdown").addClass("active")), active.trigger("activate.bs.scrollspy")
    }, ScrollSpy.prototype.clear = function () {
        $(this.selector).parentsUntil(this.options.target, ".active").removeClass("active")
    };
    var old = $.fn.scrollspy;
    $.fn.scrollspy = Plugin, $.fn.scrollspy.Constructor = ScrollSpy, $.fn.scrollspy.noConflict = function () {
        return $.fn.scrollspy = old, this
    }, $(window).on("load.bs.scrollspy.data-api", function () {
        $('[data-spy="scroll"]').each(function () {
            var $spy = $(this);
            Plugin.call($spy, $spy.data())
        })
    })
}(jQuery), +function ($) {
    "use strict";
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this), data = $this.data("bs.tab");
            data || $this.data("bs.tab", data = new Tab(this)), "string" == typeof option && data[option]()
        })
    }

    var Tab = function (element) {
        this.element = $(element)
    };
    Tab.VERSION = "3.3.7", Tab.TRANSITION_DURATION = 150, Tab.prototype.show = function () {
        var $this = this.element, $ul = $this.closest("ul:not(.dropdown-menu)"), selector = $this.data("target");
        if (selector || (selector = $this.attr("href"), selector = selector && selector.replace(/.*(?=#[^\s]*$)/, "")), !$this.parent("li").hasClass("active")) {
            var $previous = $ul.find(".active:last a"), hideEvent = $.Event("hide.bs.tab", {relatedTarget: $this[0]}), showEvent = $.Event("show.bs.tab", {relatedTarget: $previous[0]});
            if ($previous.trigger(hideEvent), $this.trigger(showEvent), !showEvent.isDefaultPrevented() && !hideEvent.isDefaultPrevented()) {
                var $target = $(selector);
                this.activate($this.closest("li"), $ul), this.activate($target, $target.parent(), function () {
                    $previous.trigger({
                        type: "hidden.bs.tab",
                        relatedTarget: $this[0]
                    }), $this.trigger({type: "shown.bs.tab", relatedTarget: $previous[0]})
                })
            }
        }
    }, Tab.prototype.activate = function (element, container, callback) {
        function next() {
            $active.removeClass("active").find("> .dropdown-menu > .active").removeClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !1), element.addClass("active").find('[data-toggle="tab"]').attr("aria-expanded", !0), transition ? (element[0].offsetWidth, element.addClass("in")) : element.removeClass("fade"), element.parent(".dropdown-menu").length && element.closest("li.dropdown").addClass("active").end().find('[data-toggle="tab"]').attr("aria-expanded", !0), callback && callback()
        }

        var $active = container.find("> .active"), transition = callback && $.support.transition && ($active.length && $active.hasClass("fade") || !!container.find("> .fade").length);
        $active.length && transition ? $active.one("bsTransitionEnd", next).emulateTransitionEnd(Tab.TRANSITION_DURATION) : next(), $active.removeClass("in")
    };
    var old = $.fn.tab;
    $.fn.tab = Plugin, $.fn.tab.Constructor = Tab, $.fn.tab.noConflict = function () {
        return $.fn.tab = old, this
    };
    var clickHandler = function (e) {
        e.preventDefault(), Plugin.call($(this), "show")
    };
    $(document).on("click.bs.tab.data-api", '[data-toggle="tab"]', clickHandler).on("click.bs.tab.data-api", '[data-toggle="pill"]', clickHandler)
}(jQuery), +function ($) {
    "use strict";
    function Plugin(option) {
        return this.each(function () {
            var $this = $(this), data = $this.data("bs.affix"), options = "object" == typeof option && option;
            data || $this.data("bs.affix", data = new Affix(this, options)), "string" == typeof option && data[option]()
        })
    }

    var Affix = function (element, options) {
        this.options = $.extend({}, Affix.DEFAULTS, options), this.$target = $(this.options.target).on("scroll.bs.affix.data-api", $.proxy(this.checkPosition, this)).on("click.bs.affix.data-api", $.proxy(this.checkPositionWithEventLoop, this)), this.$element = $(element), this.affixed = null, this.unpin = null, this.pinnedOffset = null, this.checkPosition()
    };
    Affix.VERSION = "3.3.7", Affix.RESET = "affix affix-top affix-bottom", Affix.DEFAULTS = {
        offset: 0,
        target: window
    }, Affix.prototype.getState = function (scrollHeight, height, offsetTop, offsetBottom) {
        var scrollTop = this.$target.scrollTop(), position = this.$element.offset(), targetHeight = this.$target.height();
        if (null != offsetTop && "top" == this.affixed)return offsetTop > scrollTop ? "top" : !1;
        if ("bottom" == this.affixed)return null != offsetTop ? scrollTop + this.unpin <= position.top ? !1 : "bottom" : scrollHeight - offsetBottom >= scrollTop + targetHeight ? !1 : "bottom";
        var initializing = null == this.affixed, colliderTop = initializing ? scrollTop : position.top, colliderHeight = initializing ? targetHeight : height;
        return null != offsetTop && offsetTop >= scrollTop ? "top" : null != offsetBottom && colliderTop + colliderHeight >= scrollHeight - offsetBottom ? "bottom" : !1
    }, Affix.prototype.getPinnedOffset = function () {
        if (this.pinnedOffset)return this.pinnedOffset;
        this.$element.removeClass(Affix.RESET).addClass("affix");
        var scrollTop = this.$target.scrollTop(), position = this.$element.offset();
        return this.pinnedOffset = position.top - scrollTop
    }, Affix.prototype.checkPositionWithEventLoop = function () {
        setTimeout($.proxy(this.checkPosition, this), 1)
    }, Affix.prototype.checkPosition = function () {
        if (this.$element.is(":visible")) {
            var height = this.$element.height(), offset = this.options.offset, offsetTop = offset.top, offsetBottom = offset.bottom, scrollHeight = Math.max($(document).height(), $(document.body).height());
            "object" != typeof offset && (offsetBottom = offsetTop = offset), "function" == typeof offsetTop && (offsetTop = offset.top(this.$element)), "function" == typeof offsetBottom && (offsetBottom = offset.bottom(this.$element));
            var affix = this.getState(scrollHeight, height, offsetTop, offsetBottom);
            if (this.affixed != affix) {
                null != this.unpin && this.$element.css("top", "");
                var affixType = "affix" + (affix ? "-" + affix : ""), e = $.Event(affixType + ".bs.affix");
                if (this.$element.trigger(e), e.isDefaultPrevented())return;
                this.affixed = affix, this.unpin = "bottom" == affix ? this.getPinnedOffset() : null, this.$element.removeClass(Affix.RESET).addClass(affixType).trigger(affixType.replace("affix", "affixed") + ".bs.affix")
            }
            "bottom" == affix && this.$element.offset({top: scrollHeight - height - offsetBottom})
        }
    };
    var old = $.fn.affix;
    $.fn.affix = Plugin, $.fn.affix.Constructor = Affix, $.fn.affix.noConflict = function () {
        return $.fn.affix = old, this
    }, $(window).on("load", function () {
        $('[data-spy="affix"]').each(function () {
            var $spy = $(this), data = $spy.data();
            data.offset = data.offset || {}, null != data.offsetBottom && (data.offset.bottom = data.offsetBottom), null != data.offsetTop && (data.offset.top = data.offsetTop), Plugin.call($spy, data)
        })
    })
}(jQuery), function (window, angular) {
    "use strict";
    function assertArg(arg, name, reason) {
        if (!arg)throw ngMinErr("areq", "Argument '{0}' is {1}", name || "?", reason || "required");
        return arg
    }

    function mergeClasses(a, b) {
        return a || b ? a ? b ? (isArray(a) && (a = a.join(" ")),
                    isArray(b) && (b = b.join(" ")), a + " " + b) : a : b : ""
    }

    function packageStyles(options) {
        var styles = {};
        return options && (options.to || options.from) && (styles.to = options.to, styles.from = options.from), styles
    }

    function pendClasses(classes, fix, isPrefix) {
        var className = "";
        return classes = isArray(classes) ? classes : classes && isString(classes) && classes.length ? classes.split(/\s+/) : [], forEach(classes, function (klass, i) {
            klass && klass.length > 0 && (className += i > 0 ? " " : "", className += isPrefix ? fix + klass : klass + fix)
        }), className
    }

    function removeFromArray(arr, val) {
        var index = arr.indexOf(val);
        val >= 0 && arr.splice(index, 1)
    }

    function stripCommentsFromElement(element) {
        if (element instanceof jqLite)switch (element.length) {
            case 0:
                return element;
            case 1:
                if (element[0].nodeType === ELEMENT_NODE)return element;
                break;
            default:
                return jqLite(extractElementNode(element))
        }
        return element.nodeType === ELEMENT_NODE ? jqLite(element) : void 0
    }

    function extractElementNode(element) {
        if (!element[0])return element;
        for (var i = 0; i < element.length; i++) {
            var elm = element[i];
            if (elm.nodeType == ELEMENT_NODE)return elm
        }
    }

    function $$addClass($$jqLite, element, className) {
        forEach(element, function (elm) {
            $$jqLite.addClass(elm, className)
        })
    }

    function $$removeClass($$jqLite, element, className) {
        forEach(element, function (elm) {
            $$jqLite.removeClass(elm, className)
        })
    }

    function applyAnimationClassesFactory($$jqLite) {
        return function (element, options) {
            options.addClass && ($$addClass($$jqLite, element, options.addClass), options.addClass = null), options.removeClass && ($$removeClass($$jqLite, element, options.removeClass), options.removeClass = null)
        }
    }

    function prepareAnimationOptions(options) {
        if (options = options || {}, !options.$$prepared) {
            var domOperation = options.domOperation || noop;
            options.domOperation = function () {
                options.$$domOperationFired = !0, domOperation(), domOperation = noop
            }, options.$$prepared = !0
        }
        return options
    }

    function applyAnimationStyles(element, options) {
        applyAnimationFromStyles(element, options), applyAnimationToStyles(element, options)
    }

    function applyAnimationFromStyles(element, options) {
        options.from && (element.css(options.from), options.from = null)
    }

    function applyAnimationToStyles(element, options) {
        options.to && (element.css(options.to), options.to = null)
    }

    function mergeAnimationDetails(element, oldAnimation, newAnimation) {
        var target = oldAnimation.options || {}, newOptions = newAnimation.options || {}, toAdd = (target.addClass || "") + " " + (newOptions.addClass || ""), toRemove = (target.removeClass || "") + " " + (newOptions.removeClass || ""), classes = resolveElementClasses(element.attr("class"), toAdd, toRemove);
        newOptions.preparationClasses && (target.preparationClasses = concatWithSpace(newOptions.preparationClasses, target.preparationClasses), delete newOptions.preparationClasses);
        var realDomOperation = target.domOperation !== noop ? target.domOperation : null;
        return extend(target, newOptions), realDomOperation && (target.domOperation = realDomOperation), classes.addClass ? target.addClass = classes.addClass : target.addClass = null, classes.removeClass ? target.removeClass = classes.removeClass : target.removeClass = null, oldAnimation.addClass = target.addClass, oldAnimation.removeClass = target.removeClass, target
    }

    function resolveElementClasses(existing, toAdd, toRemove) {
        function splitClassesToLookup(classes) {
            isString(classes) && (classes = classes.split(" "));
            var obj = {};
            return forEach(classes, function (klass) {
                klass.length && (obj[klass] = !0)
            }), obj
        }

        var ADD_CLASS = 1, REMOVE_CLASS = -1, flags = {};
        existing = splitClassesToLookup(existing), toAdd = splitClassesToLookup(toAdd), forEach(toAdd, function (value, key) {
            flags[key] = ADD_CLASS
        }), toRemove = splitClassesToLookup(toRemove), forEach(toRemove, function (value, key) {
            flags[key] = flags[key] === ADD_CLASS ? null : REMOVE_CLASS
        });
        var classes = {addClass: "", removeClass: ""};
        return forEach(flags, function (val, klass) {
            var prop, allow;
            val === ADD_CLASS ? (prop = "addClass", allow = !existing[klass] || existing[klass + REMOVE_CLASS_SUFFIX]) : val === REMOVE_CLASS && (prop = "removeClass", allow = existing[klass] || existing[klass + ADD_CLASS_SUFFIX]), allow && (classes[prop].length && (classes[prop] += " "), classes[prop] += klass)
        }), classes
    }

    function getDomNode(element) {
        return element instanceof jqLite ? element[0] : element
    }

    function applyGeneratedPreparationClasses(element, event, options) {
        var classes = "";
        event && (classes = pendClasses(event, EVENT_CLASS_PREFIX, !0)), options.addClass && (classes = concatWithSpace(classes, pendClasses(options.addClass, ADD_CLASS_SUFFIX))), options.removeClass && (classes = concatWithSpace(classes, pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX))), classes.length && (options.preparationClasses = classes, element.addClass(classes))
    }

    function clearGeneratedClasses(element, options) {
        options.preparationClasses && (element.removeClass(options.preparationClasses), options.preparationClasses = null), options.activeClasses && (element.removeClass(options.activeClasses), options.activeClasses = null)
    }

    function blockTransitions(node, duration) {
        var value = duration ? "-" + duration + "s" : "";
        return applyInlineStyle(node, [TRANSITION_DELAY_PROP, value]), [TRANSITION_DELAY_PROP, value]
    }

    function blockKeyframeAnimations(node, applyBlock) {
        var value = applyBlock ? "paused" : "", key = ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY;
        return applyInlineStyle(node, [key, value]), [key, value]
    }

    function applyInlineStyle(node, styleTuple) {
        var prop = styleTuple[0], value = styleTuple[1];
        node.style[prop] = value
    }

    function concatWithSpace(a, b) {
        return a ? b ? a + " " + b : a : b
    }

    function getCssKeyframeDurationStyle(duration) {
        return [ANIMATION_DURATION_PROP, duration + "s"]
    }

    function getCssDelayStyle(delay, isKeyframeAnimation) {
        var prop = isKeyframeAnimation ? ANIMATION_DELAY_PROP : TRANSITION_DELAY_PROP;
        return [prop, delay + "s"]
    }

    function computeCssStyles($window, element, properties) {
        var styles = Object.create(null), detectedStyles = $window.getComputedStyle(element) || {};
        return forEach(properties, function (formalStyleName, actualStyleName) {
            var val = detectedStyles[formalStyleName];
            if (val) {
                var c = val.charAt(0);
                ("-" === c || "+" === c || c >= 0) && (val = parseMaxTime(val)), 0 === val && (val = null), styles[actualStyleName] = val
            }
        }), styles
    }

    function parseMaxTime(str) {
        var maxValue = 0, values = str.split(/\s*,\s*/);
        return forEach(values, function (value) {
            "s" == value.charAt(value.length - 1) && (value = value.substring(0, value.length - 1)), value = parseFloat(value) || 0, maxValue = maxValue ? Math.max(value, maxValue) : value
        }), maxValue
    }

    function truthyTimingValue(val) {
        return 0 === val || null != val
    }

    function getCssTransitionDurationStyle(duration, applyOnlyDuration) {
        var style = TRANSITION_PROP, value = duration + "s";
        return applyOnlyDuration ? style += DURATION_KEY : value += " linear all", [style, value]
    }

    function createLocalCacheLookup() {
        var cache = Object.create(null);
        return {
            flush: function () {
                cache = Object.create(null)
            }, count: function (key) {
                var entry = cache[key];
                return entry ? entry.total : 0
            }, get: function (key) {
                var entry = cache[key];
                return entry && entry.value
            }, put: function (key, value) {
                cache[key] ? cache[key].total++ : cache[key] = {total: 1, value: value}
            }
        }
    }

    function registerRestorableStyles(backup, node, properties) {
        forEach(properties, function (prop) {
            backup[prop] = isDefined(backup[prop]) ? backup[prop] : node.style.getPropertyValue(prop)
        })
    }

    var TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT, ELEMENT_NODE = 1, ADD_CLASS_SUFFIX = "-add", REMOVE_CLASS_SUFFIX = "-remove", EVENT_CLASS_PREFIX = "ng-", ACTIVE_CLASS_SUFFIX = "-active", PREPARE_CLASS_SUFFIX = "-prepare", NG_ANIMATE_CLASSNAME = "ng-animate", NG_ANIMATE_CHILDREN_DATA = "$$ngAnimateChildren", CSS_PREFIX = "";
    void 0 === window.ontransitionend && void 0 !== window.onwebkittransitionend ? (CSS_PREFIX = "-webkit-", TRANSITION_PROP = "WebkitTransition", TRANSITIONEND_EVENT = "webkitTransitionEnd transitionend") : (TRANSITION_PROP = "transition", TRANSITIONEND_EVENT = "transitionend"), void 0 === window.onanimationend && void 0 !== window.onwebkitanimationend ? (CSS_PREFIX = "-webkit-", ANIMATION_PROP = "WebkitAnimation", ANIMATIONEND_EVENT = "webkitAnimationEnd animationend") : (ANIMATION_PROP = "animation", ANIMATIONEND_EVENT = "animationend");
    var copy, extend, forEach, isArray, isDefined, isElement, isFunction, isObject, isString, isUndefined, jqLite, noop, DURATION_KEY = "Duration", PROPERTY_KEY = "Property", DELAY_KEY = "Delay", TIMING_KEY = "TimingFunction", ANIMATION_ITERATION_COUNT_KEY = "IterationCount", ANIMATION_PLAYSTATE_KEY = "PlayState", SAFE_FAST_FORWARD_DURATION_VALUE = 9999, ANIMATION_DELAY_PROP = ANIMATION_PROP + DELAY_KEY, ANIMATION_DURATION_PROP = ANIMATION_PROP + DURATION_KEY, TRANSITION_DELAY_PROP = TRANSITION_PROP + DELAY_KEY, TRANSITION_DURATION_PROP = TRANSITION_PROP + DURATION_KEY, ngMinErr = angular.$$minErr("ng"), $$rAFSchedulerFactory = ["$$rAF", function ($$rAF) {
        function scheduler(tasks) {
            queue = queue.concat(tasks), nextTick()
        }

        function nextTick() {
            if (queue.length) {
                for (var items = queue.shift(), i = 0; i < items.length; i++)items[i]();
                cancelFn || $$rAF(function () {
                    cancelFn || nextTick()
                })
            }
        }

        var queue, cancelFn;
        return queue = scheduler.queue = [], scheduler.waitUntilQuiet = function (fn) {
            cancelFn && cancelFn(), cancelFn = $$rAF(function () {
                cancelFn = null, fn(), nextTick()
            })
        }, scheduler
    }], $$AnimateChildrenDirective = ["$interpolate", function ($interpolate) {
        return {
            link: function (scope, element, attrs) {
                function setData(value) {
                    value = "on" === value || "true" === value, element.data(NG_ANIMATE_CHILDREN_DATA, value)
                }

                var val = attrs.ngAnimateChildren;
                isString(val) && 0 === val.length ? element.data(NG_ANIMATE_CHILDREN_DATA, !0) : (setData($interpolate(val)(scope)), attrs.$observe("ngAnimateChildren", setData))
            }
        }
    }], ANIMATE_TIMER_KEY = "$$animateCss", ONE_SECOND = 1e3, ELAPSED_TIME_MAX_DECIMAL_PLACES = 3, CLOSING_TIME_BUFFER = 1.5, DETECT_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        transitionProperty: TRANSITION_PROP + PROPERTY_KEY,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP,
        animationIterationCount: ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY
    }, DETECT_STAGGER_CSS_PROPERTIES = {
        transitionDuration: TRANSITION_DURATION_PROP,
        transitionDelay: TRANSITION_DELAY_PROP,
        animationDuration: ANIMATION_DURATION_PROP,
        animationDelay: ANIMATION_DELAY_PROP
    }, $AnimateCssProvider = ["$animateProvider", function ($animateProvider) {
        var gcsLookup = createLocalCacheLookup(), gcsStaggerLookup = createLocalCacheLookup();
        this.$get = ["$window", "$$jqLite", "$$AnimateRunner", "$timeout", "$$forceReflow", "$sniffer", "$$rAFScheduler", "$$animateQueue", function ($window, $$jqLite, $$AnimateRunner, $timeout, $$forceReflow, $sniffer, $$rAFScheduler, $$animateQueue) {
            function gcsHashFn(node, extraClasses) {
                var KEY = "$$ngAnimateParentKey", parentNode = node.parentNode, parentID = parentNode[KEY] || (parentNode[KEY] = ++parentCounter);
                return parentID + "-" + node.getAttribute("class") + "-" + extraClasses
            }

            function computeCachedCssStyles(node, className, cacheKey, properties) {
                var timings = gcsLookup.get(cacheKey);
                return timings || (timings = computeCssStyles($window, node, properties), "infinite" === timings.animationIterationCount && (timings.animationIterationCount = 1)), gcsLookup.put(cacheKey, timings), timings
            }

            function computeCachedCssStaggerStyles(node, className, cacheKey, properties) {
                var stagger;
                if (gcsLookup.count(cacheKey) > 0 && (stagger = gcsStaggerLookup.get(cacheKey), !stagger)) {
                    var staggerClassName = pendClasses(className, "-stagger");
                    $$jqLite.addClass(node, staggerClassName), stagger = computeCssStyles($window, node, properties), stagger.animationDuration = Math.max(stagger.animationDuration, 0), stagger.transitionDuration = Math.max(stagger.transitionDuration, 0), $$jqLite.removeClass(node, staggerClassName), gcsStaggerLookup.put(cacheKey, stagger)
                }
                return stagger || {}
            }

            function waitUntilQuiet(callback) {
                rafWaitQueue.push(callback), $$rAFScheduler.waitUntilQuiet(function () {
                    gcsLookup.flush(), gcsStaggerLookup.flush();
                    for (var pageWidth = $$forceReflow(), i = 0; i < rafWaitQueue.length; i++)rafWaitQueue[i](pageWidth);
                    rafWaitQueue.length = 0
                })
            }

            function computeTimings(node, className, cacheKey) {
                var timings = computeCachedCssStyles(node, className, cacheKey, DETECT_CSS_PROPERTIES), aD = timings.animationDelay, tD = timings.transitionDelay;
                return timings.maxDelay = aD && tD ? Math.max(aD, tD) : aD || tD, timings.maxDuration = Math.max(timings.animationDuration * timings.animationIterationCount, timings.transitionDuration), timings
            }

            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite), parentCounter = 0, rafWaitQueue = [];
            return function (element, initialOptions) {
                function endFn() {
                    close()
                }

                function cancelFn() {
                    close(!0)
                }

                function close(rejected) {
                    if (!(animationClosed || animationCompleted && animationPaused)) {
                        animationClosed = !0, animationPaused = !1, options.$$skipPreparationClasses || $$jqLite.removeClass(element, preparationClasses), $$jqLite.removeClass(element, activeClasses), blockKeyframeAnimations(node, !1), blockTransitions(node, !1), forEach(temporaryStyles, function (entry) {
                            node.style[entry[0]] = ""
                        }), applyAnimationClasses(element, options), applyAnimationStyles(element, options), Object.keys(restoreStyles).length && forEach(restoreStyles, function (value, prop) {
                            value ? node.style.setProperty(prop, value) : node.style.removeProperty(prop)
                        }), options.onDone && options.onDone(), events && events.length && element.off(events.join(" "), onAnimationProgress);
                        var animationTimerData = element.data(ANIMATE_TIMER_KEY);
                        animationTimerData && ($timeout.cancel(animationTimerData[0].timer), element.removeData(ANIMATE_TIMER_KEY)), runner && runner.complete(!rejected)
                    }
                }

                function applyBlocking(duration) {
                    flags.blockTransition && blockTransitions(node, duration), flags.blockKeyframeAnimation && blockKeyframeAnimations(node, !!duration)
                }

                function closeAndReturnNoopAnimator() {
                    return runner = new $$AnimateRunner({
                        end: endFn,
                        cancel: cancelFn
                    }), waitUntilQuiet(noop), close(), {
                        $$willAnimate: !1, start: function () {
                            return runner
                        }, end: endFn
                    }
                }

                function onAnimationProgress(event) {
                    event.stopPropagation();
                    var ev = event.originalEvent || event, timeStamp = ev.$manualTimeStamp || Date.now(), elapsedTime = parseFloat(ev.elapsedTime.toFixed(ELAPSED_TIME_MAX_DECIMAL_PLACES));
                    Math.max(timeStamp - startTime, 0) >= maxDelayTime && elapsedTime >= maxDuration && (animationCompleted = !0, close())
                }

                function start() {
                    function triggerAnimationStart() {
                        if (!animationClosed) {
                            if (applyBlocking(!1), forEach(temporaryStyles, function (entry) {
                                    var key = entry[0], value = entry[1];
                                    node.style[key] = value
                                }), applyAnimationClasses(element, options), $$jqLite.addClass(element, activeClasses), flags.recalculateTimingStyles) {
                                if (fullClassName = node.className + " " + preparationClasses, cacheKey = gcsHashFn(node, fullClassName), timings = computeTimings(node, fullClassName, cacheKey), relativeDelay = timings.maxDelay, maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration, 0 === maxDuration)return void close();
                                flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0
                            }
                            if (flags.applyAnimationDelay && (relativeDelay = "boolean" != typeof options.delay && truthyTimingValue(options.delay) ? parseFloat(options.delay) : relativeDelay, maxDelay = Math.max(relativeDelay, 0), timings.animationDelay = relativeDelay, delayStyle = getCssDelayStyle(relativeDelay, !0), temporaryStyles.push(delayStyle), node.style[delayStyle[0]] = delayStyle[1]), maxDelayTime = maxDelay * ONE_SECOND, maxDurationTime = maxDuration * ONE_SECOND, options.easing) {
                                var easeProp, easeVal = options.easing;
                                flags.hasTransitions && (easeProp = TRANSITION_PROP + TIMING_KEY, temporaryStyles.push([easeProp, easeVal]), node.style[easeProp] = easeVal), flags.hasAnimations && (easeProp = ANIMATION_PROP + TIMING_KEY, temporaryStyles.push([easeProp, easeVal]), node.style[easeProp] = easeVal)
                            }
                            timings.transitionDuration && events.push(TRANSITIONEND_EVENT), timings.animationDuration && events.push(ANIMATIONEND_EVENT), startTime = Date.now();
                            var timerTime = maxDelayTime + CLOSING_TIME_BUFFER * maxDurationTime, endTime = startTime + timerTime, animationsData = element.data(ANIMATE_TIMER_KEY) || [], setupFallbackTimer = !0;
                            if (animationsData.length) {
                                var currentTimerData = animationsData[0];
                                setupFallbackTimer = endTime > currentTimerData.expectedEndTime, setupFallbackTimer ? $timeout.cancel(currentTimerData.timer) : animationsData.push(close)
                            }
                            if (setupFallbackTimer) {
                                var timer = $timeout(onAnimationExpired, timerTime, !1);
                                animationsData[0] = {
                                    timer: timer,
                                    expectedEndTime: endTime
                                }, animationsData.push(close), element.data(ANIMATE_TIMER_KEY, animationsData)
                            }
                            events.length && element.on(events.join(" "), onAnimationProgress), options.to && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.to)), applyAnimationToStyles(element, options))
                        }
                    }

                    function onAnimationExpired() {
                        var animationsData = element.data(ANIMATE_TIMER_KEY);
                        if (animationsData) {
                            for (var i = 1; i < animationsData.length; i++)animationsData[i]();
                            element.removeData(ANIMATE_TIMER_KEY)
                        }
                    }

                    if (!animationClosed) {
                        if (!node.parentNode)return void close();
                        var playPause = function (playAnimation) {
                            if (animationCompleted) animationPaused && playAnimation && (animationPaused = !1, close()); else if (animationPaused = !playAnimation, timings.animationDuration) {
                                var value = blockKeyframeAnimations(node, animationPaused);
                                animationPaused ? temporaryStyles.push(value) : removeFromArray(temporaryStyles, value)
                            }
                        }, maxStagger = itemIndex > 0 && (timings.transitionDuration && 0 === stagger.transitionDuration || timings.animationDuration && 0 === stagger.animationDuration) && Math.max(stagger.animationDelay, stagger.transitionDelay);
                        maxStagger ? $timeout(triggerAnimationStart, Math.floor(maxStagger * itemIndex * ONE_SECOND), !1) : triggerAnimationStart(), runnerHost.resume = function () {
                            playPause(!0)
                        }, runnerHost.pause = function () {
                            playPause(!1)
                        }
                    }
                }

                var options = initialOptions || {};
                options.$$prepared || (options = prepareAnimationOptions(copy(options)));
                var restoreStyles = {}, node = getDomNode(element);
                if (!node || !node.parentNode || !$$animateQueue.enabled())return closeAndReturnNoopAnimator();
                var animationClosed, animationPaused, animationCompleted, runner, runnerHost, maxDelay, maxDelayTime, maxDuration, maxDurationTime, startTime, temporaryStyles = [], classes = element.attr("class"), styles = packageStyles(options), events = [];
                if (0 === options.duration || !$sniffer.animations && !$sniffer.transitions)return closeAndReturnNoopAnimator();
                var method = options.event && isArray(options.event) ? options.event.join(" ") : options.event, isStructural = method && options.structural, structuralClassName = "", addRemoveClassName = "";
                isStructural ? structuralClassName = pendClasses(method, EVENT_CLASS_PREFIX, !0) : method && (structuralClassName = method), options.addClass && (addRemoveClassName += pendClasses(options.addClass, ADD_CLASS_SUFFIX)), options.removeClass && (addRemoveClassName.length && (addRemoveClassName += " "), addRemoveClassName += pendClasses(options.removeClass, REMOVE_CLASS_SUFFIX)), options.applyClassesEarly && addRemoveClassName.length && applyAnimationClasses(element, options);
                var preparationClasses = [structuralClassName, addRemoveClassName].join(" ").trim(), fullClassName = classes + " " + preparationClasses, activeClasses = pendClasses(preparationClasses, ACTIVE_CLASS_SUFFIX), hasToStyles = styles.to && Object.keys(styles.to).length > 0, containsKeyframeAnimation = (options.keyframeStyle || "").length > 0;
                if (!containsKeyframeAnimation && !hasToStyles && !preparationClasses)return closeAndReturnNoopAnimator();
                var cacheKey, stagger;
                if (options.stagger > 0) {
                    var staggerVal = parseFloat(options.stagger);
                    stagger = {
                        transitionDelay: staggerVal,
                        animationDelay: staggerVal,
                        transitionDuration: 0,
                        animationDuration: 0
                    }
                } else cacheKey = gcsHashFn(node, fullClassName), stagger = computeCachedCssStaggerStyles(node, preparationClasses, cacheKey, DETECT_STAGGER_CSS_PROPERTIES);
                options.$$skipPreparationClasses || $$jqLite.addClass(element, preparationClasses);
                var applyOnlyDuration;
                if (options.transitionStyle) {
                    var transitionStyle = [TRANSITION_PROP, options.transitionStyle];
                    applyInlineStyle(node, transitionStyle), temporaryStyles.push(transitionStyle)
                }
                if (options.duration >= 0) {
                    applyOnlyDuration = node.style[TRANSITION_PROP].length > 0;
                    var durationStyle = getCssTransitionDurationStyle(options.duration, applyOnlyDuration);
                    applyInlineStyle(node, durationStyle), temporaryStyles.push(durationStyle)
                }
                if (options.keyframeStyle) {
                    var keyframeStyle = [ANIMATION_PROP, options.keyframeStyle];
                    applyInlineStyle(node, keyframeStyle), temporaryStyles.push(keyframeStyle)
                }
                var itemIndex = stagger ? options.staggerIndex >= 0 ? options.staggerIndex : gcsLookup.count(cacheKey) : 0, isFirst = 0 === itemIndex;
                isFirst && !options.skipBlocking && blockTransitions(node, SAFE_FAST_FORWARD_DURATION_VALUE);
                var timings = computeTimings(node, fullClassName, cacheKey), relativeDelay = timings.maxDelay;
                maxDelay = Math.max(relativeDelay, 0), maxDuration = timings.maxDuration;
                var flags = {};
                if (flags.hasTransitions = timings.transitionDuration > 0, flags.hasAnimations = timings.animationDuration > 0, flags.hasTransitionAll = flags.hasTransitions && "all" == timings.transitionProperty, flags.applyTransitionDuration = hasToStyles && (flags.hasTransitions && !flags.hasTransitionAll || flags.hasAnimations && !flags.hasTransitions), flags.applyAnimationDuration = options.duration && flags.hasAnimations, flags.applyTransitionDelay = truthyTimingValue(options.delay) && (flags.applyTransitionDuration || flags.hasTransitions), flags.applyAnimationDelay = truthyTimingValue(options.delay) && flags.hasAnimations, flags.recalculateTimingStyles = addRemoveClassName.length > 0, (flags.applyTransitionDuration || flags.applyAnimationDuration) && (maxDuration = options.duration ? parseFloat(options.duration) : maxDuration, flags.applyTransitionDuration && (flags.hasTransitions = !0, timings.transitionDuration = maxDuration, applyOnlyDuration = node.style[TRANSITION_PROP + PROPERTY_KEY].length > 0, temporaryStyles.push(getCssTransitionDurationStyle(maxDuration, applyOnlyDuration))), flags.applyAnimationDuration && (flags.hasAnimations = !0, timings.animationDuration = maxDuration, temporaryStyles.push(getCssKeyframeDurationStyle(maxDuration)))), 0 === maxDuration && !flags.recalculateTimingStyles)return closeAndReturnNoopAnimator();
                if (null != options.delay) {
                    var delayStyle;
                    "boolean" != typeof options.delay && (delayStyle = parseFloat(options.delay), maxDelay = Math.max(delayStyle, 0)), flags.applyTransitionDelay && temporaryStyles.push(getCssDelayStyle(delayStyle)), flags.applyAnimationDelay && temporaryStyles.push(getCssDelayStyle(delayStyle, !0))
                }
                return null == options.duration && timings.transitionDuration > 0 && (flags.recalculateTimingStyles = flags.recalculateTimingStyles || isFirst), maxDelayTime = maxDelay * ONE_SECOND, maxDurationTime = maxDuration * ONE_SECOND, options.skipBlocking || (flags.blockTransition = timings.transitionDuration > 0, flags.blockKeyframeAnimation = timings.animationDuration > 0 && stagger.animationDelay > 0 && 0 === stagger.animationDuration), options.from && (options.cleanupStyles && registerRestorableStyles(restoreStyles, node, Object.keys(options.from)), applyAnimationFromStyles(element, options)), flags.blockTransition || flags.blockKeyframeAnimation ? applyBlocking(maxDuration) : options.skipBlocking || blockTransitions(node, !1), {
                    $$willAnimate: !0,
                    end: endFn,
                    start: function () {
                        return animationClosed ? void 0 : (runnerHost = {
                                end: endFn,
                                cancel: cancelFn,
                                resume: null,
                                pause: null
                            }, runner = new $$AnimateRunner(runnerHost), waitUntilQuiet(start), runner)
                    }
                }
            }
        }]
    }], $$AnimateCssDriverProvider = ["$$animationProvider", function ($$animationProvider) {
        function isDocumentFragment(node) {
            return node.parentNode && 11 === node.parentNode.nodeType
        }

        $$animationProvider.drivers.push("$$animateCssDriver");
        var NG_ANIMATE_SHIM_CLASS_NAME = "ng-animate-shim", NG_ANIMATE_ANCHOR_CLASS_NAME = "ng-anchor", NG_OUT_ANCHOR_CLASS_NAME = "ng-anchor-out", NG_IN_ANCHOR_CLASS_NAME = "ng-anchor-in";
        this.$get = ["$animateCss", "$rootScope", "$$AnimateRunner", "$rootElement", "$sniffer", "$$jqLite", "$document", function ($animateCss, $rootScope, $$AnimateRunner, $rootElement, $sniffer, $$jqLite, $document) {
            function filterCssClasses(classes) {
                return classes.replace(/\bng-\S+\b/g, "")
            }

            function getUniqueValues(a, b) {
                return isString(a) && (a = a.split(" ")), isString(b) && (b = b.split(" ")), a.filter(function (val) {
                    return -1 === b.indexOf(val)
                }).join(" ")
            }

            function prepareAnchoredAnimation(classes, outAnchor, inAnchor) {
                function calculateAnchorStyles(anchor) {
                    var styles = {}, coords = getDomNode(anchor).getBoundingClientRect();
                    return forEach(["width", "height", "top", "left"], function (key) {
                        var value = coords[key];
                        switch (key) {
                            case"top":
                                value += bodyNode.scrollTop;
                                break;
                            case"left":
                                value += bodyNode.scrollLeft
                        }
                        styles[key] = Math.floor(value) + "px"
                    }), styles
                }

                function prepareOutAnimation() {
                    var animator = $animateCss(clone, {
                        addClass: NG_OUT_ANCHOR_CLASS_NAME,
                        delay: !0,
                        from: calculateAnchorStyles(outAnchor)
                    });
                    return animator.$$willAnimate ? animator : null
                }

                function getClassVal(element) {
                    return element.attr("class") || ""
                }

                function prepareInAnimation() {
                    var endingClasses = filterCssClasses(getClassVal(inAnchor)), toAdd = getUniqueValues(endingClasses, startingClasses), toRemove = getUniqueValues(startingClasses, endingClasses), animator = $animateCss(clone, {
                        to: calculateAnchorStyles(inAnchor),
                        addClass: NG_IN_ANCHOR_CLASS_NAME + " " + toAdd,
                        removeClass: NG_OUT_ANCHOR_CLASS_NAME + " " + toRemove,
                        delay: !0
                    });
                    return animator.$$willAnimate ? animator : null
                }

                function end() {
                    clone.remove(), outAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME), inAnchor.removeClass(NG_ANIMATE_SHIM_CLASS_NAME)
                }

                var clone = jqLite(getDomNode(outAnchor).cloneNode(!0)), startingClasses = filterCssClasses(getClassVal(clone));
                outAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME), inAnchor.addClass(NG_ANIMATE_SHIM_CLASS_NAME), clone.addClass(NG_ANIMATE_ANCHOR_CLASS_NAME), rootBodyElement.append(clone);
                var animatorIn, animatorOut = prepareOutAnimation();
                if (!animatorOut && (animatorIn = prepareInAnimation(), !animatorIn))return end();
                var startingAnimator = animatorOut || animatorIn;
                return {
                    start: function () {
                        function endFn() {
                            currentAnimation && currentAnimation.end()
                        }

                        var runner, currentAnimation = startingAnimator.start();
                        return currentAnimation.done(function () {
                            return currentAnimation = null, !animatorIn && (animatorIn = prepareInAnimation()) ? (currentAnimation = animatorIn.start(), currentAnimation.done(function () {
                                    currentAnimation = null, end(), runner.complete()
                                }), currentAnimation) : (end(), void runner.complete())
                        }), runner = new $$AnimateRunner({end: endFn, cancel: endFn})
                    }
                }
            }

            function prepareFromToAnchorAnimation(from, to, classes, anchors) {
                var fromAnimation = prepareRegularAnimation(from, noop), toAnimation = prepareRegularAnimation(to, noop), anchorAnimations = [];
                return forEach(anchors, function (anchor) {
                    var outElement = anchor.out, inElement = anchor["in"], animator = prepareAnchoredAnimation(classes, outElement, inElement);
                    animator && anchorAnimations.push(animator)
                }), fromAnimation || toAnimation || 0 !== anchorAnimations.length ? {
                        start: function () {
                            function endFn() {
                                forEach(animationRunners, function (runner) {
                                    runner.end()
                                })
                            }

                            var animationRunners = [];
                            fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), forEach(anchorAnimations, function (animation) {
                                animationRunners.push(animation.start())
                            });
                            var runner = new $$AnimateRunner({end: endFn, cancel: endFn});
                            return $$AnimateRunner.all(animationRunners, function (status) {
                                runner.complete(status)
                            }), runner
                        }
                    } : void 0
            }

            function prepareRegularAnimation(animationDetails) {
                var element = animationDetails.element, options = animationDetails.options || {};
                animationDetails.structural && (options.event = animationDetails.event, options.structural = !0, options.applyClassesEarly = !0, "leave" === animationDetails.event && (options.onDone = options.domOperation)), options.preparationClasses && (options.event = concatWithSpace(options.event, options.preparationClasses));
                var animator = $animateCss(element, options);
                return animator.$$willAnimate ? animator : null
            }

            if (!$sniffer.animations && !$sniffer.transitions)return noop;
            var bodyNode = $document[0].body, rootNode = getDomNode($rootElement), rootBodyElement = jqLite(isDocumentFragment(rootNode) || bodyNode.contains(rootNode) ? rootNode : bodyNode);
            applyAnimationClassesFactory($$jqLite);
            return function (animationDetails) {
                return animationDetails.from && animationDetails.to ? prepareFromToAnchorAnimation(animationDetails.from, animationDetails.to, animationDetails.classes, animationDetails.anchors) : prepareRegularAnimation(animationDetails)
            }
        }]
    }], $$AnimateJsProvider = ["$animateProvider", function ($animateProvider) {
        this.$get = ["$injector", "$$AnimateRunner", "$$jqLite", function ($injector, $$AnimateRunner, $$jqLite) {
            function lookupAnimations(classes) {
                classes = isArray(classes) ? classes : classes.split(" ");
                for (var matches = [], flagMap = {}, i = 0; i < classes.length; i++) {
                    var klass = classes[i], animationFactory = $animateProvider.$$registeredAnimations[klass];
                    animationFactory && !flagMap[klass] && (matches.push($injector.get(animationFactory)), flagMap[klass] = !0)
                }
                return matches
            }

            var applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function (element, event, classes, options) {
                function applyOptions() {
                    options.domOperation(), applyAnimationClasses(element, options)
                }

                function close() {
                    animationClosed = !0, applyOptions(), applyAnimationStyles(element, options)
                }

                function executeAnimationFn(fn, element, event, options, onDone) {
                    var args;
                    switch (event) {
                        case"animate":
                            args = [element, options.from, options.to, onDone];
                            break;
                        case"setClass":
                            args = [element, classesToAdd, classesToRemove, onDone];
                            break;
                        case"addClass":
                            args = [element, classesToAdd, onDone];
                            break;
                        case"removeClass":
                            args = [element, classesToRemove, onDone];
                            break;
                        default:
                            args = [element, onDone]
                    }
                    args.push(options);
                    var value = fn.apply(fn, args);
                    if (value)if (isFunction(value.start) && (value = value.start()), value instanceof $$AnimateRunner) value.done(onDone); else if (isFunction(value))return value;
                    return noop
                }

                function groupEventedAnimations(element, event, options, animations, fnName) {
                    var operations = [];
                    return forEach(animations, function (ani) {
                        var animation = ani[fnName];
                        animation && operations.push(function () {
                            var runner, endProgressCb, resolved = !1, onAnimationComplete = function (rejected) {
                                resolved || (resolved = !0, (endProgressCb || noop)(rejected), runner.complete(!rejected))
                            };
                            return runner = new $$AnimateRunner({
                                end: function () {
                                    onAnimationComplete()
                                }, cancel: function () {
                                    onAnimationComplete(!0)
                                }
                            }), endProgressCb = executeAnimationFn(animation, element, event, options, function (result) {
                                var cancelled = result === !1;
                                onAnimationComplete(cancelled)
                            }), runner
                        })
                    }), operations
                }

                function packageAnimations(element, event, options, animations, fnName) {
                    var operations = groupEventedAnimations(element, event, options, animations, fnName);
                    if (0 === operations.length) {
                        var a, b;
                        "beforeSetClass" === fnName ? (a = groupEventedAnimations(element, "removeClass", options, animations, "beforeRemoveClass"), b = groupEventedAnimations(element, "addClass", options, animations, "beforeAddClass")) : "setClass" === fnName && (a = groupEventedAnimations(element, "removeClass", options, animations, "removeClass"), b = groupEventedAnimations(element, "addClass", options, animations, "addClass")), a && (operations = operations.concat(a)), b && (operations = operations.concat(b))
                    }
                    if (0 !== operations.length)return function (callback) {
                        var runners = [];
                        return operations.length && forEach(operations, function (animateFn) {
                            runners.push(animateFn())
                        }), runners.length ? $$AnimateRunner.all(runners, callback) : callback(), function (reject) {
                            forEach(runners, function (runner) {
                                reject ? runner.cancel() : runner.end()
                            })
                        }
                    }
                }

                var animationClosed = !1;
                3 === arguments.length && isObject(classes) && (options = classes, classes = null), options = prepareAnimationOptions(options), classes || (classes = element.attr("class") || "", options.addClass && (classes += " " + options.addClass), options.removeClass && (classes += " " + options.removeClass));
                var before, after, classesToAdd = options.addClass, classesToRemove = options.removeClass, animations = lookupAnimations(classes);
                if (animations.length) {
                    var afterFn, beforeFn;
                    "leave" == event ? (beforeFn = "leave", afterFn = "afterLeave") : (beforeFn = "before" + event.charAt(0).toUpperCase() + event.substr(1), afterFn = event), "enter" !== event && "move" !== event && (before = packageAnimations(element, event, options, animations, beforeFn)), after = packageAnimations(element, event, options, animations, afterFn)
                }
                if (before || after) {
                    var runner;
                    return {
                        $$willAnimate: !0, end: function () {
                            return runner ? runner.end() : (close(), runner = new $$AnimateRunner, runner.complete(!0)), runner
                        }, start: function () {
                            function onComplete(success) {
                                close(success), runner.complete(success)
                            }

                            function endAnimations(cancelled) {
                                animationClosed || ((closeActiveAnimations || noop)(cancelled), onComplete(cancelled))
                            }

                            if (runner)return runner;
                            runner = new $$AnimateRunner;
                            var closeActiveAnimations, chain = [];
                            return before && chain.push(function (fn) {
                                closeActiveAnimations = before(fn)
                            }), chain.length ? chain.push(function (fn) {
                                    applyOptions(), fn(!0)
                                }) : applyOptions(), after && chain.push(function (fn) {
                                closeActiveAnimations = after(fn)
                            }), runner.setHost({
                                end: function () {
                                    endAnimations()
                                }, cancel: function () {
                                    endAnimations(!0)
                                }
                            }), $$AnimateRunner.chain(chain, onComplete), runner
                        }
                    }
                }
            }
        }]
    }], $$AnimateJsDriverProvider = ["$$animationProvider", function ($$animationProvider) {
        $$animationProvider.drivers.push("$$animateJsDriver"), this.$get = ["$$animateJs", "$$AnimateRunner", function ($$animateJs, $$AnimateRunner) {
            function prepareAnimation(animationDetails) {
                var element = animationDetails.element, event = animationDetails.event, options = animationDetails.options, classes = animationDetails.classes;
                return $$animateJs(element, event, classes, options)
            }

            return function (animationDetails) {
                if (animationDetails.from && animationDetails.to) {
                    var fromAnimation = prepareAnimation(animationDetails.from), toAnimation = prepareAnimation(animationDetails.to);
                    if (!fromAnimation && !toAnimation)return;
                    return {
                        start: function () {
                            function endFnFactory() {
                                return function () {
                                    forEach(animationRunners, function (runner) {
                                        runner.end()
                                    })
                                }
                            }

                            function done(status) {
                                runner.complete(status)
                            }

                            var animationRunners = [];
                            fromAnimation && animationRunners.push(fromAnimation.start()), toAnimation && animationRunners.push(toAnimation.start()), $$AnimateRunner.all(animationRunners, done);
                            var runner = new $$AnimateRunner({end: endFnFactory(), cancel: endFnFactory()});
                            return runner
                        }
                    }
                }
                return prepareAnimation(animationDetails)
            }
        }]
    }], NG_ANIMATE_ATTR_NAME = "data-ng-animate", NG_ANIMATE_PIN_DATA = "$ngAnimatePin", $$AnimateQueueProvider = ["$animateProvider", function ($animateProvider) {
        function makeTruthyCssClassMap(classString) {
            if (!classString)return null;
            var keys = classString.split(ONE_SPACE), map = Object.create(null);
            return forEach(keys, function (key) {
                map[key] = !0
            }), map
        }

        function hasMatchingClasses(newClassString, currentClassString) {
            if (newClassString && currentClassString) {
                var currentClassMap = makeTruthyCssClassMap(currentClassString);
                return newClassString.split(ONE_SPACE).some(function (className) {
                    return currentClassMap[className]
                })
            }
        }

        function isAllowed(ruleType, element, currentAnimation, previousAnimation) {
            return rules[ruleType].some(function (fn) {
                return fn(element, currentAnimation, previousAnimation)
            })
        }

        function hasAnimationClasses(animation, and) {
            var a = (animation.addClass || "").length > 0, b = (animation.removeClass || "").length > 0;
            return and ? a && b : a || b
        }

        var PRE_DIGEST_STATE = 1, RUNNING_STATE = 2, ONE_SPACE = " ", rules = this.rules = {
            skip: [],
            cancel: [],
            join: []
        };
        rules.join.push(function (element, newAnimation, currentAnimation) {
            return !newAnimation.structural && hasAnimationClasses(newAnimation)
        }), rules.skip.push(function (element, newAnimation, currentAnimation) {
            return !newAnimation.structural && !hasAnimationClasses(newAnimation)
        }), rules.skip.push(function (element, newAnimation, currentAnimation) {
            return "leave" == currentAnimation.event && newAnimation.structural
        }), rules.skip.push(function (element, newAnimation, currentAnimation) {
            return currentAnimation.structural && currentAnimation.state === RUNNING_STATE && !newAnimation.structural
        }), rules.cancel.push(function (element, newAnimation, currentAnimation) {
            return currentAnimation.structural && newAnimation.structural
        }), rules.cancel.push(function (element, newAnimation, currentAnimation) {
            return currentAnimation.state === RUNNING_STATE && newAnimation.structural
        }), rules.cancel.push(function (element, newAnimation, currentAnimation) {
            if (currentAnimation.structural)return !1;
            var nA = newAnimation.addClass, nR = newAnimation.removeClass, cA = currentAnimation.addClass, cR = currentAnimation.removeClass;
            return isUndefined(nA) && isUndefined(nR) || isUndefined(cA) && isUndefined(cR) ? !1 : hasMatchingClasses(nA, cR) || hasMatchingClasses(nR, cA)
        }), this.$get = ["$$rAF", "$rootScope", "$rootElement", "$document", "$$HashMap", "$$animation", "$$AnimateRunner", "$templateRequest", "$$jqLite", "$$forceReflow", function ($$rAF, $rootScope, $rootElement, $document, $$HashMap, $$animation, $$AnimateRunner, $templateRequest, $$jqLite, $$forceReflow) {
            function postDigestTaskFactory() {
                var postDigestCalled = !1;
                return function (fn) {
                    postDigestCalled ? fn() : $rootScope.$$postDigest(function () {
                            postDigestCalled = !0, fn()
                        })
                }
            }

            function normalizeAnimationDetails(element, animation) {
                return mergeAnimationDetails(element, animation, {})
            }

            function findCallbacks(parent, element, event) {
                var targetNode = getDomNode(element), targetParentNode = getDomNode(parent), matches = [], entries = callbackRegistry[event];
                return entries && forEach(entries, function (entry) {
                    contains.call(entry.node, targetNode) ? matches.push(entry.callback) : "leave" === event && contains.call(entry.node, targetParentNode) && matches.push(entry.callback)
                }), matches
            }

            function filterFromRegistry(list, matchContainer, matchCallback) {
                var containerNode = extractElementNode(matchContainer);
                return list.filter(function (entry) {
                    var isMatch = entry.node === containerNode && (!matchCallback || entry.callback === matchCallback);
                    return !isMatch
                })
            }

            function cleanupEventListeners(phase, element) {
                "close" !== phase || element[0].parentNode || $animate.off(element)
            }

            function queueAnimation(element, event, initialOptions) {
                function notifyProgress(runner, event, phase, data) {
                    runInNextPostDigestOrNow(function () {
                        var callbacks = findCallbacks(parent, element, event);
                        callbacks.length ? $$rAF(function () {
                                forEach(callbacks, function (callback) {
                                    callback(element, phase, data)
                                }), cleanupEventListeners(phase, element)
                            }) : cleanupEventListeners(phase, element)
                    }), runner.progress(event, phase, data)
                }

                function close(reject) {
                    clearGeneratedClasses(element, options), applyAnimationClasses(element, options), applyAnimationStyles(element, options), options.domOperation(), runner.complete(!reject)
                }

                var node, parent, options = copy(initialOptions);
                element = stripCommentsFromElement(element), element && (node = getDomNode(element), parent = element.parent()), options = prepareAnimationOptions(options);
                var runner = new $$AnimateRunner, runInNextPostDigestOrNow = postDigestTaskFactory();
                if (isArray(options.addClass) && (options.addClass = options.addClass.join(" ")), options.addClass && !isString(options.addClass) && (options.addClass = null), isArray(options.removeClass) && (options.removeClass = options.removeClass.join(" ")), options.removeClass && !isString(options.removeClass) && (options.removeClass = null), options.from && !isObject(options.from) && (options.from = null), options.to && !isObject(options.to) && (options.to = null), !node)return close(), runner;
                var className = [node.className, options.addClass, options.removeClass].join(" ");
                if (!isAnimatableClassName(className))return close(), runner;
                var isStructural = ["enter", "move", "leave"].indexOf(event) >= 0, documentHidden = $document[0].hidden, skipAnimations = !animationsEnabled || documentHidden || disabledElementsLookup.get(node), existingAnimation = !skipAnimations && activeAnimationsLookup.get(node) || {}, hasExistingAnimation = !!existingAnimation.state;
                if (skipAnimations || hasExistingAnimation && existingAnimation.state == PRE_DIGEST_STATE || (skipAnimations = !areAnimationsAllowed(element, parent, event)), skipAnimations)return documentHidden && notifyProgress(runner, event, "start"), close(), documentHidden && notifyProgress(runner, event, "close"), runner;
                isStructural && closeChildAnimations(element);
                var newAnimation = {
                    structural: isStructural,
                    element: element,
                    event: event,
                    addClass: options.addClass,
                    removeClass: options.removeClass,
                    close: close,
                    options: options,
                    runner: runner
                };
                if (hasExistingAnimation) {
                    var skipAnimationFlag = isAllowed("skip", element, newAnimation, existingAnimation);
                    if (skipAnimationFlag)return existingAnimation.state === RUNNING_STATE ? (close(), runner) : (mergeAnimationDetails(element, existingAnimation, newAnimation), existingAnimation.runner);
                    var cancelAnimationFlag = isAllowed("cancel", element, newAnimation, existingAnimation);
                    if (cancelAnimationFlag)if (existingAnimation.state === RUNNING_STATE) existingAnimation.runner.end(); else {
                        if (!existingAnimation.structural)return mergeAnimationDetails(element, existingAnimation, newAnimation), existingAnimation.runner;
                        existingAnimation.close()
                    } else {
                        var joinAnimationFlag = isAllowed("join", element, newAnimation, existingAnimation);
                        if (joinAnimationFlag) {
                            if (existingAnimation.state !== RUNNING_STATE)return applyGeneratedPreparationClasses(element, isStructural ? event : null, options), event = newAnimation.event = existingAnimation.event, options = mergeAnimationDetails(element, existingAnimation, newAnimation), existingAnimation.runner;
                            normalizeAnimationDetails(element, newAnimation)
                        }
                    }
                } else normalizeAnimationDetails(element, newAnimation);
                var isValidAnimation = newAnimation.structural;
                if (isValidAnimation || (isValidAnimation = "animate" === newAnimation.event && Object.keys(newAnimation.options.to || {}).length > 0 || hasAnimationClasses(newAnimation)), !isValidAnimation)return close(), clearElementAnimationState(element), runner;
                var counter = (existingAnimation.counter || 0) + 1;
                return newAnimation.counter = counter, markElementAnimationState(element, PRE_DIGEST_STATE, newAnimation), $rootScope.$$postDigest(function () {
                    var animationDetails = activeAnimationsLookup.get(node), animationCancelled = !animationDetails;
                    animationDetails = animationDetails || {};
                    var parentElement = element.parent() || [], isValidAnimation = parentElement.length > 0 && ("animate" === animationDetails.event || animationDetails.structural || hasAnimationClasses(animationDetails));
                    if (animationCancelled || animationDetails.counter !== counter || !isValidAnimation)return animationCancelled && (applyAnimationClasses(element, options), applyAnimationStyles(element, options)), (animationCancelled || isStructural && animationDetails.event !== event) && (options.domOperation(), runner.end()), void(isValidAnimation || clearElementAnimationState(element));
                    event = !animationDetails.structural && hasAnimationClasses(animationDetails, !0) ? "setClass" : animationDetails.event, markElementAnimationState(element, RUNNING_STATE);
                    var realRunner = $$animation(element, event, animationDetails.options);
                    runner.setHost(realRunner), notifyProgress(runner, event, "start", {}), realRunner.done(function (status) {
                        close(!status);
                        var animationDetails = activeAnimationsLookup.get(node);
                        animationDetails && animationDetails.counter === counter && clearElementAnimationState(getDomNode(element)), notifyProgress(runner, event, "close", {})
                    })
                }), runner
            }

            function closeChildAnimations(element) {
                var node = getDomNode(element), children = node.querySelectorAll("[" + NG_ANIMATE_ATTR_NAME + "]");
                forEach(children, function (child) {
                    var state = parseInt(child.getAttribute(NG_ANIMATE_ATTR_NAME)), animationDetails = activeAnimationsLookup.get(child);
                    if (animationDetails)switch (state) {
                        case RUNNING_STATE:
                            animationDetails.runner.end();
                        case PRE_DIGEST_STATE:
                            activeAnimationsLookup.remove(child)
                    }
                })
            }

            function clearElementAnimationState(element) {
                var node = getDomNode(element);
                node.removeAttribute(NG_ANIMATE_ATTR_NAME), activeAnimationsLookup.remove(node)
            }

            function isMatchingElement(nodeOrElmA, nodeOrElmB) {
                return getDomNode(nodeOrElmA) === getDomNode(nodeOrElmB)
            }

            function areAnimationsAllowed(element, parentElement, event) {
                var animateChildren, bodyElement = jqLite($document[0].body), bodyElementDetected = isMatchingElement(element, bodyElement) || "HTML" === element[0].nodeName, rootElementDetected = isMatchingElement(element, $rootElement), parentAnimationDetected = !1, elementDisabled = disabledElementsLookup.get(getDomNode(element)), parentHost = jqLite.data(element[0], NG_ANIMATE_PIN_DATA);
                for (parentHost && (parentElement = parentHost), parentElement = getDomNode(parentElement); parentElement && (rootElementDetected || (rootElementDetected = isMatchingElement(parentElement, $rootElement)), parentElement.nodeType === ELEMENT_NODE);) {
                    var details = activeAnimationsLookup.get(parentElement) || {};
                    if (!parentAnimationDetected) {
                        var parentElementDisabled = disabledElementsLookup.get(parentElement);
                        if (parentElementDisabled === !0 && elementDisabled !== !1) {
                            elementDisabled = !0;
                            break
                        }
                        parentElementDisabled === !1 && (elementDisabled = !1), parentAnimationDetected = details.structural
                    }
                    if (isUndefined(animateChildren) || animateChildren === !0) {
                        var value = jqLite.data(parentElement, NG_ANIMATE_CHILDREN_DATA);
                        isDefined(value) && (animateChildren = value)
                    }
                    if (parentAnimationDetected && animateChildren === !1)break;
                    if (bodyElementDetected || (bodyElementDetected = isMatchingElement(parentElement, bodyElement)), bodyElementDetected && rootElementDetected)break;
                    parentElement = rootElementDetected || !(parentHost = jqLite.data(parentElement, NG_ANIMATE_PIN_DATA)) ? parentElement.parentNode : getDomNode(parentHost)
                }
                var allowAnimation = (!parentAnimationDetected || animateChildren) && elementDisabled !== !0;
                return allowAnimation && rootElementDetected && bodyElementDetected
            }

            function markElementAnimationState(element, state, details) {
                details = details || {}, details.state = state;
                var node = getDomNode(element);
                node.setAttribute(NG_ANIMATE_ATTR_NAME, state);
                var oldValue = activeAnimationsLookup.get(node), newValue = oldValue ? extend(oldValue, details) : details;
                activeAnimationsLookup.put(node, newValue)
            }

            var activeAnimationsLookup = new $$HashMap, disabledElementsLookup = new $$HashMap, animationsEnabled = null, deregisterWatch = $rootScope.$watch(function () {
                return 0 === $templateRequest.totalPendingRequests
            }, function (isEmpty) {
                isEmpty && (deregisterWatch(), $rootScope.$$postDigest(function () {
                    $rootScope.$$postDigest(function () {
                        null === animationsEnabled && (animationsEnabled = !0)
                    })
                }))
            }), callbackRegistry = Object.create(null), classNameFilter = $animateProvider.classNameFilter(), isAnimatableClassName = classNameFilter ? function (className) {
                    return classNameFilter.test(className)
                } : function () {
                    return !0
                }, applyAnimationClasses = applyAnimationClassesFactory($$jqLite), contains = window.Node.prototype.contains || function (arg) {
                    return this === arg || !!(16 & this.compareDocumentPosition(arg))
                }, $animate = {
                on: function (event, container, callback) {
                    var node = extractElementNode(container);
                    callbackRegistry[event] = callbackRegistry[event] || [], callbackRegistry[event].push({
                        node: node,
                        callback: callback
                    }), jqLite(container).on("$destroy", function () {
                        var animationDetails = activeAnimationsLookup.get(node);
                        animationDetails || $animate.off(event, container, callback)
                    })
                }, off: function (event, container, callback) {
                    if (1 !== arguments.length || isString(arguments[0])) {
                        var entries = callbackRegistry[event];
                        entries && (callbackRegistry[event] = 1 === arguments.length ? null : filterFromRegistry(entries, container, callback))
                    } else {
                        container = arguments[0];
                        for (var eventType in callbackRegistry)callbackRegistry[eventType] = filterFromRegistry(callbackRegistry[eventType], container)
                    }
                }, pin: function (element, parentElement) {
                    assertArg(isElement(element), "element", "not an element"), assertArg(isElement(parentElement), "parentElement", "not an element"), element.data(NG_ANIMATE_PIN_DATA, parentElement)
                }, push: function (element, event, options, domOperation) {
                    return options = options || {}, options.domOperation = domOperation, queueAnimation(element, event, options)
                }, enabled: function (element, bool) {
                    var argCount = arguments.length;
                    if (0 === argCount) bool = !!animationsEnabled; else {
                        var hasElement = isElement(element);
                        if (hasElement) {
                            var node = getDomNode(element);
                            1 === argCount ? bool = !disabledElementsLookup.get(node) : disabledElementsLookup.put(node, !bool)
                        } else bool = animationsEnabled = !!element
                    }
                    return bool
                }
            };
            return $animate
        }]
    }], $$AnimationProvider = ["$animateProvider", function ($animateProvider) {
        function setRunner(element, runner) {
            element.data(RUNNER_STORAGE_KEY, runner)
        }

        function removeRunner(element) {
            element.removeData(RUNNER_STORAGE_KEY)
        }

        function getRunner(element) {
            return element.data(RUNNER_STORAGE_KEY)
        }

        var NG_ANIMATE_REF_ATTR = "ng-animate-ref", drivers = this.drivers = [], RUNNER_STORAGE_KEY = "$$animationRunner";
        this.$get = ["$$jqLite", "$rootScope", "$injector", "$$AnimateRunner", "$$HashMap", "$$rAFScheduler", function ($$jqLite, $rootScope, $injector, $$AnimateRunner, $$HashMap, $$rAFScheduler) {
            function sortAnimations(animations) {
                function processNode(entry) {
                    if (entry.processed)return entry;
                    entry.processed = !0;
                    var elementNode = entry.domNode, parentNode = elementNode.parentNode;
                    lookup.put(elementNode, entry);
                    for (var parentEntry; parentNode;) {
                        if (parentEntry = lookup.get(parentNode)) {
                            parentEntry.processed || (parentEntry = processNode(parentEntry));
                            break
                        }
                        parentNode = parentNode.parentNode
                    }
                    return (parentEntry || tree).children.push(entry), entry
                }

                function flatten(tree) {
                    var i, result = [], queue = [];
                    for (i = 0; i < tree.children.length; i++)queue.push(tree.children[i]);
                    var remainingLevelEntries = queue.length, nextLevelEntries = 0, row = [];
                    for (i = 0; i < queue.length; i++) {
                        var entry = queue[i];
                        0 >= remainingLevelEntries && (remainingLevelEntries = nextLevelEntries, nextLevelEntries = 0, result.push(row), row = []), row.push(entry.fn), entry.children.forEach(function (childEntry) {
                            nextLevelEntries++, queue.push(childEntry)
                        }), remainingLevelEntries--
                    }
                    return row.length && result.push(row), result
                }

                var i, tree = {children: []}, lookup = new $$HashMap;
                for (i = 0; i < animations.length; i++) {
                    var animation = animations[i];
                    lookup.put(animation.domNode, animations[i] = {
                        domNode: animation.domNode,
                        fn: animation.fn,
                        children: []
                    })
                }
                for (i = 0; i < animations.length; i++)processNode(animations[i]);
                return flatten(tree)
            }

            var animationQueue = [], applyAnimationClasses = applyAnimationClassesFactory($$jqLite);
            return function (element, event, options) {
                function getAnchorNodes(node) {
                    var SELECTOR = "[" + NG_ANIMATE_REF_ATTR + "]", items = node.hasAttribute(NG_ANIMATE_REF_ATTR) ? [node] : node.querySelectorAll(SELECTOR), anchors = [];
                    return forEach(items, function (node) {
                        var attr = node.getAttribute(NG_ANIMATE_REF_ATTR);
                        attr && attr.length && anchors.push(node)
                    }), anchors
                }

                function groupAnimations(animations) {
                    var preparedAnimations = [], refLookup = {};
                    forEach(animations, function (animation, index) {
                        var element = animation.element, node = getDomNode(element), event = animation.event, enterOrMove = ["enter", "move"].indexOf(event) >= 0, anchorNodes = animation.structural ? getAnchorNodes(node) : [];
                        if (anchorNodes.length) {
                            var direction = enterOrMove ? "to" : "from";
                            forEach(anchorNodes, function (anchor) {
                                var key = anchor.getAttribute(NG_ANIMATE_REF_ATTR);
                                refLookup[key] = refLookup[key] || {}, refLookup[key][direction] = {
                                    animationID: index,
                                    element: jqLite(anchor)
                                }
                            })
                        } else preparedAnimations.push(animation)
                    });
                    var usedIndicesLookup = {}, anchorGroups = {};
                    return forEach(refLookup, function (operations, key) {
                        var from = operations.from, to = operations.to;
                        if (!from || !to) {
                            var index = from ? from.animationID : to.animationID, indexKey = index.toString();
                            return void(usedIndicesLookup[indexKey] || (usedIndicesLookup[indexKey] = !0, preparedAnimations.push(animations[index])))
                        }
                        var fromAnimation = animations[from.animationID], toAnimation = animations[to.animationID], lookupKey = from.animationID.toString();
                        if (!anchorGroups[lookupKey]) {
                            var group = anchorGroups[lookupKey] = {
                                structural: !0,
                                beforeStart: function () {
                                    fromAnimation.beforeStart(), toAnimation.beforeStart()
                                },
                                close: function () {
                                    fromAnimation.close(), toAnimation.close()
                                },
                                classes: cssClassesIntersection(fromAnimation.classes, toAnimation.classes),
                                from: fromAnimation,
                                to: toAnimation,
                                anchors: []
                            };
                            group.classes.length ? preparedAnimations.push(group) : (preparedAnimations.push(fromAnimation), preparedAnimations.push(toAnimation))
                        }
                        anchorGroups[lookupKey].anchors.push({out: from.element, "in": to.element})
                    }), preparedAnimations
                }

                function cssClassesIntersection(a, b) {
                    a = a.split(" "), b = b.split(" ");
                    for (var matches = [], i = 0; i < a.length; i++) {
                        var aa = a[i];
                        if ("ng-" !== aa.substring(0, 3))for (var j = 0; j < b.length; j++)if (aa === b[j]) {
                            matches.push(aa);
                            break
                        }
                    }
                    return matches.join(" ")
                }

                function invokeFirstDriver(animationDetails) {
                    for (var i = drivers.length - 1; i >= 0; i--) {
                        var driverName = drivers[i], factory = $injector.get(driverName), driver = factory(animationDetails);
                        if (driver)return driver
                    }
                }

                function beforeStart() {
                    element.addClass(NG_ANIMATE_CLASSNAME), tempClasses && $$jqLite.addClass(element, tempClasses), prepareClassName && ($$jqLite.removeClass(element, prepareClassName), prepareClassName = null)
                }

                function updateAnimationRunners(animation, newRunner) {
                    function update(element) {
                        var runner = getRunner(element);
                        runner && runner.setHost(newRunner)
                    }

                    animation.from && animation.to ? (update(animation.from.element), update(animation.to.element)) : update(animation.element)
                }

                function handleDestroyedElement() {
                    var runner = getRunner(element);
                    !runner || "leave" === event && options.$$domOperationFired || runner.end()
                }

                function close(rejected) {
                    element.off("$destroy", handleDestroyedElement), removeRunner(element), applyAnimationClasses(element, options), applyAnimationStyles(element, options), options.domOperation(), tempClasses && $$jqLite.removeClass(element, tempClasses), element.removeClass(NG_ANIMATE_CLASSNAME), runner.complete(!rejected)
                }

                options = prepareAnimationOptions(options);
                var isStructural = ["enter", "move", "leave"].indexOf(event) >= 0, runner = new $$AnimateRunner({
                    end: function () {
                        close()
                    }, cancel: function () {
                        close(!0)
                    }
                });
                if (!drivers.length)return close(), runner;
                setRunner(element, runner);
                var classes = mergeClasses(element.attr("class"), mergeClasses(options.addClass, options.removeClass)), tempClasses = options.tempClasses;
                tempClasses && (classes += " " + tempClasses, options.tempClasses = null);
                var prepareClassName;
                return isStructural && (prepareClassName = "ng-" + event + PREPARE_CLASS_SUFFIX, $$jqLite.addClass(element, prepareClassName)), animationQueue.push({
                    element: element,
                    classes: classes,
                    event: event,
                    structural: isStructural,
                    options: options,
                    beforeStart: beforeStart,
                    close: close
                }), element.on("$destroy", handleDestroyedElement), animationQueue.length > 1 ? runner : ($rootScope.$$postDigest(function () {
                        var animations = [];
                        forEach(animationQueue, function (entry) {
                            getRunner(entry.element) ? animations.push(entry) : entry.close()
                        }), animationQueue.length = 0;
                        var groupedAnimations = groupAnimations(animations), toBeSortedAnimations = [];
                        forEach(groupedAnimations, function (animationEntry) {
                            toBeSortedAnimations.push({
                                domNode: getDomNode(animationEntry.from ? animationEntry.from.element : animationEntry.element),
                                fn: function () {
                                    animationEntry.beforeStart();
                                    var startAnimationFn, closeFn = animationEntry.close, targetElement = animationEntry.anchors ? animationEntry.from.element || animationEntry.to.element : animationEntry.element;
                                    if (getRunner(targetElement)) {
                                        var operation = invokeFirstDriver(animationEntry);
                                        operation && (startAnimationFn = operation.start)
                                    }
                                    if (startAnimationFn) {
                                        var animationRunner = startAnimationFn();
                                        animationRunner.done(function (status) {
                                            closeFn(!status)
                                        }), updateAnimationRunners(animationEntry, animationRunner)
                                    } else closeFn()
                                }
                            })
                        }), $$rAFScheduler(sortAnimations(toBeSortedAnimations))
                    }), runner)
            }
        }]
    }], ngAnimateSwapDirective = ["$animate", "$rootScope", function ($animate, $rootScope) {
        return {
            restrict: "A",
            transclude: "element",
            terminal: !0,
            priority: 600,
            link: function (scope, $element, attrs, ctrl, $transclude) {
                var previousElement, previousScope;
                scope.$watchCollection(attrs.ngAnimateSwap || attrs["for"], function (value) {
                    previousElement && $animate.leave(previousElement), previousScope && (previousScope.$destroy(), previousScope = null), (value || 0 === value) && (previousScope = scope.$new(), $transclude(previousScope, function (element) {
                        previousElement = element, $animate.enter(element, null, $element)
                    }))
                })
            }
        }
    }];
    angular.module("ngAnimate", [], function () {
        noop = angular.noop, copy = angular.copy, extend = angular.extend, jqLite = angular.element, forEach = angular.forEach, isArray = angular.isArray, isString = angular.isString, isObject = angular.isObject, isUndefined = angular.isUndefined, isDefined = angular.isDefined, isFunction = angular.isFunction, isElement = angular.isElement
    }).directive("ngAnimateSwap", ngAnimateSwapDirective).directive("ngAnimateChildren", $$AnimateChildrenDirective).factory("$$rAFScheduler", $$rAFSchedulerFactory).provider("$$animateQueue", $$AnimateQueueProvider).provider("$$animation", $$AnimationProvider).provider("$animateCss", $AnimateCssProvider).provider("$$animateCssDriver", $$AnimateCssDriverProvider).provider("$$animateJs", $$AnimateJsProvider).provider("$$animateJsDriver", $$AnimateJsDriverProvider)
}(window, window.angular), function (window, angular) {
    "use strict";
    function $$CookieWriter($document, $log, $browser) {
        function buildCookieString(name, value, options) {
            var path, expires;
            options = options || {}, expires = options.expires, path = angular.isDefined(options.path) ? options.path : cookiePath, angular.isUndefined(value) && (expires = "Thu, 01 Jan 1970 00:00:00 GMT", value = ""), angular.isString(expires) && (expires = new Date(expires));
            var str = encodeURIComponent(name) + "=" + encodeURIComponent(value);
            str += path ? ";path=" + path : "", str += options.domain ? ";domain=" + options.domain : "", str += expires ? ";expires=" + expires.toUTCString() : "", str += options.secure ? ";secure" : "";
            var cookieLength = str.length + 1;
            return cookieLength > 4096 && $log.warn("Cookie '" + name + "' possibly not set or overflowed because it was too large (" + cookieLength + " > 4096 bytes)!"), str
        }

        var cookiePath = $browser.baseHref(), rawDocument = $document[0];
        return function (name, value, options) {
            rawDocument.cookie = buildCookieString(name, value, options)
        }
    }

    angular.module("ngCookies", ["ng"]).provider("$cookies", [function () {
        function calcOptions(options) {
            return options ? angular.extend({}, defaults, options) : defaults
        }

        var defaults = this.defaults = {};
        this.$get = ["$$cookieReader", "$$cookieWriter", function ($$cookieReader, $$cookieWriter) {
            return {
                get: function (key) {
                    return $$cookieReader()[key]
                }, getObject: function (key) {
                    var value = this.get(key);
                    return value ? angular.fromJson(value) : value
                }, getAll: function () {
                    return $$cookieReader()
                }, put: function (key, value, options) {
                    $$cookieWriter(key, value, calcOptions(options))
                }, putObject: function (key, value, options) {
                    this.put(key, angular.toJson(value), options)
                }, remove: function (key, options) {
                    $$cookieWriter(key, void 0, calcOptions(options))
                }
            }
        }]
    }]), angular.module("ngCookies").factory("$cookieStore", ["$cookies", function ($cookies) {
        return {
            get: function (key) {
                return $cookies.getObject(key)
            }, put: function (key, value) {
                $cookies.putObject(key, value)
            }, remove: function (key) {
                $cookies.remove(key)
            }
        }
    }]), $$CookieWriter.$inject = ["$document", "$log", "$browser"], angular.module("ngCookies").provider("$$cookieWriter", function () {
        this.$get = $$CookieWriter
    })
}(window, window.angular), function (window, angular) {
    "use strict";
    function isValidDottedPath(path) {
        return null != path && "" !== path && "hasOwnProperty" !== path && MEMBER_NAME_REGEX.test("." + path)
    }

    function lookupDottedPath(obj, path) {
        if (!isValidDottedPath(path))throw $resourceMinErr("badmember", 'Dotted member path "@{0}" is invalid.', path);
        for (var keys = path.split("."), i = 0, ii = keys.length; ii > i && angular.isDefined(obj); i++) {
            var key = keys[i];
            obj = null !== obj ? obj[key] : void 0
        }
        return obj
    }

    function shallowClearAndCopy(src, dst) {
        dst = dst || {}, angular.forEach(dst, function (value, key) {
            delete dst[key]
        });
        for (var key in src)!src.hasOwnProperty(key) || "$" === key.charAt(0) && "$" === key.charAt(1) || (dst[key] = src[key]);
        return dst
    }

    var $resourceMinErr = angular.$$minErr("$resource"), MEMBER_NAME_REGEX = /^(\.[a-zA-Z_$@][0-9a-zA-Z_$@]*)+$/;
    angular.module("ngResource", ["ng"]).provider("$resource", function () {
        var PROTOCOL_AND_DOMAIN_REGEX = /^https?:\/\/[^\/]*/, provider = this;
        this.defaults = {
            stripTrailingSlashes: !0,
            cancellable: !1,
            actions: {
                get: {method: "GET"},
                save: {method: "POST"},
                query: {method: "GET", isArray: !0},
                remove: {method: "DELETE"},
                "delete": {method: "DELETE"}
            }
        }, this.$get = ["$http", "$log", "$q", "$timeout", function ($http, $log, $q, $timeout) {
            function encodeUriSegment(val) {
                return encodeUriQuery(val, !0).replace(/%26/gi, "&").replace(/%3D/gi, "=").replace(/%2B/gi, "+")
            }

            function encodeUriQuery(val, pctEncodeSpaces) {
                return encodeURIComponent(val).replace(/%40/gi, "@").replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, pctEncodeSpaces ? "%20" : "+")
            }

            function Route(template, defaults) {
                this.template = template, this.defaults = extend({}, provider.defaults, defaults), this.urlParams = {}
            }

            function resourceFactory(url, paramDefaults, actions, options) {
                function extractParams(data, actionParams) {
                    var ids = {};
                    return actionParams = extend({}, paramDefaults, actionParams), forEach(actionParams, function (value, key) {
                        isFunction(value) && (value = value(data)), ids[key] = value && value.charAt && "@" == value.charAt(0) ? lookupDottedPath(data, value.substr(1)) : value
                    }), ids
                }

                function defaultResponseInterceptor(response) {
                    return response.resource
                }

                function Resource(value) {
                    shallowClearAndCopy(value || {}, this)
                }

                var route = new Route(url, options);
                return actions = extend({}, provider.defaults.actions, actions), Resource.prototype.toJSON = function () {
                    var data = extend({}, this);
                    return delete data.$promise, delete data.$resolved, data
                }, forEach(actions, function (action, name) {
                    var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method), numericTimeout = action.timeout, cancellable = angular.isDefined(action.cancellable) ? action.cancellable : options && angular.isDefined(options.cancellable) ? options.cancellable : provider.defaults.cancellable;
                    numericTimeout && !angular.isNumber(numericTimeout) && ($log.debug("ngResource:\n  Only numeric values are allowed as `timeout`.\n  Promises are not supported in $resource, because the same value would be used for multiple requests. If you are looking for a way to cancel requests, you should use the `cancellable` option."), delete action.timeout, numericTimeout = null), Resource[name] = function (a1, a2, a3, a4) {
                        var data, success, error, params = {};
                        switch (arguments.length) {
                            case 4:
                                error = a4, success = a3;
                            case 3:
                            case 2:
                                if (!isFunction(a2)) {
                                    params = a1, data = a2, success = a3;
                                    break
                                }
                                if (isFunction(a1)) {
                                    success = a1, error = a2;
                                    break
                                }
                                success = a2, error = a3;
                            case 1:
                                isFunction(a1) ? success = a1 : hasBody ? data = a1 : params = a1;
                                break;
                            case 0:
                                break;
                            default:
                                throw $resourceMinErr("badargs", "Expected up to 4 arguments [params, data, success, error], got {0} arguments", arguments.length)
                        }
                        var timeoutDeferred, numericTimeoutPromise, isInstanceCall = this instanceof Resource, value = isInstanceCall ? data : action.isArray ? [] : new Resource(data), httpConfig = {}, responseInterceptor = action.interceptor && action.interceptor.response || defaultResponseInterceptor, responseErrorInterceptor = action.interceptor && action.interceptor.responseError || void 0;
                        forEach(action, function (value, key) {
                            switch (key) {
                                default:
                                    httpConfig[key] = copy(value);
                                    break;
                                case"params":
                                case"isArray":
                                case"interceptor":
                                case"cancellable":
                            }
                        }), !isInstanceCall && cancellable && (timeoutDeferred = $q.defer(), httpConfig.timeout = timeoutDeferred.promise, numericTimeout && (numericTimeoutPromise = $timeout(timeoutDeferred.resolve, numericTimeout))), hasBody && (httpConfig.data = data), route.setUrlParams(httpConfig, extend({}, extractParams(data, action.params || {}), params), action.url);
                        var promise = $http(httpConfig).then(function (response) {
                            var data = response.data;
                            if (data) {
                                if (angular.isArray(data) !== !!action.isArray)throw $resourceMinErr("badcfg", "Error in resource configuration for action `{0}`. Expected response to contain an {1} but got an {2} (Request: {3} {4})", name, action.isArray ? "array" : "object", angular.isArray(data) ? "array" : "object", httpConfig.method, httpConfig.url);
                                if (action.isArray) value.length = 0, forEach(data, function (item) {
                                    "object" == typeof item ? value.push(new Resource(item)) : value.push(item)
                                }); else {
                                    var promise = value.$promise;
                                    shallowClearAndCopy(data, value), value.$promise = promise
                                }
                            }
                            return response.resource = value, response
                        }, function (response) {
                            return (error || noop)(response), $q.reject(response)
                        });
                        return promise["finally"](function () {
                            value.$resolved = !0, !isInstanceCall && cancellable && (value.$cancelRequest = angular.noop, $timeout.cancel(numericTimeoutPromise), timeoutDeferred = numericTimeoutPromise = httpConfig.timeout = null)
                        }), promise = promise.then(function (response) {
                            var value = responseInterceptor(response);
                            return (success || noop)(value, response.headers), value
                        }, responseErrorInterceptor), isInstanceCall ? promise : (value.$promise = promise, value.$resolved = !1, cancellable && (value.$cancelRequest = timeoutDeferred.resolve), value)
                    }, Resource.prototype["$" + name] = function (params, success, error) {
                        isFunction(params) && (error = success, success = params, params = {});
                        var result = Resource[name].call(this, params, this, success, error);
                        return result.$promise || result
                    }
                }), Resource.bind = function (additionalParamDefaults) {
                    return resourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions)
                }, Resource
            }

            var noop = angular.noop, forEach = angular.forEach, extend = angular.extend, copy = angular.copy, isFunction = angular.isFunction;
            return Route.prototype = {
                setUrlParams: function (config, params, actionUrl) {
                    var val, encodedVal, self = this, url = actionUrl || self.template, protocolAndDomain = "", urlParams = self.urlParams = {};
                    forEach(url.split(/\W/), function (param) {
                        if ("hasOwnProperty" === param)throw $resourceMinErr("badname", "hasOwnProperty is not a valid parameter name.");
                        !new RegExp("^\\d+$").test(param) && param && new RegExp("(^|[^\\\\]):" + param + "(\\W|$)").test(url) && (urlParams[param] = {isQueryParamValue: new RegExp("\\?.*=:" + param + "(?:\\W|$)").test(url)})
                    }), url = url.replace(/\\:/g, ":"), url = url.replace(PROTOCOL_AND_DOMAIN_REGEX, function (match) {
                        return protocolAndDomain = match, ""
                    }), params = params || {}, forEach(self.urlParams, function (paramInfo, urlParam) {
                        val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam], angular.isDefined(val) && null !== val ? (encodedVal = paramInfo.isQueryParamValue ? encodeUriQuery(val, !0) : encodeUriSegment(val), url = url.replace(new RegExp(":" + urlParam + "(\\W|$)", "g"), function (match, p1) {
                                return encodedVal + p1
                            })) : url = url.replace(new RegExp("(/?):" + urlParam + "(\\W|$)", "g"), function (match, leadingSlashes, tail) {
                                return "/" == tail.charAt(0) ? tail : leadingSlashes + tail
                            })
                    }), self.defaults.stripTrailingSlashes && (url = url.replace(/\/+$/, "") || "/"), url = url.replace(/\/\.(?=\w+($|\?))/, "."), config.url = protocolAndDomain + url.replace(/\/\\\./, "/."), forEach(params, function (value, key) {
                        self.urlParams[key] || (config.params = config.params || {}, config.params[key] = value)
                    })
                }
            }, resourceFactory
        }]
    })
}(window, window.angular), function (window, angular) {
    "use strict";
    function shallowCopy(src, dst) {
        if (isArray(src)) {
            dst = dst || [];
            for (var i = 0, ii = src.length; ii > i; i++)dst[i] = src[i]
        } else if (isObject(src)) {
            dst = dst || {};
            for (var key in src)("$" !== key.charAt(0) || "$" !== key.charAt(1)) && (dst[key] = src[key])
        }
        return dst || src
    }

    function $RouteProvider() {
        function inherit(parent, extra) {
            return angular.extend(Object.create(parent), extra)
        }

        function pathRegExp(path, opts) {
            var insensitive = opts.caseInsensitiveMatch, ret = {originalPath: path, regexp: path}, keys = ret.keys = [];
            return path = path.replace(/([().])/g, "\\$1").replace(/(\/)?:(\w+)(\*\?|[\?\*])?/g, function (_, slash, key, option) {
                var optional = "?" === option || "*?" === option ? "?" : null, star = "*" === option || "*?" === option ? "*" : null;
                return keys.push({
                    name: key,
                    optional: !!optional
                }), slash = slash || "", "" + (optional ? "" : slash) + "(?:" + (optional ? slash : "") + (star && "(.+?)" || "([^/]+)") + (optional || "") + ")" + (optional || "")
            }).replace(/([\/$\*])/g, "\\$1"), ret.regexp = new RegExp("^" + path + "$", insensitive ? "i" : ""), ret
        }

        isArray = angular.isArray, isObject = angular.isObject;
        var routes = {};
        this.when = function (path, route) {
            var routeCopy = shallowCopy(route);
            if (angular.isUndefined(routeCopy.reloadOnSearch) && (routeCopy.reloadOnSearch = !0), angular.isUndefined(routeCopy.caseInsensitiveMatch) && (routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch), routes[path] = angular.extend(routeCopy, path && pathRegExp(path, routeCopy)), path) {
                var redirectPath = "/" == path[path.length - 1] ? path.substr(0, path.length - 1) : path + "/";
                routes[redirectPath] = angular.extend({redirectTo: path}, pathRegExp(redirectPath, routeCopy))
            }
            return this
        }, this.caseInsensitiveMatch = !1, this.otherwise = function (params) {
            return "string" == typeof params && (params = {redirectTo: params}), this.when(null, params), this
        }, this.$get = ["$rootScope", "$location", "$routeParams", "$q", "$injector", "$templateRequest", "$sce", function ($rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce) {
            function switchRouteMatcher(on, route) {
                var keys = route.keys, params = {};
                if (!route.regexp)return null;
                var m = route.regexp.exec(on);
                if (!m)return null;
                for (var i = 1, len = m.length; len > i; ++i) {
                    var key = keys[i - 1], val = m[i];
                    key && val && (params[key.name] = val)
                }
                return params
            }

            function prepareRoute($locationEvent) {
                var lastRoute = $route.current;
                preparedRoute = parseRoute(), preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route && angular.equals(preparedRoute.pathParams, lastRoute.pathParams) && !preparedRoute.reloadOnSearch && !forceReload, preparedRouteIsUpdateOnly || !lastRoute && !preparedRoute || $rootScope.$broadcast("$routeChangeStart", preparedRoute, lastRoute).defaultPrevented && $locationEvent && $locationEvent.preventDefault()
            }

            function commitRoute() {
                var lastRoute = $route.current, nextRoute = preparedRoute;
                preparedRouteIsUpdateOnly ? (lastRoute.params = nextRoute.params, angular.copy(lastRoute.params, $routeParams), $rootScope.$broadcast("$routeUpdate", lastRoute)) : (nextRoute || lastRoute) && (forceReload = !1, $route.current = nextRoute, nextRoute && nextRoute.redirectTo && (angular.isString(nextRoute.redirectTo) ? $location.path(interpolate(nextRoute.redirectTo, nextRoute.params)).search(nextRoute.params).replace() : $location.url(nextRoute.redirectTo(nextRoute.pathParams, $location.path(), $location.search())).replace()), $q.when(nextRoute).then(resolveLocals).then(function (locals) {
                        nextRoute == $route.current && (nextRoute && (nextRoute.locals = locals, angular.copy(nextRoute.params, $routeParams)), $rootScope.$broadcast("$routeChangeSuccess", nextRoute, lastRoute))
                    }, function (error) {
                        nextRoute == $route.current && $rootScope.$broadcast("$routeChangeError", nextRoute, lastRoute, error)
                    }))
            }

            function resolveLocals(route) {
                if (route) {
                    var locals = angular.extend({}, route.resolve);
                    angular.forEach(locals, function (value, key) {
                        locals[key] = angular.isString(value) ? $injector.get(value) : $injector.invoke(value, null, null, key)
                    });
                    var template = getTemplateFor(route);
                    return angular.isDefined(template) && (locals.$template = template), $q.all(locals)
                }
            }

            function getTemplateFor(route) {
                var template, templateUrl;
                return angular.isDefined(template = route.template) ? angular.isFunction(template) && (template = template(route.params)) : angular.isDefined(templateUrl = route.templateUrl) && (angular.isFunction(templateUrl) && (templateUrl = templateUrl(route.params)), angular.isDefined(templateUrl) && (route.loadedTemplateUrl = $sce.valueOf(templateUrl), template = $templateRequest(templateUrl))), template
            }

            function parseRoute() {
                var params, match;
                return angular.forEach(routes, function (route, path) {
                    !match && (params = switchRouteMatcher($location.path(), route)) && (match = inherit(route, {
                        params: angular.extend({}, $location.search(), params),
                        pathParams: params
                    }), match.$$route = route)
                }), match || routes[null] && inherit(routes[null], {params: {}, pathParams: {}})
            }

            function interpolate(string, params) {
                var result = [];
                return angular.forEach((string || "").split(":"), function (segment, i) {
                    if (0 === i) result.push(segment); else {
                        var segmentMatch = segment.match(/(\w+)(?:[?*])?(.*)/), key = segmentMatch[1];
                        result.push(params[key]), result.push(segmentMatch[2] || ""), delete params[key]
                    }
                }), result.join("")
            }

            var preparedRoute, preparedRouteIsUpdateOnly, forceReload = !1, $route = {
                routes: routes,
                reload: function () {
                    forceReload = !0;
                    var fakeLocationEvent = {
                        defaultPrevented: !1, preventDefault: function () {
                            this.defaultPrevented = !0, forceReload = !1
                        }
                    };
                    $rootScope.$evalAsync(function () {
                        prepareRoute(fakeLocationEvent), fakeLocationEvent.defaultPrevented || commitRoute()
                    })
                },
                updateParams: function (newParams) {
                    if (!this.current || !this.current.$$route)throw $routeMinErr("norout", "Tried updating route when with no current route");
                    newParams = angular.extend({}, this.current.params, newParams), $location.path(interpolate(this.current.$$route.originalPath, newParams)), $location.search(newParams)
                }
            };
            return $rootScope.$on("$locationChangeStart", prepareRoute), $rootScope.$on("$locationChangeSuccess", commitRoute), $route
        }]
    }

    function $RouteParamsProvider() {
        this.$get = function () {
            return {}
        }
    }

    function ngViewFactory($route, $anchorScroll, $animate) {
        return {
            restrict: "ECA",
            terminal: !0,
            priority: 400,
            transclude: "element",
            link: function (scope, $element, attr, ctrl, $transclude) {
                function cleanupLastView() {
                    previousLeaveAnimation && ($animate.cancel(previousLeaveAnimation), previousLeaveAnimation = null), currentScope && (currentScope.$destroy(), currentScope = null), currentElement && (previousLeaveAnimation = $animate.leave(currentElement), previousLeaveAnimation.then(function () {
                        previousLeaveAnimation = null
                    }), currentElement = null)
                }

                function update() {
                    var locals = $route.current && $route.current.locals, template = locals && locals.$template;
                    if (angular.isDefined(template)) {
                        var newScope = scope.$new(), current = $route.current, clone = $transclude(newScope, function (clone) {
                            $animate.enter(clone, null, currentElement || $element).then(function () {
                                !angular.isDefined(autoScrollExp) || autoScrollExp && !scope.$eval(autoScrollExp) || $anchorScroll()
                            }), cleanupLastView()
                        });
                        currentElement = clone, currentScope = current.scope = newScope, currentScope.$emit("$viewContentLoaded"), currentScope.$eval(onloadExp)
                    } else cleanupLastView()
                }

                var currentScope, currentElement, previousLeaveAnimation, autoScrollExp = attr.autoscroll, onloadExp = attr.onload || "";
                scope.$on("$routeChangeSuccess", update), update()
            }
        }
    }

    function ngViewFillContentFactory($compile, $controller, $route) {
        return {
            restrict: "ECA", priority: -400, link: function (scope, $element) {
                var current = $route.current, locals = current.locals;
                $element.html(locals.$template);
                var link = $compile($element.contents());
                if (current.controller) {
                    locals.$scope = scope;
                    var controller = $controller(current.controller, locals);
                    current.controllerAs && (scope[current.controllerAs] = controller), $element.data("$ngControllerController", controller), $element.children().data("$ngControllerController", controller)
                }
                scope[current.resolveAs || "$resolve"] = locals, link(scope)
            }
        }
    }

    var isArray, isObject, ngRouteModule = angular.module("ngRoute", ["ng"]).provider("$route", $RouteProvider), $routeMinErr = angular.$$minErr("ngRoute");
    ngRouteModule.provider("$routeParams", $RouteParamsProvider), ngRouteModule.directive("ngView", ngViewFactory), ngRouteModule.directive("ngView", ngViewFillContentFactory), ngViewFactory.$inject = ["$route", "$anchorScroll", "$animate"], ngViewFillContentFactory.$inject = ["$compile", "$controller", "$route"]
}(window, window.angular), function (window, angular) {
    "use strict";
    function $SanitizeProvider() {
        function toMap(str, lowercaseKeys) {
            var i, obj = {}, items = str.split(",");
            for (i = 0; i < items.length; i++)obj[lowercaseKeys ? lowercase(items[i]) : items[i]] = !0;
            return obj
        }

        function htmlParserImpl(html, handler) {
            null === html || void 0 === html ? html = "" : "string" != typeof html && (html = "" + html), inertBodyElement.innerHTML = html;
            var mXSSAttempts = 5;
            do {
                if (0 === mXSSAttempts)throw $sanitizeMinErr("uinput", "Failed to sanitize html because the input is unstable");
                mXSSAttempts--, window.document.documentMode && stripCustomNsAttrs(inertBodyElement), html = inertBodyElement.innerHTML, inertBodyElement.innerHTML = html
            } while (html !== inertBodyElement.innerHTML);
            for (var node = inertBodyElement.firstChild; node;) {
                switch (node.nodeType) {
                    case 1:
                        handler.start(node.nodeName.toLowerCase(), attrToMap(node.attributes));
                        break;
                    case 3:
                        handler.chars(node.textContent)
                }
                var nextNode;
                if (!(nextNode = node.firstChild) && (1 == node.nodeType && handler.end(node.nodeName.toLowerCase()), nextNode = node.nextSibling, !nextNode))for (; null == nextNode && (node = node.parentNode, node !== inertBodyElement);)nextNode = node.nextSibling, 1 == node.nodeType && handler.end(node.nodeName.toLowerCase());
                node = nextNode
            }
            for (; node = inertBodyElement.firstChild;)inertBodyElement.removeChild(node)
        }

        function attrToMap(attrs) {
            for (var map = {}, i = 0, ii = attrs.length; ii > i; i++) {
                var attr = attrs[i];
                map[attr.name] = attr.value
            }
            return map
        }

        function encodeEntities(value) {
            return value.replace(/&/g, "&amp;").replace(SURROGATE_PAIR_REGEXP, function (value) {
                var hi = value.charCodeAt(0), low = value.charCodeAt(1);
                return "&#" + (1024 * (hi - 55296) + (low - 56320) + 65536) + ";"
            }).replace(NON_ALPHANUMERIC_REGEXP, function (value) {
                return "&#" + value.charCodeAt(0) + ";"
            }).replace(/</g, "&lt;").replace(/>/g, "&gt;")
        }

        function htmlSanitizeWriterImpl(buf, uriValidator) {
            var ignoreCurrentElement = !1, out = bind(buf, buf.push);
            return {
                start: function (tag, attrs) {
                    tag = lowercase(tag), !ignoreCurrentElement && blockedElements[tag] && (ignoreCurrentElement = tag), ignoreCurrentElement || validElements[tag] !== !0 || (out("<"), out(tag), forEach(attrs, function (value, key) {
                        var lkey = lowercase(key), isImage = "img" === tag && "src" === lkey || "background" === lkey;
                        validAttrs[lkey] !== !0 || uriAttrs[lkey] === !0 && !uriValidator(value, isImage) || (out(" "), out(key), out('="'), out(encodeEntities(value)), out('"'))
                    }), out(">"))
                }, end: function (tag) {
                    tag = lowercase(tag), ignoreCurrentElement || validElements[tag] !== !0 || voidElements[tag] === !0 || (out("</"), out(tag), out(">")), tag == ignoreCurrentElement && (ignoreCurrentElement = !1)
                }, chars: function (chars) {
                    ignoreCurrentElement || out(encodeEntities(chars))
                }
            }
        }

        function stripCustomNsAttrs(node) {
            if (node.nodeType === window.Node.ELEMENT_NODE)for (var attrs = node.attributes, i = 0, l = attrs.length; l > i; i++) {
                var attrNode = attrs[i], attrName = attrNode.name.toLowerCase();
                ("xmlns:ns1" === attrName || 0 === attrName.lastIndexOf("ns1:", 0)) && (node.removeAttributeNode(attrNode), i--, l--)
            }
            var nextNode = node.firstChild;
            nextNode && stripCustomNsAttrs(nextNode), nextNode = node.nextSibling, nextNode && stripCustomNsAttrs(nextNode)
        }

        var svgEnabled = !1;
        this.$get = ["$$sanitizeUri", function ($$sanitizeUri) {
            return svgEnabled && extend(validElements, svgElements), function (html) {
                var buf = [];
                return htmlParser(html, htmlSanitizeWriter(buf, function (uri, isImage) {
                    return !/^unsafe:/.test($$sanitizeUri(uri, isImage))
                })), buf.join("")
            }
        }], this.enableSvg = function (enableSvg) {
            return isDefined(enableSvg) ? (svgEnabled = enableSvg, this) : svgEnabled
        }, bind = angular.bind, extend = angular.extend, forEach = angular.forEach, isDefined = angular.isDefined, lowercase = angular.lowercase, noop = angular.noop, htmlParser = htmlParserImpl, htmlSanitizeWriter = htmlSanitizeWriterImpl;
        var inertBodyElement, SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g, NON_ALPHANUMERIC_REGEXP = /([^\#-~ |!])/g, voidElements = toMap("area,br,col,hr,img,wbr"), optionalEndTagBlockElements = toMap("colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr"), optionalEndTagInlineElements = toMap("rp,rt"), optionalEndTagElements = extend({}, optionalEndTagInlineElements, optionalEndTagBlockElements), blockElements = extend({}, optionalEndTagBlockElements, toMap("address,article,aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5,h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,section,table,ul")), inlineElements = extend({}, optionalEndTagInlineElements, toMap("a,abbr,acronym,b,bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s,samp,small,span,strike,strong,sub,sup,time,tt,u,var")), svgElements = toMap("circle,defs,desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient,line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,stop,svg,switch,text,title,tspan"), blockedElements = toMap("script,style"), validElements = extend({}, voidElements, blockElements, inlineElements, optionalEndTagElements), uriAttrs = toMap("background,cite,href,longdesc,src,xlink:href"), htmlAttrs = toMap("abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,scope,scrolling,shape,size,span,start,summary,tabindex,target,title,type,valign,value,vspace,width"), svgAttrs = toMap("accent-height,accumulate,additive,alphabetic,arabic-form,ascent,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,zoomAndPan", !0), validAttrs = extend({}, uriAttrs, svgAttrs, htmlAttrs);
        !function (window) {
            var doc;
            if (!window.document || !window.document.implementation)throw $sanitizeMinErr("noinert", "Can't create an inert html document");
            doc = window.document.implementation.createHTMLDocument("inert");
            var docElement = doc.documentElement || doc.getDocumentElement(), bodyElements = docElement.getElementsByTagName("body");
            if (1 === bodyElements.length) inertBodyElement = bodyElements[0]; else {
                var html = doc.createElement("html");
                inertBodyElement = doc.createElement("body"), html.appendChild(inertBodyElement), doc.appendChild(html)
            }
        }(window)
    }

    function sanitizeText(chars) {
        var buf = [], writer = htmlSanitizeWriter(buf, noop);
        return writer.chars(chars), buf.join("")
    }

    var bind, extend, forEach, isDefined, lowercase, noop, htmlParser, htmlSanitizeWriter, $sanitizeMinErr = angular.$$minErr("$sanitize");
    angular.module("ngSanitize", []).provider("$sanitize", $SanitizeProvider), angular.module("ngSanitize").filter("linky", ["$sanitize", function ($sanitize) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"\u201d\u2019]/i, MAILTO_REGEXP = /^mailto:/i, linkyMinErr = angular.$$minErr("linky"), isDefined = angular.isDefined, isFunction = angular.isFunction, isObject = angular.isObject, isString = angular.isString;
        return function (text, target, attributes) {
            function addText(text) {
                text && html.push(sanitizeText(text))
            }

            function addLink(url, text) {
                var key, linkAttributes = attributesFn(url);
                html.push("<a ");
                for (key in linkAttributes)html.push(key + '="' + linkAttributes[key] + '" ');
                !isDefined(target) || "target" in linkAttributes || html.push('target="', target, '" '), html.push('href="', url.replace(/"/g, "&quot;"), '">'), addText(text), html.push("</a>")
            }

            if (null == text || "" === text)return text;
            if (!isString(text))throw linkyMinErr("notstring", "Expected string but received: {0}", text);
            for (var match, url, i, attributesFn = isFunction(attributes) ? attributes : isObject(attributes) ? function () {
                        return attributes
                    } : function () {
                        return {}
                    }, raw = text, html = []; match = raw.match(LINKY_URL_REGEXP);)url = match[0], match[2] || match[4] || (url = (match[3] ? "http://" : "mailto:") + url), i = match.index, addText(raw.substr(0, i)), addLink(url, match[0].replace(MAILTO_REGEXP, "")), raw = raw.substring(i + match[0].length);
            return addText(raw), $sanitize(html.join(""))
        }
    }])
}(window, window.angular), function (window, angular) {
    "use strict";
    function nodeName_(element) {
        return angular.lowercase(element.nodeName || element[0] && element[0].nodeName)
    }

    function $TouchProvider($provide, $compileProvider) {
        var ngClickOverrideEnabled = !1, ngClickDirectiveAdded = !1;
        this.ngClickOverrideEnabled = function (enabled) {
            return angular.isDefined(enabled) ? (enabled && !ngClickDirectiveAdded && (ngClickDirectiveAdded = !0, ngTouchClickDirectiveFactory.$$moduleName = "ngTouch", $compileProvider.directive("ngClick", ngTouchClickDirectiveFactory), $provide.decorator("ngClickDirective", ["$delegate", function ($delegate) {
                    if (ngClickOverrideEnabled) $delegate.shift(); else for (var i = $delegate.length - 1; i >= 0;) {
                        if ("ngTouch" === $delegate[i].$$moduleName) {
                            $delegate.splice(i, 1);
                            break
                        }
                        i--
                    }
                    return $delegate
                }])), ngClickOverrideEnabled = enabled, this) : ngClickOverrideEnabled
        }, this.$get = function () {
            return {
                ngClickOverrideEnabled: function () {
                    return ngClickOverrideEnabled
                }
            }
        }
    }

    function makeSwipeDirective(directiveName, direction, eventName) {
        ngTouch.directive(directiveName, ["$parse", "$swipe", function ($parse, $swipe) {
            var MAX_VERTICAL_DISTANCE = 75, MAX_VERTICAL_RATIO = .3, MIN_HORIZONTAL_DISTANCE = 30;
            return function (scope, element, attr) {
                function validSwipe(coords) {
                    if (!startCoords)return !1;
                    var deltaY = Math.abs(coords.y - startCoords.y), deltaX = (coords.x - startCoords.x) * direction;
                    return valid && MAX_VERTICAL_DISTANCE > deltaY && deltaX > 0 && deltaX > MIN_HORIZONTAL_DISTANCE && MAX_VERTICAL_RATIO > deltaY / deltaX
                }

                var startCoords, valid, swipeHandler = $parse(attr[directiveName]), pointerTypes = ["touch"];
                angular.isDefined(attr.ngSwipeDisableMouse) || pointerTypes.push("mouse"), $swipe.bind(element, {
                    start: function (coords, event) {
                        startCoords = coords, valid = !0
                    }, cancel: function (event) {
                        valid = !1
                    }, end: function (coords, event) {
                        validSwipe(coords) && scope.$apply(function () {
                            element.triggerHandler(eventName), swipeHandler(scope, {$event: event})
                        })
                    }
                }, pointerTypes)
            }
        }])
    }

    var ngTouch = angular.module("ngTouch", []);
    ngTouch.provider("$touch", $TouchProvider), $TouchProvider.$inject = ["$provide", "$compileProvider"], ngTouch.factory("$swipe", [function () {
        function getCoordinates(event) {
            var originalEvent = event.originalEvent || event, touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent], e = originalEvent.changedTouches && originalEvent.changedTouches[0] || touches[0];
            return {x: e.clientX, y: e.clientY}
        }

        function getEvents(pointerTypes, eventType) {
            var res = [];
            return angular.forEach(pointerTypes, function (pointerType) {
                var eventName = POINTER_EVENTS[pointerType][eventType];
                eventName && res.push(eventName)
            }), res.join(" ")
        }

        var MOVE_BUFFER_RADIUS = 10, POINTER_EVENTS = {
            mouse: {start: "mousedown", move: "mousemove", end: "mouseup"},
            touch: {start: "touchstart", move: "touchmove", end: "touchend", cancel: "touchcancel"},
            pointer: {start: "pointerdown", move: "pointermove", end: "pointerup", cancel: "pointercancel"}
        };
        return {
            bind: function (element, eventHandlers, pointerTypes) {
                var totalX, totalY, startCoords, lastPos, active = !1;
                pointerTypes = pointerTypes || ["mouse", "touch", "pointer"], element.on(getEvents(pointerTypes, "start"), function (event) {
                    startCoords = getCoordinates(event), active = !0, totalX = 0, totalY = 0, lastPos = startCoords, eventHandlers.start && eventHandlers.start(startCoords, event)
                });
                var events = getEvents(pointerTypes, "cancel");
                events && element.on(events, function (event) {
                    active = !1, eventHandlers.cancel && eventHandlers.cancel(event)
                }), element.on(getEvents(pointerTypes, "move"), function (event) {
                    if (active && startCoords) {
                        var coords = getCoordinates(event);
                        if (totalX += Math.abs(coords.x - lastPos.x), totalY += Math.abs(coords.y - lastPos.y), lastPos = coords, !(MOVE_BUFFER_RADIUS > totalX && MOVE_BUFFER_RADIUS > totalY))return totalY > totalX ? (active = !1, void(eventHandlers.cancel && eventHandlers.cancel(event))) : (event.preventDefault(), void(eventHandlers.move && eventHandlers.move(coords, event)))
                    }
                }), element.on(getEvents(pointerTypes, "end"), function (event) {
                    active && (active = !1, eventHandlers.end && eventHandlers.end(getCoordinates(event), event))
                })
            }
        }
    }]);
    var ngTouchClickDirectiveFactory = ["$parse", "$timeout", "$rootElement", function ($parse, $timeout, $rootElement) {
        function hit(x1, y1, x2, y2) {
            return Math.abs(x1 - x2) < CLICKBUSTER_THRESHOLD && Math.abs(y1 - y2) < CLICKBUSTER_THRESHOLD
        }

        function checkAllowableRegions(touchCoordinates, x, y) {
            for (var i = 0; i < touchCoordinates.length; i += 2)if (hit(touchCoordinates[i], touchCoordinates[i + 1], x, y))return touchCoordinates.splice(i, i + 2), !0;
            return !1
        }

        function onClick(event) {
            if (!(Date.now() - lastPreventedTime > PREVENT_DURATION)) {
                var touches = event.touches && event.touches.length ? event.touches : [event], x = touches[0].clientX, y = touches[0].clientY;
                1 > x && 1 > y || lastLabelClickCoordinates && lastLabelClickCoordinates[0] === x && lastLabelClickCoordinates[1] === y || (lastLabelClickCoordinates && (lastLabelClickCoordinates = null), "label" === nodeName_(event.target) && (lastLabelClickCoordinates = [x, y]), checkAllowableRegions(touchCoordinates, x, y) || (event.stopPropagation(), event.preventDefault(), event.target && event.target.blur && event.target.blur()))
            }
        }

        function onTouchStart(event) {
            var touches = event.touches && event.touches.length ? event.touches : [event], x = touches[0].clientX, y = touches[0].clientY;
            touchCoordinates.push(x, y), $timeout(function () {
                for (var i = 0; i < touchCoordinates.length; i += 2)if (touchCoordinates[i] == x && touchCoordinates[i + 1] == y)return void touchCoordinates.splice(i, i + 2)
            }, PREVENT_DURATION, !1)
        }

        function preventGhostClick(x, y) {
            touchCoordinates || ($rootElement[0].addEventListener("click", onClick, !0), $rootElement[0].addEventListener("touchstart", onTouchStart, !0), touchCoordinates = []), lastPreventedTime = Date.now(), checkAllowableRegions(touchCoordinates, x, y)
        }

        var lastPreventedTime, touchCoordinates, lastLabelClickCoordinates, TAP_DURATION = 750, MOVE_TOLERANCE = 12, PREVENT_DURATION = 2500, CLICKBUSTER_THRESHOLD = 25, ACTIVE_CLASS_NAME = "ng-click-active";
        return function (scope, element, attr) {
            function resetState() {
                tapping = !1, element.removeClass(ACTIVE_CLASS_NAME)
            }

            var tapElement, startTime, touchStartX, touchStartY, clickHandler = $parse(attr.ngClick), tapping = !1;
            element.on("touchstart", function (event) {
                tapping = !0, tapElement = event.target ? event.target : event.srcElement, 3 == tapElement.nodeType && (tapElement = tapElement.parentNode), element.addClass(ACTIVE_CLASS_NAME), startTime = Date.now();
                var originalEvent = event.originalEvent || event, touches = originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent], e = touches[0];
                touchStartX = e.clientX, touchStartY = e.clientY
            }), element.on("touchcancel", function (event) {
                resetState()
            }), element.on("touchend", function (event) {
                var diff = Date.now() - startTime, originalEvent = event.originalEvent || event, touches = originalEvent.changedTouches && originalEvent.changedTouches.length ? originalEvent.changedTouches : originalEvent.touches && originalEvent.touches.length ? originalEvent.touches : [originalEvent], e = touches[0], x = e.clientX, y = e.clientY, dist = Math.sqrt(Math.pow(x - touchStartX, 2) + Math.pow(y - touchStartY, 2));
                tapping && TAP_DURATION > diff && MOVE_TOLERANCE > dist && (preventGhostClick(x, y), tapElement && tapElement.blur(), angular.isDefined(attr.disabled) && attr.disabled !== !1 || element.triggerHandler("click", [event])), resetState()
            }), element.onclick = function (event) {
            }, element.on("click", function (event, touchend) {
                scope.$apply(function () {
                    clickHandler(scope, {$event: touchend || event})
                })
            }), element.on("mousedown", function (event) {
                element.addClass(ACTIVE_CLASS_NAME)
            }), element.on("mousemove mouseup", function (event) {
                element.removeClass(ACTIVE_CLASS_NAME)
            })
        }
    }];
    makeSwipeDirective("ngSwipeLeft", -1, "swipeleft"), makeSwipeDirective("ngSwipeRight", 1, "swiperight")
}(window, window.angular), function (undefined) {
    function dfl(a, b, c) {
        switch (arguments.length) {
            case 2:
                return null != a ? a : b;
            case 3:
                return null != a ? a : null != b ? b : c;
            default:
                throw new Error("Implement me")
        }
    }

    function hasOwnProp(a, b) {
        return hasOwnProperty.call(a, b)
    }

    function defaultParsingFlags() {
        return {
            empty: !1,
            unusedTokens: [],
            unusedInput: [],
            overflow: -2,
            charsLeftOver: 0,
            nullInput: !1,
            invalidMonth: null,
            invalidFormat: !1,
            userInvalidated: !1,
            iso: !1
        }
    }

    function printMsg(msg) {
        moment.suppressDeprecationWarnings === !1 && "undefined" != typeof console && console.warn && console.warn("Deprecation warning: " + msg)
    }

    function deprecate(msg, fn) {
        var firstTime = !0;
        return extend(function () {
            return firstTime && (printMsg(msg), firstTime = !1), fn.apply(this, arguments)
        }, fn)
    }

    function deprecateSimple(name, msg) {
        deprecations[name] || (printMsg(msg), deprecations[name] = !0)
    }

    function padToken(func, count) {
        return function (a) {
            return leftZeroFill(func.call(this, a), count)
        }
    }

    function ordinalizeToken(func, period) {
        return function (a) {
            return this.localeData().ordinal(func.call(this, a), period)
        }
    }

    function monthDiff(a, b) {
        var anchor2, adjust, wholeMonthDiff = 12 * (b.year() - a.year()) + (b.month() - a.month()), anchor = a.clone().add(wholeMonthDiff, "months");
        return 0 > b - anchor ? (anchor2 = a.clone().add(wholeMonthDiff - 1, "months"), adjust = (b - anchor) / (anchor - anchor2)) : (anchor2 = a.clone().add(wholeMonthDiff + 1, "months"), adjust = (b - anchor) / (anchor2 - anchor)), -(wholeMonthDiff + adjust)
    }

    function meridiemFixWrap(locale, hour, meridiem) {
        var isPm;
        return null == meridiem ? hour : null != locale.meridiemHour ? locale.meridiemHour(hour, meridiem) : null != locale.isPM ? (isPm = locale.isPM(meridiem), isPm && 12 > hour && (hour += 12), isPm || 12 !== hour || (hour = 0), hour) : hour
    }

    function Locale() {
    }

    function Moment(config, skipOverflow) {
        skipOverflow !== !1 && checkOverflow(config), copyConfig(this, config), this._d = new Date(+config._d), updateInProgress === !1 && (updateInProgress = !0, moment.updateOffset(this), updateInProgress = !1)
    }

    function Duration(duration) {
        var normalizedInput = normalizeObjectUnits(duration), years = normalizedInput.year || 0, quarters = normalizedInput.quarter || 0, months = normalizedInput.month || 0, weeks = normalizedInput.week || 0, days = normalizedInput.day || 0, hours = normalizedInput.hour || 0, minutes = normalizedInput.minute || 0, seconds = normalizedInput.second || 0, milliseconds = normalizedInput.millisecond || 0;
        this._milliseconds = +milliseconds + 1e3 * seconds + 6e4 * minutes + 36e5 * hours, this._days = +days + 7 * weeks, this._months = +months + 3 * quarters + 12 * years, this._data = {}, this._locale = moment.localeData(), this._bubble()
    }

    function extend(a, b) {
        for (var i in b)hasOwnProp(b, i) && (a[i] = b[i]);
        return hasOwnProp(b, "toString") && (a.toString = b.toString), hasOwnProp(b, "valueOf") && (a.valueOf = b.valueOf), a
    }

    function copyConfig(to, from) {
        var i, prop, val;
        if ("undefined" != typeof from._isAMomentObject && (to._isAMomentObject = from._isAMomentObject), "undefined" != typeof from._i && (to._i = from._i), "undefined" != typeof from._f && (to._f = from._f), "undefined" != typeof from._l && (to._l = from._l), "undefined" != typeof from._strict && (to._strict = from._strict), "undefined" != typeof from._tzm && (to._tzm = from._tzm), "undefined" != typeof from._isUTC && (to._isUTC = from._isUTC), "undefined" != typeof from._offset && (to._offset = from._offset), "undefined" != typeof from._pf && (to._pf = from._pf), "undefined" != typeof from._locale && (to._locale = from._locale), momentProperties.length > 0)for (i in momentProperties)prop = momentProperties[i], val = from[prop], "undefined" != typeof val && (to[prop] = val);
        return to
    }

    function absRound(number) {
        return 0 > number ? Math.ceil(number) : Math.floor(number)
    }

    function leftZeroFill(number, targetLength, forceSign) {
        for (var output = "" + Math.abs(number), sign = number >= 0; output.length < targetLength;)output = "0" + output;
        return (sign ? forceSign ? "+" : "" : "-") + output
    }

    function positiveMomentsDifference(base, other) {
        var res = {milliseconds: 0, months: 0};
        return res.months = other.month() - base.month() + 12 * (other.year() - base.year()), base.clone().add(res.months, "M").isAfter(other) && --res.months, res.milliseconds = +other - +base.clone().add(res.months, "M"), res
    }

    function momentsDifference(base, other) {
        var res;
        return other = makeAs(other, base), base.isBefore(other) ? res = positiveMomentsDifference(base, other) : (res = positiveMomentsDifference(other, base), res.milliseconds = -res.milliseconds, res.months = -res.months), res
    }

    function createAdder(direction, name) {
        return function (val, period) {
            var dur, tmp;
            return null === period || isNaN(+period) || (deprecateSimple(name, "moment()." + name + "(period, number) is deprecated. Please use moment()." + name + "(number, period)."), tmp = val, val = period, period = tmp), val = "string" == typeof val ? +val : val, dur = moment.duration(val, period), addOrSubtractDurationFromMoment(this, dur, direction), this
        }
    }

    function addOrSubtractDurationFromMoment(mom, duration, isAdding, updateOffset) {
        var milliseconds = duration._milliseconds, days = duration._days, months = duration._months;
        updateOffset = null == updateOffset ? !0 : updateOffset, milliseconds && mom._d.setTime(+mom._d + milliseconds * isAdding), days && rawSetter(mom, "Date", rawGetter(mom, "Date") + days * isAdding), months && rawMonthSetter(mom, rawGetter(mom, "Month") + months * isAdding), updateOffset && moment.updateOffset(mom, days || months)
    }

    function isArray(input) {
        return "[object Array]" === Object.prototype.toString.call(input)
    }

    function isDate(input) {
        return "[object Date]" === Object.prototype.toString.call(input) || input instanceof Date
    }

    function compareArrays(array1, array2, dontConvert) {
        var i, len = Math.min(array1.length, array2.length), lengthDiff = Math.abs(array1.length - array2.length), diffs = 0;
        for (i = 0; len > i; i++)(dontConvert && array1[i] !== array2[i] || !dontConvert && toInt(array1[i]) !== toInt(array2[i])) && diffs++;
        return diffs + lengthDiff
    }

    function normalizeUnits(units) {
        if (units) {
            var lowered = units.toLowerCase().replace(/(.)s$/, "$1");
            units = unitAliases[units] || camelFunctions[lowered] || lowered
        }
        return units
    }

    function normalizeObjectUnits(inputObject) {
        var normalizedProp, prop, normalizedInput = {};
        for (prop in inputObject)hasOwnProp(inputObject, prop) && (normalizedProp = normalizeUnits(prop), normalizedProp && (normalizedInput[normalizedProp] = inputObject[prop]));
        return normalizedInput
    }

    function makeList(field) {
        var count, setter;
        if (0 === field.indexOf("week")) count = 7, setter = "day"; else {
            if (0 !== field.indexOf("month"))return;
            count = 12, setter = "month"
        }
        moment[field] = function (format, index) {
            var i, getter, method = moment._locale[field], results = [];
            if ("number" == typeof format && (index = format, format = undefined), getter = function (i) {
                    var m = moment().utc().set(setter, i);
                    return method.call(moment._locale, m, format || "")
                }, null != index)return getter(index);
            for (i = 0; count > i; i++)results.push(getter(i));
            return results
        }
    }

    function toInt(argumentForCoercion) {
        var coercedNumber = +argumentForCoercion, value = 0;
        return 0 !== coercedNumber && isFinite(coercedNumber) && (value = coercedNumber >= 0 ? Math.floor(coercedNumber) : Math.ceil(coercedNumber)), value
    }

    function daysInMonth(year, month) {
        return new Date(Date.UTC(year, month + 1, 0)).getUTCDate()
    }

    function weeksInYear(year, dow, doy) {
        return weekOfYear(moment([year, 11, 31 + dow - doy]), dow, doy).week
    }

    function daysInYear(year) {
        return isLeapYear(year) ? 366 : 365
    }

    function isLeapYear(year) {
        return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0
    }

    function checkOverflow(m) {
        var overflow;
        m._a && -2 === m._pf.overflow && (overflow = m._a[MONTH] < 0 || m._a[MONTH] > 11 ? MONTH : m._a[DATE] < 1 || m._a[DATE] > daysInMonth(m._a[YEAR], m._a[MONTH]) ? DATE : m._a[HOUR] < 0 || m._a[HOUR] > 24 || 24 === m._a[HOUR] && (0 !== m._a[MINUTE] || 0 !== m._a[SECOND] || 0 !== m._a[MILLISECOND]) ? HOUR : m._a[MINUTE] < 0 || m._a[MINUTE] > 59 ? MINUTE : m._a[SECOND] < 0 || m._a[SECOND] > 59 ? SECOND : m._a[MILLISECOND] < 0 || m._a[MILLISECOND] > 999 ? MILLISECOND : -1, m._pf._overflowDayOfYear && (YEAR > overflow || overflow > DATE) && (overflow = DATE), m._pf.overflow = overflow)
    }

    function isValid(m) {
        return null == m._isValid && (m._isValid = !isNaN(m._d.getTime()) && m._pf.overflow < 0 && !m._pf.empty && !m._pf.invalidMonth && !m._pf.nullInput && !m._pf.invalidFormat && !m._pf.userInvalidated, m._strict && (m._isValid = m._isValid && 0 === m._pf.charsLeftOver && 0 === m._pf.unusedTokens.length && m._pf.bigHour === undefined)), m._isValid
    }

    function normalizeLocale(key) {
        return key ? key.toLowerCase().replace("_", "-") : key
    }

    function chooseLocale(names) {
        for (var j, next, locale, split, i = 0; i < names.length;) {
            for (split = normalizeLocale(names[i]).split("-"), j = split.length, next = normalizeLocale(names[i + 1]), next = next ? next.split("-") : null; j > 0;) {
                if (locale = loadLocale(split.slice(0, j).join("-")))return locale;
                if (next && next.length >= j && compareArrays(split, next, !0) >= j - 1)break;
                j--
            }
            i++
        }
        return null
    }

    function loadLocale(name) {
        var oldLocale = null;
        if (!locales[name] && hasModule)try {
            oldLocale = moment.locale(), require("./locale/" + name), moment.locale(oldLocale)
        } catch (e) {
        }
        return locales[name]
    }

    function makeAs(input, model) {
        var res, diff;
        return model._isUTC ? (res = model.clone(), diff = (moment.isMoment(input) || isDate(input) ? +input : +moment(input)) - +res, res._d.setTime(+res._d + diff), moment.updateOffset(res, !1), res) : moment(input).local()
    }

    function removeFormattingTokens(input) {
        return input.match(/\[[\s\S]/) ? input.replace(/^\[|\]$/g, "") : input.replace(/\\/g, "")
    }

    function makeFormatFunction(format) {
        var i, length, array = format.match(formattingTokens);
        for (i = 0, length = array.length; length > i; i++)formatTokenFunctions[array[i]] ? array[i] = formatTokenFunctions[array[i]] : array[i] = removeFormattingTokens(array[i]);
        return function (mom) {
            var output = "";
            for (i = 0; length > i; i++)output += array[i] instanceof Function ? array[i].call(mom, format) : array[i];
            return output
        }
    }

    function formatMoment(m, format) {
        return m.isValid() ? (format = expandFormat(format, m.localeData()), formatFunctions[format] || (formatFunctions[format] = makeFormatFunction(format)), formatFunctions[format](m)) : m.localeData().invalidDate()
    }

    function expandFormat(format, locale) {
        function replaceLongDateFormatTokens(input) {
            return locale.longDateFormat(input) || input
        }

        var i = 5;
        for (localFormattingTokens.lastIndex = 0; i >= 0 && localFormattingTokens.test(format);)format = format.replace(localFormattingTokens, replaceLongDateFormatTokens), localFormattingTokens.lastIndex = 0, i -= 1;
        return format
    }

    function getParseRegexForToken(token, config) {
        var a, strict = config._strict;
        switch (token) {
            case"Q":
                return parseTokenOneDigit;
            case"DDDD":
                return parseTokenThreeDigits;
            case"YYYY":
            case"GGGG":
            case"gggg":
                return strict ? parseTokenFourDigits : parseTokenOneToFourDigits;
            case"Y":
            case"G":
            case"g":
                return parseTokenSignedNumber;
            case"YYYYYY":
            case"YYYYY":
            case"GGGGG":
            case"ggggg":
                return strict ? parseTokenSixDigits : parseTokenOneToSixDigits;
            case"S":
                if (strict)return parseTokenOneDigit;
            case"SS":
                if (strict)return parseTokenTwoDigits;
            case"SSS":
                if (strict)return parseTokenThreeDigits;
            case"DDD":
                return parseTokenOneToThreeDigits;
            case"MMM":
            case"MMMM":
            case"dd":
            case"ddd":
            case"dddd":
                return parseTokenWord;
            case"a":
            case"A":
                return config._locale._meridiemParse;
            case"x":
                return parseTokenOffsetMs;
            case"X":
                return parseTokenTimestampMs;
            case"Z":
            case"ZZ":
                return parseTokenTimezone;
            case"T":
                return parseTokenT;
            case"SSSS":
                return parseTokenDigits;
            case"MM":
            case"DD":
            case"YY":
            case"GG":
            case"gg":
            case"HH":
            case"hh":
            case"mm":
            case"ss":
            case"ww":
            case"WW":
                return strict ? parseTokenTwoDigits : parseTokenOneOrTwoDigits;
            case"M":
            case"D":
            case"d":
            case"H":
            case"h":
            case"m":
            case"s":
            case"w":
            case"W":
            case"e":
            case"E":
                return parseTokenOneOrTwoDigits;
            case"Do":
                return strict ? config._locale._ordinalParse : config._locale._ordinalParseLenient;
            default:
                return a = new RegExp(regexpEscape(unescapeFormat(token.replace("\\", "")), "i"))
        }
    }

    function utcOffsetFromString(string) {
        string = string || "";
        var possibleTzMatches = string.match(parseTokenTimezone) || [], tzChunk = possibleTzMatches[possibleTzMatches.length - 1] || [], parts = (tzChunk + "").match(parseTimezoneChunker) || ["-", 0, 0], minutes = +(60 * parts[1]) + toInt(parts[2]);
        return "+" === parts[0] ? minutes : -minutes
    }

    function addTimeToArrayFromToken(token, input, config) {
        var a, datePartArray = config._a;
        switch (token) {
            case"Q":
                null != input && (datePartArray[MONTH] = 3 * (toInt(input) - 1));
                break;
            case"M":
            case"MM":
                null != input && (datePartArray[MONTH] = toInt(input) - 1);
                break;
            case"MMM":
            case"MMMM":
                a = config._locale.monthsParse(input, token, config._strict), null != a ? datePartArray[MONTH] = a : config._pf.invalidMonth = input;
                break;
            case"D":
            case"DD":
                null != input && (datePartArray[DATE] = toInt(input));
                break;
            case"Do":
                null != input && (datePartArray[DATE] = toInt(parseInt(input.match(/\d{1,2}/)[0], 10)));
                break;
            case"DDD":
            case"DDDD":
                null != input && (config._dayOfYear = toInt(input));
                break;
            case"YY":
                datePartArray[YEAR] = moment.parseTwoDigitYear(input);
                break;
            case"YYYY":
            case"YYYYY":
            case"YYYYYY":
                datePartArray[YEAR] = toInt(input);
                break;
            case"a":
            case"A":
                config._meridiem = input;
                break;
            case"h":
            case"hh":
                config._pf.bigHour = !0;
            case"H":
            case"HH":
                datePartArray[HOUR] = toInt(input);
                break;
            case"m":
            case"mm":
                datePartArray[MINUTE] = toInt(input);
                break;
            case"s":
            case"ss":
                datePartArray[SECOND] = toInt(input);
                break;
            case"S":
            case"SS":
            case"SSS":
            case"SSSS":
                datePartArray[MILLISECOND] = toInt(1e3 * ("0." + input));
                break;
            case"x":
                config._d = new Date(toInt(input));
                break;
            case"X":
                config._d = new Date(1e3 * parseFloat(input));
                break;
            case"Z":
            case"ZZ":
                config._useUTC = !0, config._tzm = utcOffsetFromString(input);
                break;
            case"dd":
            case"ddd":
            case"dddd":
                a = config._locale.weekdaysParse(input), null != a ? (config._w = config._w || {}, config._w.d = a) : config._pf.invalidWeekday = input;
                break;
            case"w":
            case"ww":
            case"W":
            case"WW":
            case"d":
            case"e":
            case"E":
                token = token.substr(0, 1);
            case"gggg":
            case"GGGG":
            case"GGGGG":
                token = token.substr(0, 2), input && (config._w = config._w || {}, config._w[token] = toInt(input));
                break;
            case"gg":
            case"GG":
                config._w = config._w || {}, config._w[token] = moment.parseTwoDigitYear(input)
        }
    }

    function dayOfYearFromWeekInfo(config) {
        var w, weekYear, week, weekday, dow, doy, temp;
        w = config._w, null != w.GG || null != w.W || null != w.E ? (dow = 1, doy = 4, weekYear = dfl(w.GG, config._a[YEAR], weekOfYear(moment(), 1, 4).year), week = dfl(w.W, 1), weekday = dfl(w.E, 1)) : (dow = config._locale._week.dow, doy = config._locale._week.doy, weekYear = dfl(w.gg, config._a[YEAR], weekOfYear(moment(), dow, doy).year), week = dfl(w.w, 1), null != w.d ? (weekday = w.d, dow > weekday && ++week) : weekday = null != w.e ? w.e + dow : dow), temp = dayOfYearFromWeeks(weekYear, week, weekday, doy, dow), config._a[YEAR] = temp.year, config._dayOfYear = temp.dayOfYear
    }

    function dateFromConfig(config) {
        var i, date, currentDate, yearToUse, input = [];
        if (!config._d) {
            for (currentDate = currentDateArray(config), config._w && null == config._a[DATE] && null == config._a[MONTH] && dayOfYearFromWeekInfo(config), config._dayOfYear && (yearToUse = dfl(config._a[YEAR], currentDate[YEAR]), config._dayOfYear > daysInYear(yearToUse) && (config._pf._overflowDayOfYear = !0), date = makeUTCDate(yearToUse, 0, config._dayOfYear), config._a[MONTH] = date.getUTCMonth(), config._a[DATE] = date.getUTCDate()), i = 0; 3 > i && null == config._a[i]; ++i)config._a[i] = input[i] = currentDate[i];
            for (; 7 > i; i++)config._a[i] = input[i] = null == config._a[i] ? 2 === i ? 1 : 0 : config._a[i];
            24 === config._a[HOUR] && 0 === config._a[MINUTE] && 0 === config._a[SECOND] && 0 === config._a[MILLISECOND] && (config._nextDay = !0, config._a[HOUR] = 0), config._d = (config._useUTC ? makeUTCDate : makeDate).apply(null, input), null != config._tzm && config._d.setUTCMinutes(config._d.getUTCMinutes() - config._tzm), config._nextDay && (config._a[HOUR] = 24)
        }
    }

    function dateFromObject(config) {
        var normalizedInput;
        config._d || (normalizedInput = normalizeObjectUnits(config._i), config._a = [normalizedInput.year, normalizedInput.month, normalizedInput.day || normalizedInput.date, normalizedInput.hour, normalizedInput.minute, normalizedInput.second, normalizedInput.millisecond], dateFromConfig(config))
    }

    function currentDateArray(config) {
        var now = new Date;
        return config._useUTC ? [now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()] : [now.getFullYear(), now.getMonth(), now.getDate()]
    }

    function makeDateFromStringAndFormat(config) {
        if (config._f === moment.ISO_8601)return void parseISO(config);
        config._a = [], config._pf.empty = !0;
        var i, parsedInput, tokens, token, skipped, string = "" + config._i, stringLength = string.length, totalParsedInputLength = 0;
        for (tokens = expandFormat(config._f, config._locale).match(formattingTokens) || [], i = 0; i < tokens.length; i++)token = tokens[i], parsedInput = (string.match(getParseRegexForToken(token, config)) || [])[0], parsedInput && (skipped = string.substr(0, string.indexOf(parsedInput)), skipped.length > 0 && config._pf.unusedInput.push(skipped), string = string.slice(string.indexOf(parsedInput) + parsedInput.length), totalParsedInputLength += parsedInput.length), formatTokenFunctions[token] ? (parsedInput ? config._pf.empty = !1 : config._pf.unusedTokens.push(token), addTimeToArrayFromToken(token, parsedInput, config)) : config._strict && !parsedInput && config._pf.unusedTokens.push(token);
        config._pf.charsLeftOver = stringLength - totalParsedInputLength, string.length > 0 && config._pf.unusedInput.push(string), config._pf.bigHour === !0 && config._a[HOUR] <= 12 && (config._pf.bigHour = undefined), config._a[HOUR] = meridiemFixWrap(config._locale, config._a[HOUR], config._meridiem), dateFromConfig(config), checkOverflow(config)
    }

    function unescapeFormat(s) {
        return s.replace(/\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g, function (matched, p1, p2, p3, p4) {
            return p1 || p2 || p3 || p4
        })
    }

    function regexpEscape(s) {
        return s.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&")
    }

    function makeDateFromStringAndArray(config) {
        var tempConfig, bestMoment, scoreToBeat, i, currentScore;
        if (0 === config._f.length)return config._pf.invalidFormat = !0, void(config._d = new Date(NaN));
        for (i = 0; i < config._f.length; i++)currentScore = 0, tempConfig = copyConfig({}, config), null != config._useUTC && (tempConfig._useUTC = config._useUTC), tempConfig._pf = defaultParsingFlags(), tempConfig._f = config._f[i], makeDateFromStringAndFormat(tempConfig), isValid(tempConfig) && (currentScore += tempConfig._pf.charsLeftOver, currentScore += 10 * tempConfig._pf.unusedTokens.length, tempConfig._pf.score = currentScore, (null == scoreToBeat || scoreToBeat > currentScore) && (scoreToBeat = currentScore, bestMoment = tempConfig));
        extend(config, bestMoment || tempConfig)
    }

    function parseISO(config) {
        var i, l, string = config._i, match = isoRegex.exec(string);
        if (match) {
            for (config._pf.iso = !0, i = 0, l = isoDates.length; l > i; i++)if (isoDates[i][1].exec(string)) {
                config._f = isoDates[i][0] + (match[6] || " ");
                break
            }
            for (i = 0, l = isoTimes.length; l > i; i++)if (isoTimes[i][1].exec(string)) {
                config._f += isoTimes[i][0];
                break
            }
            string.match(parseTokenTimezone) && (config._f += "Z"), makeDateFromStringAndFormat(config)
        } else config._isValid = !1
    }

    function makeDateFromString(config) {
        parseISO(config), config._isValid === !1 && (delete config._isValid, moment.createFromInputFallback(config))
    }

    function map(arr, fn) {
        var i, res = [];
        for (i = 0; i < arr.length; ++i)res.push(fn(arr[i], i));
        return res
    }

    function makeDateFromInput(config) {
        var matched, input = config._i;
        input === undefined ? config._d = new Date : isDate(input) ? config._d = new Date(+input) : null !== (matched = aspNetJsonRegex.exec(input)) ? config._d = new Date(+matched[1]) : "string" == typeof input ? makeDateFromString(config) : isArray(input) ? (config._a = map(input.slice(0), function (obj) {
                                return parseInt(obj, 10)
                            }), dateFromConfig(config)) : "object" == typeof input ? dateFromObject(config) : "number" == typeof input ? config._d = new Date(input) : moment.createFromInputFallback(config)
    }

    function makeDate(y, m, d, h, M, s, ms) {
        var date = new Date(y, m, d, h, M, s, ms);
        return 1970 > y && date.setFullYear(y), date
    }

    function makeUTCDate(y) {
        var date = new Date(Date.UTC.apply(null, arguments));
        return 1970 > y && date.setUTCFullYear(y), date
    }

    function parseWeekday(input, locale) {
        if ("string" == typeof input)if (isNaN(input)) {
            if (input = locale.weekdaysParse(input), "number" != typeof input)return null
        } else input = parseInt(input, 10);
        return input
    }

    function substituteTimeAgo(string, number, withoutSuffix, isFuture, locale) {
        return locale.relativeTime(number || 1, !!withoutSuffix, string, isFuture)
    }

    function relativeTime(posNegDuration, withoutSuffix, locale) {
        var duration = moment.duration(posNegDuration).abs(), seconds = round(duration.as("s")), minutes = round(duration.as("m")), hours = round(duration.as("h")), days = round(duration.as("d")), months = round(duration.as("M")), years = round(duration.as("y")), args = seconds < relativeTimeThresholds.s && ["s", seconds] || 1 === minutes && ["m"] || minutes < relativeTimeThresholds.m && ["mm", minutes] || 1 === hours && ["h"] || hours < relativeTimeThresholds.h && ["hh", hours] || 1 === days && ["d"] || days < relativeTimeThresholds.d && ["dd", days] || 1 === months && ["M"] || months < relativeTimeThresholds.M && ["MM", months] || 1 === years && ["y"] || ["yy", years];
        return args[2] = withoutSuffix, args[3] = +posNegDuration > 0, args[4] = locale, substituteTimeAgo.apply({}, args)
    }

    function weekOfYear(mom, firstDayOfWeek, firstDayOfWeekOfYear) {
        var adjustedMoment, end = firstDayOfWeekOfYear - firstDayOfWeek, daysToDayOfWeek = firstDayOfWeekOfYear - mom.day();
        return daysToDayOfWeek > end && (daysToDayOfWeek -= 7), end - 7 > daysToDayOfWeek && (daysToDayOfWeek += 7), adjustedMoment = moment(mom).add(daysToDayOfWeek, "d"), {
            week: Math.ceil(adjustedMoment.dayOfYear() / 7),
            year: adjustedMoment.year()
        }
    }

    function dayOfYearFromWeeks(year, week, weekday, firstDayOfWeekOfYear, firstDayOfWeek) {
        var daysToAdd, dayOfYear, d = makeUTCDate(year, 0, 1).getUTCDay();
        return d = 0 === d ? 7 : d, weekday = null != weekday ? weekday : firstDayOfWeek, daysToAdd = firstDayOfWeek - d + (d > firstDayOfWeekOfYear ? 7 : 0) - (firstDayOfWeek > d ? 7 : 0), dayOfYear = 7 * (week - 1) + (weekday - firstDayOfWeek) + daysToAdd + 1, {
            year: dayOfYear > 0 ? year : year - 1,
            dayOfYear: dayOfYear > 0 ? dayOfYear : daysInYear(year - 1) + dayOfYear
        }
    }

    function makeMoment(config) {
        var res, input = config._i, format = config._f;
        return config._locale = config._locale || moment.localeData(config._l), null === input || format === undefined && "" === input ? moment.invalid({nullInput: !0}) : ("string" == typeof input && (config._i = input = config._locale.preparse(input)), moment.isMoment(input) ? new Moment(input, !0) : (format ? isArray(format) ? makeDateFromStringAndArray(config) : makeDateFromStringAndFormat(config) : makeDateFromInput(config), res = new Moment(config), res._nextDay && (res.add(1, "d"), res._nextDay = undefined), res))
    }

    function pickBy(fn, moments) {
        var res, i;
        if (1 === moments.length && isArray(moments[0]) && (moments = moments[0]), !moments.length)return moment();
        for (res = moments[0], i = 1; i < moments.length; ++i)moments[i][fn](res) && (res = moments[i]);
        return res
    }

    function rawMonthSetter(mom, value) {
        var dayOfMonth;
        return "string" == typeof value && (value = mom.localeData().monthsParse(value), "number" != typeof value) ? mom : (dayOfMonth = Math.min(mom.date(), daysInMonth(mom.year(), value)), mom._d["set" + (mom._isUTC ? "UTC" : "") + "Month"](value, dayOfMonth), mom)
    }

    function rawGetter(mom, unit) {
        return mom._d["get" + (mom._isUTC ? "UTC" : "") + unit]()
    }

    function rawSetter(mom, unit, value) {
        return "Month" === unit ? rawMonthSetter(mom, value) : mom._d["set" + (mom._isUTC ? "UTC" : "") + unit](value)
    }

    function makeAccessor(unit, keepTime) {
        return function (value) {
            return null != value ? (rawSetter(this, unit, value), moment.updateOffset(this, keepTime), this) : rawGetter(this, unit)
        }
    }

    function daysToYears(days) {
        return 400 * days / 146097
    }

    function yearsToDays(years) {
        return 146097 * years / 400
    }

    function makeDurationGetter(name) {
        moment.duration.fn[name] = function () {
            return this._data[name]
        }
    }

    function makeGlobal(shouldDeprecate) {
        "undefined" == typeof ender && (oldGlobalMoment = globalScope.moment, shouldDeprecate ? globalScope.moment = deprecate("Accessing Moment through the global scope is deprecated, and will be removed in an upcoming release.", moment) : globalScope.moment = moment)
    }

    for (var moment, oldGlobalMoment, i, VERSION = "2.9.0", globalScope = "undefined" == typeof global || "undefined" != typeof window && window !== global.window ? this : global, round = Math.round, hasOwnProperty = Object.prototype.hasOwnProperty, YEAR = 0, MONTH = 1, DATE = 2, HOUR = 3, MINUTE = 4, SECOND = 5, MILLISECOND = 6, locales = {}, momentProperties = [], hasModule = "undefined" != typeof module && module && module.exports, aspNetJsonRegex = /^\/?Date\((\-?\d+)/i, aspNetTimeSpanJsonRegex = /(\-)?(?:(\d*)\.)?(\d+)\:(\d+)(?:\:(\d+)\.?(\d{3})?)?/, isoDurationRegex = /^(-)?P(?:(?:([0-9,.]*)Y)?(?:([0-9,.]*)M)?(?:([0-9,.]*)D)?(?:T(?:([0-9,.]*)H)?(?:([0-9,.]*)M)?(?:([0-9,.]*)S)?)?|([0-9,.]*)W)$/, formattingTokens = /(\[[^\[]*\])|(\\)?(Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Q|YYYYYY|YYYYY|YYYY|YY|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|mm?|ss?|S{1,4}|x|X|zz?|ZZ?|.)/g, localFormattingTokens = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, parseTokenOneOrTwoDigits = /\d\d?/, parseTokenOneToThreeDigits = /\d{1,3}/, parseTokenOneToFourDigits = /\d{1,4}/, parseTokenOneToSixDigits = /[+\-]?\d{1,6}/, parseTokenDigits = /\d+/, parseTokenWord = /[0-9]*['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFFEF]+|[\u0600-\u06FF\/]+(\s*?[\u0600-\u06FF]+){1,2}/i, parseTokenTimezone = /Z|[\+\-]\d\d:?\d\d/gi, parseTokenT = /T/i, parseTokenOffsetMs = /[\+\-]?\d+/, parseTokenTimestampMs = /[\+\-]?\d+(\.\d{1,3})?/, parseTokenOneDigit = /\d/, parseTokenTwoDigits = /\d\d/, parseTokenThreeDigits = /\d{3}/, parseTokenFourDigits = /\d{4}/, parseTokenSixDigits = /[+-]?\d{6}/, parseTokenSignedNumber = /[+-]?\d+/, isoRegex = /^\s*(?:[+-]\d{6}|\d{4})-(?:(\d\d-\d\d)|(W\d\d$)|(W\d\d-\d)|(\d\d\d))((T| )(\d\d(:\d\d(:\d\d(\.\d+)?)?)?)?([\+\-]\d\d(?::?\d\d)?|\s*Z)?)?$/, isoFormat = "YYYY-MM-DDTHH:mm:ssZ", isoDates = [["YYYYYY-MM-DD", /[+-]\d{6}-\d{2}-\d{2}/], ["YYYY-MM-DD", /\d{4}-\d{2}-\d{2}/], ["GGGG-[W]WW-E", /\d{4}-W\d{2}-\d/], ["GGGG-[W]WW", /\d{4}-W\d{2}/], ["YYYY-DDD", /\d{4}-\d{3}/]], isoTimes = [["HH:mm:ss.SSSS", /(T| )\d\d:\d\d:\d\d\.\d+/], ["HH:mm:ss", /(T| )\d\d:\d\d:\d\d/], ["HH:mm", /(T| )\d\d:\d\d/], ["HH", /(T| )\d\d/]], parseTimezoneChunker = /([\+\-]|\d\d)/gi, unitMillisecondFactors = ("Date|Hours|Minutes|Seconds|Milliseconds".split("|"), {
        Milliseconds: 1,
        Seconds: 1e3,
        Minutes: 6e4,
        Hours: 36e5,
        Days: 864e5,
        Months: 2592e6,
        Years: 31536e6
    }), unitAliases = {
        ms: "millisecond",
        s: "second",
        m: "minute",
        h: "hour",
        d: "day",
        D: "date",
        w: "week",
        W: "isoWeek",
        M: "month",
        Q: "quarter",
        y: "year",
        DDD: "dayOfYear",
        e: "weekday",
        E: "isoWeekday",
        gg: "weekYear",
        GG: "isoWeekYear"
    }, camelFunctions = {
        dayofyear: "dayOfYear",
        isoweekday: "isoWeekday",
        isoweek: "isoWeek",
        weekyear: "weekYear",
        isoweekyear: "isoWeekYear"
    }, formatFunctions = {}, relativeTimeThresholds = {
        s: 45,
        m: 45,
        h: 22,
        d: 26,
        M: 11
    }, ordinalizeTokens = "DDD w W M D d".split(" "), paddedTokens = "M D H h m s w W".split(" "), formatTokenFunctions = {
        M: function () {
            return this.month() + 1
        }, MMM: function (format) {
            return this.localeData().monthsShort(this, format)
        }, MMMM: function (format) {
            return this.localeData().months(this, format)
        }, D: function () {
            return this.date()
        }, DDD: function () {
            return this.dayOfYear()
        }, d: function () {
            return this.day()
        }, dd: function (format) {
            return this.localeData().weekdaysMin(this, format)
        }, ddd: function (format) {
            return this.localeData().weekdaysShort(this, format)
        }, dddd: function (format) {
            return this.localeData().weekdays(this, format)
        }, w: function () {
            return this.week()
        }, W: function () {
            return this.isoWeek()
        }, YY: function () {
            return leftZeroFill(this.year() % 100, 2)
        }, YYYY: function () {
            return leftZeroFill(this.year(), 4)
        }, YYYYY: function () {
            return leftZeroFill(this.year(), 5)
        }, YYYYYY: function () {
            var y = this.year(), sign = y >= 0 ? "+" : "-";
            return sign + leftZeroFill(Math.abs(y), 6)
        }, gg: function () {
            return leftZeroFill(this.weekYear() % 100, 2)
        }, gggg: function () {
            return leftZeroFill(this.weekYear(), 4)
        }, ggggg: function () {
            return leftZeroFill(this.weekYear(), 5)
        }, GG: function () {
            return leftZeroFill(this.isoWeekYear() % 100, 2)
        }, GGGG: function () {
            return leftZeroFill(this.isoWeekYear(), 4)
        }, GGGGG: function () {
            return leftZeroFill(this.isoWeekYear(), 5)
        }, e: function () {
            return this.weekday()
        }, E: function () {
            return this.isoWeekday()
        }, a: function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), !0)
        }, A: function () {
            return this.localeData().meridiem(this.hours(), this.minutes(), !1)
        }, H: function () {
            return this.hours()
        }, h: function () {
            return this.hours() % 12 || 12
        }, m: function () {
            return this.minutes()
        }, s: function () {
            return this.seconds()
        }, S: function () {
            return toInt(this.milliseconds() / 100)
        }, SS: function () {
            return leftZeroFill(toInt(this.milliseconds() / 10), 2)
        }, SSS: function () {
            return leftZeroFill(this.milliseconds(), 3)
        }, SSSS: function () {
            return leftZeroFill(this.milliseconds(), 3)
        }, Z: function () {
            var a = this.utcOffset(), b = "+";
            return 0 > a && (a = -a, b = "-"), b + leftZeroFill(toInt(a / 60), 2) + ":" + leftZeroFill(toInt(a) % 60, 2)
        }, ZZ: function () {
            var a = this.utcOffset(), b = "+";
            return 0 > a && (a = -a, b = "-"), b + leftZeroFill(toInt(a / 60), 2) + leftZeroFill(toInt(a) % 60, 2)
        }, z: function () {
            return this.zoneAbbr()
        }, zz: function () {
            return this.zoneName()
        }, x: function () {
            return this.valueOf()
        }, X: function () {
            return this.unix()
        }, Q: function () {
            return this.quarter()
        }
    }, deprecations = {}, lists = ["months", "monthsShort", "weekdays", "weekdaysShort", "weekdaysMin"], updateInProgress = !1; ordinalizeTokens.length;)i = ordinalizeTokens.pop(), formatTokenFunctions[i + "o"] = ordinalizeToken(formatTokenFunctions[i], i);
    for (; paddedTokens.length;)i = paddedTokens.pop(), formatTokenFunctions[i + i] = padToken(formatTokenFunctions[i], 2);
    formatTokenFunctions.DDDD = padToken(formatTokenFunctions.DDD, 3), extend(Locale.prototype, {
        set: function (config) {
            var prop, i;
            for (i in config)prop = config[i], "function" == typeof prop ? this[i] = prop : this["_" + i] = prop;
            this._ordinalParseLenient = new RegExp(this._ordinalParse.source + "|" + /\d{1,2}/.source)
        },
        _months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"),
        months: function (m) {
            return this._months[m.month()]
        },
        _monthsShort: "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"),
        monthsShort: function (m) {
            return this._monthsShort[m.month()]
        },
        monthsParse: function (monthName, format, strict) {
            var i, mom, regex;
            for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), i = 0; 12 > i; i++) {
                if (mom = moment.utc([2e3, i]), strict && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp("^" + this.months(mom, "").replace(".", "") + "$", "i"), this._shortMonthsParse[i] = new RegExp("^" + this.monthsShort(mom, "").replace(".", "") + "$", "i")), strict || this._monthsParse[i] || (regex = "^" + this.months(mom, "") + "|^" + this.monthsShort(mom, ""), this._monthsParse[i] = new RegExp(regex.replace(".", ""), "i")), strict && "MMMM" === format && this._longMonthsParse[i].test(monthName))return i;
                if (strict && "MMM" === format && this._shortMonthsParse[i].test(monthName))return i;
                if (!strict && this._monthsParse[i].test(monthName))return i
            }
        },
        _weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"),
        weekdays: function (m) {
            return this._weekdays[m.day()]
        },
        _weekdaysShort: "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"),
        weekdaysShort: function (m) {
            return this._weekdaysShort[m.day()]
        },
        _weekdaysMin: "Su_Mo_Tu_We_Th_Fr_Sa".split("_"),
        weekdaysMin: function (m) {
            return this._weekdaysMin[m.day()]
        },
        weekdaysParse: function (weekdayName) {
            var i, mom, regex;
            for (this._weekdaysParse || (this._weekdaysParse = []), i = 0; 7 > i; i++)if (this._weekdaysParse[i] || (mom = moment([2e3, 1]).day(i), regex = "^" + this.weekdays(mom, "") + "|^" + this.weekdaysShort(mom, "") + "|^" + this.weekdaysMin(mom, ""), this._weekdaysParse[i] = new RegExp(regex.replace(".", ""), "i")), this._weekdaysParse[i].test(weekdayName))return i
        },
        _longDateFormat: {
            LTS: "h:mm:ss A",
            LT: "h:mm A",
            L: "MM/DD/YYYY",
            LL: "MMMM D, YYYY",
            LLL: "MMMM D, YYYY LT",
            LLLL: "dddd, MMMM D, YYYY LT"
        },
        longDateFormat: function (key) {
            var output = this._longDateFormat[key];
            return !output && this._longDateFormat[key.toUpperCase()] && (output = this._longDateFormat[key.toUpperCase()].replace(/MMMM|MM|DD|dddd/g, function (val) {
                return val.slice(1)
            }), this._longDateFormat[key] = output), output
        },
        isPM: function (input) {
            return "p" === (input + "").toLowerCase().charAt(0)
        },
        _meridiemParse: /[ap]\.?m?\.?/i,
        meridiem: function (hours, minutes, isLower) {
            return hours > 11 ? isLower ? "pm" : "PM" : isLower ? "am" : "AM"
        },
        _calendar: {
            sameDay: "[Today at] LT",
            nextDay: "[Tomorrow at] LT",
            nextWeek: "dddd [at] LT",
            lastDay: "[Yesterday at] LT",
            lastWeek: "[Last] dddd [at] LT",
            sameElse: "L"
        },
        calendar: function (key, mom, now) {
            var output = this._calendar[key];
            return "function" == typeof output ? output.apply(mom, [now]) : output
        },
        _relativeTime: {
            future: "in %s",
            past: "%s ago",
            s: "a few seconds",
            m: "a minute",
            mm: "%d minutes",
            h: "an hour",
            hh: "%d hours",
            d: "a day",
            dd: "%d days",
            M: "a month",
            MM: "%d months",
            y: "a year",
            yy: "%d years"
        },
        relativeTime: function (number, withoutSuffix, string, isFuture) {
            var output = this._relativeTime[string];
            return "function" == typeof output ? output(number, withoutSuffix, string, isFuture) : output.replace(/%d/i, number)
        },
        pastFuture: function (diff, output) {
            var format = this._relativeTime[diff > 0 ? "future" : "past"];
            return "function" == typeof format ? format(output) : format.replace(/%s/i, output)
        },
        ordinal: function (number) {
            return this._ordinal.replace("%d", number)
        },
        _ordinal: "%d",
        _ordinalParse: /\d{1,2}/,
        preparse: function (string) {
            return string
        },
        postformat: function (string) {
            return string
        },
        week: function (mom) {
            return weekOfYear(mom, this._week.dow, this._week.doy).week
        },
        _week: {dow: 0, doy: 6},
        firstDayOfWeek: function () {
            return this._week.dow
        },
        firstDayOfYear: function () {
            return this._week.doy
        },
        _invalidDate: "Invalid date",
        invalidDate: function () {
            return this._invalidDate
        }
    }), moment = function (input, format, locale, strict) {
        var c;
        return "boolean" == typeof locale && (strict = locale, locale = undefined), c = {}, c._isAMomentObject = !0, c._i = input, c._f = format, c._l = locale, c._strict = strict, c._isUTC = !1, c._pf = defaultParsingFlags(), makeMoment(c)
    }, moment.suppressDeprecationWarnings = !1, moment.createFromInputFallback = deprecate("moment construction falls back to js Date. This is discouraged and will be removed in upcoming major release. Please refer to https://github.com/moment/moment/issues/1407 for more info.", function (config) {
        config._d = new Date(config._i + (config._useUTC ? " UTC" : ""))
    }), moment.min = function () {
        var args = [].slice.call(arguments, 0);
        return pickBy("isBefore", args)
    }, moment.max = function () {
        var args = [].slice.call(arguments, 0);
        return pickBy("isAfter", args)
    }, moment.utc = function (input, format, locale, strict) {
        var c;
        return "boolean" == typeof locale && (strict = locale, locale = undefined), c = {}, c._isAMomentObject = !0, c._useUTC = !0, c._isUTC = !0, c._l = locale, c._i = input, c._f = format, c._strict = strict, c._pf = defaultParsingFlags(), makeMoment(c).utc()
    }, moment.unix = function (input) {
        return moment(1e3 * input)
    }, moment.duration = function (input, key) {
        var sign, ret, parseIso, diffRes, duration = input, match = null;
        return moment.isDuration(input) ? duration = {
                ms: input._milliseconds,
                d: input._days,
                M: input._months
            } : "number" == typeof input ? (duration = {}, key ? duration[key] = input : duration.milliseconds = input) : (match = aspNetTimeSpanJsonRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, duration = {
                        y: 0,
                        d: toInt(match[DATE]) * sign,
                        h: toInt(match[HOUR]) * sign,
                        m: toInt(match[MINUTE]) * sign,
                        s: toInt(match[SECOND]) * sign,
                        ms: toInt(match[MILLISECOND]) * sign
                    }) : (match = isoDurationRegex.exec(input)) ? (sign = "-" === match[1] ? -1 : 1, parseIso = function (inp) {
                            var res = inp && parseFloat(inp.replace(",", "."));
                            return (isNaN(res) ? 0 : res) * sign
                        }, duration = {
                            y: parseIso(match[2]),
                            M: parseIso(match[3]),
                            d: parseIso(match[4]),
                            h: parseIso(match[5]),
                            m: parseIso(match[6]),
                            s: parseIso(match[7]),
                            w: parseIso(match[8])
                        }) : null == duration ? duration = {} : "object" == typeof duration && ("from" in duration || "to" in duration) && (diffRes = momentsDifference(moment(duration.from), moment(duration.to)), duration = {}, duration.ms = diffRes.milliseconds, duration.M = diffRes.months), ret = new Duration(duration), moment.isDuration(input) && hasOwnProp(input, "_locale") && (ret._locale = input._locale), ret
    }, moment.version = VERSION, moment.defaultFormat = isoFormat, moment.ISO_8601 = function () {
    }, moment.momentProperties = momentProperties, moment.updateOffset = function () {
    }, moment.relativeTimeThreshold = function (threshold, limit) {
        return relativeTimeThresholds[threshold] === undefined ? !1 : limit === undefined ? relativeTimeThresholds[threshold] : (relativeTimeThresholds[threshold] = limit, !0)
    }, moment.lang = deprecate("moment.lang is deprecated. Use moment.locale instead.", function (key, value) {
        return moment.locale(key, value)
    }), moment.locale = function (key, values) {
        var data;
        return key && (data = "undefined" != typeof values ? moment.defineLocale(key, values) : moment.localeData(key), data && (moment.duration._locale = moment._locale = data)), moment._locale._abbr
    }, moment.defineLocale = function (name, values) {
        return null !== values ? (values.abbr = name, locales[name] || (locales[name] = new Locale), locales[name].set(values), moment.locale(name), locales[name]) : (delete locales[name], null)
    }, moment.langData = deprecate("moment.langData is deprecated. Use moment.localeData instead.", function (key) {
        return moment.localeData(key)
    }), moment.localeData = function (key) {
        var locale;
        if (key && key._locale && key._locale._abbr && (key = key._locale._abbr), !key)return moment._locale;
        if (!isArray(key)) {
            if (locale = loadLocale(key))return locale;
            key = [key]
        }
        return chooseLocale(key)
    }, moment.isMoment = function (obj) {
        return obj instanceof Moment || null != obj && hasOwnProp(obj, "_isAMomentObject")
    }, moment.isDuration = function (obj) {
        return obj instanceof Duration
    };
    for (i = lists.length - 1; i >= 0; --i)makeList(lists[i]);
    moment.normalizeUnits = function (units) {
        return normalizeUnits(units)
    }, moment.invalid = function (flags) {
        var m = moment.utc(NaN);
        return null != flags ? extend(m._pf, flags) : m._pf.userInvalidated = !0, m
    }, moment.parseZone = function () {
        return moment.apply(null, arguments).parseZone()
    }, moment.parseTwoDigitYear = function (input) {
        return toInt(input) + (toInt(input) > 68 ? 1900 : 2e3)
    }, moment.isDate = isDate, extend(moment.fn = Moment.prototype, {
        clone: function () {
            return moment(this)
        },
        valueOf: function () {
            return +this._d - 6e4 * (this._offset || 0)
        },
        unix: function () {
            return Math.floor(+this / 1e3)
        },
        toString: function () {
            return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ")
        },
        toDate: function () {
            return this._offset ? new Date(+this) : this._d
        },
        toISOString: function () {
            var m = moment(this).utc();
            return 0 < m.year() && m.year() <= 9999 ? "function" == typeof Date.prototype.toISOString ? this.toDate().toISOString() : formatMoment(m, "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]") : formatMoment(m, "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]")
        },
        toArray: function () {
            var m = this;
            return [m.year(), m.month(), m.date(), m.hours(), m.minutes(), m.seconds(), m.milliseconds()]
        },
        isValid: function () {
            return isValid(this)
        },
        isDSTShifted: function () {
            return this._a ? this.isValid() && compareArrays(this._a, (this._isUTC ? moment.utc(this._a) : moment(this._a)).toArray()) > 0 : !1
        },
        parsingFlags: function () {
            return extend({}, this._pf)
        },
        invalidAt: function () {
            return this._pf.overflow
        },
        utc: function (keepLocalTime) {
            return this.utcOffset(0, keepLocalTime)
        },
        local: function (keepLocalTime) {
            return this._isUTC && (this.utcOffset(0, keepLocalTime), this._isUTC = !1, keepLocalTime && this.subtract(this._dateUtcOffset(), "m")), this
        },
        format: function (inputString) {
            var output = formatMoment(this, inputString || moment.defaultFormat);
            return this.localeData().postformat(output)
        },
        add: createAdder(1, "add"),
        subtract: createAdder(-1, "subtract"),
        diff: function (input, units, asFloat) {
            var diff, output, that = makeAs(input, this), zoneDiff = 6e4 * (that.utcOffset() - this.utcOffset());
            return units = normalizeUnits(units), "year" === units || "month" === units || "quarter" === units ? (output = monthDiff(this, that), "quarter" === units ? output /= 3 : "year" === units && (output /= 12)) : (diff = this - that, output = "second" === units ? diff / 1e3 : "minute" === units ? diff / 6e4 : "hour" === units ? diff / 36e5 : "day" === units ? (diff - zoneDiff) / 864e5 : "week" === units ? (diff - zoneDiff) / 6048e5 : diff), asFloat ? output : absRound(output)
        },
        from: function (time, withoutSuffix) {
            return moment.duration({to: this, from: time}).locale(this.locale()).humanize(!withoutSuffix)
        },
        fromNow: function (withoutSuffix) {
            return this.from(moment(), withoutSuffix)
        },
        calendar: function (time) {
            var now = time || moment(), sod = makeAs(now, this).startOf("day"), diff = this.diff(sod, "days", !0), format = -6 > diff ? "sameElse" : -1 > diff ? "lastWeek" : 0 > diff ? "lastDay" : 1 > diff ? "sameDay" : 2 > diff ? "nextDay" : 7 > diff ? "nextWeek" : "sameElse";
            return this.format(this.localeData().calendar(format, this, moment(now)))
        },
        isLeapYear: function () {
            return isLeapYear(this.year())
        },
        isDST: function () {
            return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset()
        },
        day: function (input) {
            var day = this._isUTC ? this._d.getUTCDay() : this._d.getDay();
            return null != input ? (input = parseWeekday(input, this.localeData()), this.add(input - day, "d")) : day
        },
        month: makeAccessor("Month", !0),
        startOf: function (units) {
            switch (units = normalizeUnits(units)) {
                case"year":
                    this.month(0);
                case"quarter":
                case"month":
                    this.date(1);
                case"week":
                case"isoWeek":
                case"day":
                    this.hours(0);
                case"hour":
                    this.minutes(0);
                case"minute":
                    this.seconds(0);
                case"second":
                    this.milliseconds(0)
            }
            return "week" === units ? this.weekday(0) : "isoWeek" === units && this.isoWeekday(1), "quarter" === units && this.month(3 * Math.floor(this.month() / 3)), this
        },
        endOf: function (units) {
            return units = normalizeUnits(units), units === undefined || "millisecond" === units ? this : this.startOf(units).add(1, "isoWeek" === units ? "week" : units).subtract(1, "ms")
        },
        isAfter: function (input, units) {
            var inputMs;
            return units = normalizeUnits("undefined" != typeof units ? units : "millisecond"), "millisecond" === units ? (input = moment.isMoment(input) ? input : moment(input), +this > +input) : (inputMs = moment.isMoment(input) ? +input : +moment(input), inputMs < +this.clone().startOf(units))
        },
        isBefore: function (input, units) {
            var inputMs;
            return units = normalizeUnits("undefined" != typeof units ? units : "millisecond"), "millisecond" === units ? (input = moment.isMoment(input) ? input : moment(input),
                +input > +this) : (inputMs = moment.isMoment(input) ? +input : +moment(input), +this.clone().endOf(units) < inputMs)
        },
        isBetween: function (from, to, units) {
            return this.isAfter(from, units) && this.isBefore(to, units)
        },
        isSame: function (input, units) {
            var inputMs;
            return units = normalizeUnits(units || "millisecond"), "millisecond" === units ? (input = moment.isMoment(input) ? input : moment(input), +this === +input) : (inputMs = +moment(input), +this.clone().startOf(units) <= inputMs && inputMs <= +this.clone().endOf(units))
        },
        min: deprecate("moment().min is deprecated, use moment.min instead. https://github.com/moment/moment/issues/1548", function (other) {
            return other = moment.apply(null, arguments), this > other ? this : other
        }),
        max: deprecate("moment().max is deprecated, use moment.max instead. https://github.com/moment/moment/issues/1548", function (other) {
            return other = moment.apply(null, arguments), other > this ? this : other
        }),
        zone: deprecate("moment().zone is deprecated, use moment().utcOffset instead. https://github.com/moment/moment/issues/1779", function (input, keepLocalTime) {
            return null != input ? ("string" != typeof input && (input = -input), this.utcOffset(input, keepLocalTime), this) : -this.utcOffset()
        }),
        utcOffset: function (input, keepLocalTime) {
            var localAdjust, offset = this._offset || 0;
            return null != input ? ("string" == typeof input && (input = utcOffsetFromString(input)), Math.abs(input) < 16 && (input = 60 * input), !this._isUTC && keepLocalTime && (localAdjust = this._dateUtcOffset()), this._offset = input, this._isUTC = !0, null != localAdjust && this.add(localAdjust, "m"), offset !== input && (!keepLocalTime || this._changeInProgress ? addOrSubtractDurationFromMoment(this, moment.duration(input - offset, "m"), 1, !1) : this._changeInProgress || (this._changeInProgress = !0, moment.updateOffset(this, !0), this._changeInProgress = null)), this) : this._isUTC ? offset : this._dateUtcOffset()
        },
        isLocal: function () {
            return !this._isUTC
        },
        isUtcOffset: function () {
            return this._isUTC
        },
        isUtc: function () {
            return this._isUTC && 0 === this._offset
        },
        zoneAbbr: function () {
            return this._isUTC ? "UTC" : ""
        },
        zoneName: function () {
            return this._isUTC ? "Coordinated Universal Time" : ""
        },
        parseZone: function () {
            return this._tzm ? this.utcOffset(this._tzm) : "string" == typeof this._i && this.utcOffset(utcOffsetFromString(this._i)), this
        },
        hasAlignedHourOffset: function (input) {
            return input = input ? moment(input).utcOffset() : 0, (this.utcOffset() - input) % 60 === 0
        },
        daysInMonth: function () {
            return daysInMonth(this.year(), this.month())
        },
        dayOfYear: function (input) {
            var dayOfYear = round((moment(this).startOf("day") - moment(this).startOf("year")) / 864e5) + 1;
            return null == input ? dayOfYear : this.add(input - dayOfYear, "d")
        },
        quarter: function (input) {
            return null == input ? Math.ceil((this.month() + 1) / 3) : this.month(3 * (input - 1) + this.month() % 3)
        },
        weekYear: function (input) {
            var year = weekOfYear(this, this.localeData()._week.dow, this.localeData()._week.doy).year;
            return null == input ? year : this.add(input - year, "y")
        },
        isoWeekYear: function (input) {
            var year = weekOfYear(this, 1, 4).year;
            return null == input ? year : this.add(input - year, "y")
        },
        week: function (input) {
            var week = this.localeData().week(this);
            return null == input ? week : this.add(7 * (input - week), "d")
        },
        isoWeek: function (input) {
            var week = weekOfYear(this, 1, 4).week;
            return null == input ? week : this.add(7 * (input - week), "d")
        },
        weekday: function (input) {
            var weekday = (this.day() + 7 - this.localeData()._week.dow) % 7;
            return null == input ? weekday : this.add(input - weekday, "d")
        },
        isoWeekday: function (input) {
            return null == input ? this.day() || 7 : this.day(this.day() % 7 ? input : input - 7)
        },
        isoWeeksInYear: function () {
            return weeksInYear(this.year(), 1, 4)
        },
        weeksInYear: function () {
            var weekInfo = this.localeData()._week;
            return weeksInYear(this.year(), weekInfo.dow, weekInfo.doy)
        },
        get: function (units) {
            return units = normalizeUnits(units), this[units]()
        },
        set: function (units, value) {
            var unit;
            if ("object" == typeof units)for (unit in units)this.set(unit, units[unit]); else units = normalizeUnits(units), "function" == typeof this[units] && this[units](value);
            return this
        },
        locale: function (key) {
            var newLocaleData;
            return key === undefined ? this._locale._abbr : (newLocaleData = moment.localeData(key), null != newLocaleData && (this._locale = newLocaleData), this)
        },
        lang: deprecate("moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.", function (key) {
            return key === undefined ? this.localeData() : this.locale(key)
        }),
        localeData: function () {
            return this._locale
        },
        _dateUtcOffset: function () {
            return 15 * -Math.round(this._d.getTimezoneOffset() / 15)
        }
    }), moment.fn.millisecond = moment.fn.milliseconds = makeAccessor("Milliseconds", !1), moment.fn.second = moment.fn.seconds = makeAccessor("Seconds", !1), moment.fn.minute = moment.fn.minutes = makeAccessor("Minutes", !1), moment.fn.hour = moment.fn.hours = makeAccessor("Hours", !0), moment.fn.date = makeAccessor("Date", !0), moment.fn.dates = deprecate("dates accessor is deprecated. Use date instead.", makeAccessor("Date", !0)), moment.fn.year = makeAccessor("FullYear", !0), moment.fn.years = deprecate("years accessor is deprecated. Use year instead.", makeAccessor("FullYear", !0)), moment.fn.days = moment.fn.day, moment.fn.months = moment.fn.month, moment.fn.weeks = moment.fn.week, moment.fn.isoWeeks = moment.fn.isoWeek, moment.fn.quarters = moment.fn.quarter, moment.fn.toJSON = moment.fn.toISOString, moment.fn.isUTC = moment.fn.isUtc, extend(moment.duration.fn = Duration.prototype, {
        _bubble: function () {
            var seconds, minutes, hours, milliseconds = this._milliseconds, days = this._days, months = this._months, data = this._data, years = 0;
            data.milliseconds = milliseconds % 1e3, seconds = absRound(milliseconds / 1e3), data.seconds = seconds % 60, minutes = absRound(seconds / 60), data.minutes = minutes % 60, hours = absRound(minutes / 60), data.hours = hours % 24, days += absRound(hours / 24), years = absRound(daysToYears(days)), days -= absRound(yearsToDays(years)), months += absRound(days / 30), days %= 30, years += absRound(months / 12), months %= 12, data.days = days, data.months = months, data.years = years
        },
        abs: function () {
            return this._milliseconds = Math.abs(this._milliseconds), this._days = Math.abs(this._days), this._months = Math.abs(this._months), this._data.milliseconds = Math.abs(this._data.milliseconds), this._data.seconds = Math.abs(this._data.seconds), this._data.minutes = Math.abs(this._data.minutes), this._data.hours = Math.abs(this._data.hours), this._data.months = Math.abs(this._data.months), this._data.years = Math.abs(this._data.years), this
        },
        weeks: function () {
            return absRound(this.days() / 7)
        },
        valueOf: function () {
            return this._milliseconds + 864e5 * this._days + this._months % 12 * 2592e6 + 31536e6 * toInt(this._months / 12)
        },
        humanize: function (withSuffix) {
            var output = relativeTime(this, !withSuffix, this.localeData());
            return withSuffix && (output = this.localeData().pastFuture(+this, output)), this.localeData().postformat(output)
        },
        add: function (input, val) {
            var dur = moment.duration(input, val);
            return this._milliseconds += dur._milliseconds, this._days += dur._days, this._months += dur._months, this._bubble(), this
        },
        subtract: function (input, val) {
            var dur = moment.duration(input, val);
            return this._milliseconds -= dur._milliseconds, this._days -= dur._days, this._months -= dur._months, this._bubble(), this
        },
        get: function (units) {
            return units = normalizeUnits(units), this[units.toLowerCase() + "s"]()
        },
        as: function (units) {
            var days, months;
            if (units = normalizeUnits(units), "month" === units || "year" === units)return days = this._days + this._milliseconds / 864e5, months = this._months + 12 * daysToYears(days), "month" === units ? months : months / 12;
            switch (days = this._days + Math.round(yearsToDays(this._months / 12)), units) {
                case"week":
                    return days / 7 + this._milliseconds / 6048e5;
                case"day":
                    return days + this._milliseconds / 864e5;
                case"hour":
                    return 24 * days + this._milliseconds / 36e5;
                case"minute":
                    return 24 * days * 60 + this._milliseconds / 6e4;
                case"second":
                    return 24 * days * 60 * 60 + this._milliseconds / 1e3;
                case"millisecond":
                    return Math.floor(24 * days * 60 * 60 * 1e3) + this._milliseconds;
                default:
                    throw new Error("Unknown unit " + units)
            }
        },
        lang: moment.fn.lang,
        locale: moment.fn.locale,
        toIsoString: deprecate("toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)", function () {
            return this.toISOString()
        }),
        toISOString: function () {
            var years = Math.abs(this.years()), months = Math.abs(this.months()), days = Math.abs(this.days()), hours = Math.abs(this.hours()), minutes = Math.abs(this.minutes()), seconds = Math.abs(this.seconds() + this.milliseconds() / 1e3);
            return this.asSeconds() ? (this.asSeconds() < 0 ? "-" : "") + "P" + (years ? years + "Y" : "") + (months ? months + "M" : "") + (days ? days + "D" : "") + (hours || minutes || seconds ? "T" : "") + (hours ? hours + "H" : "") + (minutes ? minutes + "M" : "") + (seconds ? seconds + "S" : "") : "P0D"
        },
        localeData: function () {
            return this._locale
        },
        toJSON: function () {
            return this.toISOString()
        }
    }), moment.duration.fn.toString = moment.duration.fn.toISOString;
    for (i in unitMillisecondFactors)hasOwnProp(unitMillisecondFactors, i) && makeDurationGetter(i.toLowerCase());
    moment.duration.fn.asMilliseconds = function () {
        return this.as("ms")
    }, moment.duration.fn.asSeconds = function () {
        return this.as("s")
    }, moment.duration.fn.asMinutes = function () {
        return this.as("m")
    }, moment.duration.fn.asHours = function () {
        return this.as("h")
    }, moment.duration.fn.asDays = function () {
        return this.as("d")
    }, moment.duration.fn.asWeeks = function () {
        return this.as("weeks")
    }, moment.duration.fn.asMonths = function () {
        return this.as("M")
    }, moment.duration.fn.asYears = function () {
        return this.as("y")
    }, moment.locale("en", {
        ordinalParse: /\d{1,2}(th|st|nd|rd)/, ordinal: function (number) {
            var b = number % 10, output = 1 === toInt(number % 100 / 10) ? "th" : 1 === b ? "st" : 2 === b ? "nd" : 3 === b ? "rd" : "th";
            return number + output
        }
    }), hasModule ? module.exports = moment : "function" == typeof define && define.amd ? (define(function (require, exports, module) {
                return module.config && module.config() && module.config().noGlobal === !0 && (globalScope.moment = oldGlobalMoment), moment
            }), makeGlobal(!0)) : makeGlobal()
}.call(this), function () {
    function humanizer(passedOptions) {
        var result = function (ms, humanizerOptions) {
            var options = extend({}, result, humanizerOptions || {});
            return doHumanization(ms, options)
        };
        return extend(result, {
            language: "en",
            delimiter: ", ",
            spacer: " ",
            units: ["year", "month", "week", "day", "hour", "minute", "second"],
            languages: {},
            halfUnit: !0,
            round: !1
        }, passedOptions)
    }

    function humanizeDuration() {
        return defaultHumanizer.apply(defaultHumanizer, arguments)
    }

    function doHumanization(ms, options) {
        if (ms = Math.abs(ms), 0 === ms)return "0";
        var dictionary = options.languages[options.language] || languages[options.language];
        if (!dictionary)throw new Error("No language " + dictionary + ".");
        for (var unitName, unitMS, unitCount, mightBeHalfUnit, result = [], i = 0, len = options.units.length; len > i; i++) {
            if (unitName = options.units[i], "s" === unitName[unitName.length - 1] && (unitName = unitName.substring(0, unitName.length - 1)), unitMS = UNITS[unitName], 0 === result.length && options.halfUnit && (mightBeHalfUnit = ms / unitMS * 2, mightBeHalfUnit === Math.floor(mightBeHalfUnit)))return render(mightBeHalfUnit / 2, unitName, dictionary, options.spacer);
            i + 1 === len ? (unitCount = ms / unitMS, options.round && (unitCount = Math.round(unitCount))) : unitCount = Math.floor(ms / unitMS), unitCount && result.push(render(unitCount, unitName, dictionary, options.spacer)), ms -= unitCount * unitMS
        }
        return result.join(options.delimiter)
    }

    function render(count, type, dictionary, spacer) {
        var word, dictionaryValue = dictionary[type];
        return word = "function" == typeof dictionaryValue ? dictionaryValue(count) : dictionaryValue, count + spacer + word
    }

    function extend(destination) {
        for (var source, i = 1; i < arguments.length; i++) {
            source = arguments[i];
            for (var prop in source)source.hasOwnProperty(prop) && (destination[prop] = source[prop])
        }
        return destination
    }

    function getPolishForm(c) {
        return 1 === c ? 0 : Math.floor(c) !== c ? 1 : c % 10 >= 2 && 4 >= c % 10 && !(c % 100 > 10 && 20 > c % 100) ? 2 : 3
    }

    function getRussianForm(c) {
        return Math.floor(c) !== c ? 2 : 0 === c || c >= 5 && 20 >= c || c % 10 >= 5 && 9 >= c % 10 || c % 10 === 0 ? 0 : 1 === c || c % 10 === 1 ? 1 : c > 1 ? 2 : 0
    }

    function getSupportedLanguages() {
        var result = [];
        for (var language in languages)languages.hasOwnProperty(language) && result.push(language);
        return result
    }

    var UNITS = {
        year: 315576e5,
        month: 26298e5,
        week: 6048e5,
        day: 864e5,
        hour: 36e5,
        minute: 6e4,
        second: 1e3,
        millisecond: 1
    }, languages = {
        ar: {
            year: function (c) {
                return 1 === c ? "سنة" : "سنوات"
            }, month: function (c) {
                return 1 === c ? "شهر" : "أشهر"
            }, week: function (c) {
                return 1 === c ? "أسبوع" : "أسابيع"
            }, day: function (c) {
                return 1 === c ? "يوم" : "أيام"
            }, hour: function (c) {
                return 1 === c ? "ساعة" : "ساعات"
            }, minute: function (c) {
                return 1 === c ? "دقيقة" : "دقائق"
            }, second: function (c) {
                return 1 === c ? "ثانية" : "ثواني"
            }, millisecond: function (c) {
                return 1 === c ? "جزء من الثانية" : "أجزاء من الثانية"
            }
        },
        ca: {
            year: function (c) {
                return "any" + (1 !== c ? "s" : "")
            }, month: function (c) {
                return "mes" + (1 !== c ? "os" : "")
            }, week: function (c) {
                return "setman" + (1 !== c ? "es" : "a")
            }, day: function (c) {
                return "di" + (1 !== c ? "es" : "a")
            }, hour: function (c) {
                return "hor" + (1 !== c ? "es" : "a")
            }, minute: function (c) {
                return "minut" + (1 !== c ? "s" : "")
            }, second: function (c) {
                return "segon" + (1 !== c ? "s" : "")
            }, millisecond: function (c) {
                return "milisegon" + (1 !== c ? "s" : "")
            }
        },
        da: {
            year: "år", month: function (c) {
                return "måned" + (1 !== c ? "er" : "")
            }, week: function (c) {
                return "uge" + (1 !== c ? "r" : "")
            }, day: function (c) {
                return "dag" + (1 !== c ? "e" : "")
            }, hour: function (c) {
                return "time" + (1 !== c ? "r" : "")
            }, minute: function (c) {
                return "minut" + (1 !== c ? "ter" : "")
            }, second: function (c) {
                return "sekund" + (1 !== c ? "er" : "")
            }, millisecond: function (c) {
                return "millisekund" + (1 !== c ? "er" : "")
            }
        },
        de: {
            year: function (c) {
                return "Jahr" + (1 !== c ? "e" : "")
            }, month: function (c) {
                return "Monat" + (1 !== c ? "e" : "")
            }, week: function (c) {
                return "Woche" + (1 !== c ? "n" : "")
            }, day: function (c) {
                return "Tag" + (1 !== c ? "e" : "")
            }, hour: function (c) {
                return "Stunde" + (1 !== c ? "n" : "")
            }, minute: function (c) {
                return "Minute" + (1 !== c ? "n" : "")
            }, second: function (c) {
                return "Sekunde" + (1 !== c ? "n" : "")
            }, millisecond: function (c) {
                return "Millisekunde" + (1 !== c ? "n" : "")
            }
        },
        en: {
            year: function (c) {
                return "year" + (1 !== c ? "s" : "")
            }, month: function (c) {
                return "month" + (1 !== c ? "s" : "")
            }, week: function (c) {
                return "week" + (1 !== c ? "s" : "")
            }, day: function (c) {
                return "day" + (1 !== c ? "s" : "")
            }, hour: function (c) {
                return "hour" + (1 !== c ? "s" : "")
            }, minute: function (c) {
                return "minute" + (1 !== c ? "s" : "")
            }, second: function (c) {
                return "second" + (1 !== c ? "s" : "")
            }, millisecond: function (c) {
                return "millisecond" + (1 !== c ? "s" : "")
            }
        },
        es: {
            year: function (c) {
                return "año" + (1 !== c ? "s" : "")
            }, month: function (c) {
                return "mes" + (1 !== c ? "es" : "")
            }, week: function (c) {
                return "semana" + (1 !== c ? "s" : "")
            }, day: function (c) {
                return "día" + (1 !== c ? "s" : "")
            }, hour: function (c) {
                return "hora" + (1 !== c ? "s" : "")
            }, minute: function (c) {
                return "minuto" + (1 !== c ? "s" : "")
            }, second: function (c) {
                return "segundo" + (1 !== c ? "s" : "")
            }, millisecond: function (c) {
                return "milisegundo" + (1 !== c ? "s" : "")
            }
        },
        fr: {
            year: function (c) {
                return "an" + (1 !== c ? "s" : "")
            }, month: "mois", week: function (c) {
                return "semaine" + (1 !== c ? "s" : "")
            }, day: function (c) {
                return "jour" + (1 !== c ? "s" : "")
            }, hour: function (c) {
                return "heure" + (1 !== c ? "s" : "")
            }, minute: function (c) {
                return "minute" + (1 !== c ? "s" : "")
            }, second: function (c) {
                return "seconde" + (1 !== c ? "s" : "")
            }, millisecond: function (c) {
                return "milliseconde" + (1 !== c ? "s" : "")
            }
        },
        hu: {
            year: "év",
            month: "hónap",
            week: "hét",
            day: "nap",
            hour: "óra",
            minute: "perc",
            second: "másodperc",
            millisecond: "ezredmásodperc"
        },
        it: {
            year: function (c) {
                return "ann" + (1 !== c ? "i" : "o")
            }, month: function (c) {
                return "mes" + (1 !== c ? "i" : "e")
            }, week: function (c) {
                return "settiman" + (1 !== c ? "e" : "a")
            }, day: function (c) {
                return "giorn" + (1 !== c ? "i" : "o")
            }, hour: function (c) {
                return "or" + (1 !== c ? "e" : "a")
            }, minute: function (c) {
                return "minut" + (1 !== c ? "i" : "o")
            }, second: function (c) {
                return "second" + (1 !== c ? "i" : "o")
            }, millisecond: function (c) {
                return "millisecond" + (1 !== c ? "i" : "o")
            }
        },
        ja: {year: "年", month: "月", week: "週", day: "日", hour: "時間", minute: "分", second: "秒", millisecond: "ミリ秒"},
        ko: {year: "년", month: "개월", week: "주일", day: "일", hour: "시간", minute: "분", second: "초", millisecond: "밀리 초"},
        nl: {
            year: "jaar", month: function (c) {
                return 1 === c ? "maand" : "maanden"
            }, week: function (c) {
                return 1 === c ? "week" : "weken"
            }, day: function (c) {
                return 1 === c ? "dag" : "dagen"
            }, hour: "uur", minute: function (c) {
                return 1 === c ? "minuut" : "minuten"
            }, second: function (c) {
                return 1 === c ? "seconde" : "seconden"
            }, millisecond: function (c) {
                return 1 === c ? "milliseconde" : "milliseconden"
            }
        },
        nob: {
            year: "år", month: function (c) {
                return "måned" + (1 !== c ? "er" : "")
            }, week: function (c) {
                return "uke" + (1 !== c ? "r" : "")
            }, day: function (c) {
                return "dag" + (1 !== c ? "er" : "")
            }, hour: function (c) {
                return "time" + (1 !== c ? "r" : "")
            }, minute: function (c) {
                return "minutt" + (1 !== c ? "er" : "")
            }, second: function (c) {
                return "sekund" + (1 !== c ? "er" : "")
            }, millisecond: function (c) {
                return "millisekund" + (1 !== c ? "er" : "")
            }
        },
        pl: {
            year: function (c) {
                return ["rok", "roku", "lata", "lat"][getPolishForm(c)]
            }, month: function (c) {
                return ["miesiąc", "miesiąca", "miesiące", "miesięcy"][getPolishForm(c)]
            }, week: function (c) {
                return ["tydzień", "tygodnia", "tygodnie", "tygodni"][getPolishForm(c)]
            }, day: function (c) {
                return ["dzień", "dnia", "dni", "dni"][getPolishForm(c)]
            }, hour: function (c) {
                return ["godzina", "godziny", "godziny", "godzin"][getPolishForm(c)]
            }, minute: function (c) {
                return ["minuta", "minuty", "minuty", "minut"][getPolishForm(c)]
            }, second: function (c) {
                return ["sekunda", "sekundy", "sekundy", "sekund"][getPolishForm(c)]
            }, millisecond: function (c) {
                return ["milisekunda", "milisekundy", "milisekundy", "milisekund"][getPolishForm(c)]
            }
        },
        pt: {
            year: function (c) {
                return "ano" + (1 !== c ? "s" : "")
            }, month: function (c) {
                return 1 !== c ? "meses" : "mês"
            }, week: function (c) {
                return "semana" + (1 !== c ? "s" : "")
            }, day: function (c) {
                return "dia" + (1 !== c ? "s" : "")
            }, hour: function (c) {
                return "hora" + (1 !== c ? "s" : "")
            }, minute: function (c) {
                return "minuto" + (1 !== c ? "s" : "")
            }, second: function (c) {
                return "segundo" + (1 !== c ? "s" : "")
            }, millisecond: function (c) {
                return "milissegundo" + (1 !== c ? "s" : "")
            }
        },
        ru: {
            year: function (c) {
                return ["лет", "год", "года"][getRussianForm(c)]
            }, month: function (c) {
                return ["месяцев", "месяц", "месяца"][getRussianForm(c)]
            }, week: function (c) {
                return ["недель", "неделя", "недели"][getRussianForm(c)]
            }, day: function (c) {
                return ["дней", "день", "дня"][getRussianForm(c)]
            }, hour: function (c) {
                return ["часов", "час", "часа"][getRussianForm(c)]
            }, minute: function (c) {
                return ["минут", "минута", "минуты"][getRussianForm(c)]
            }, second: function (c) {
                return ["секунд", "секунда", "секунды"][getRussianForm(c)]
            }, millisecond: function (c) {
                return ["миллисекунд", "миллисекунда", "миллисекунды"][getRussianForm(c)]
            }
        },
        sv: {
            year: "år", month: function (c) {
                return "månad" + (1 !== c ? "er" : "")
            }, week: function (c) {
                return "veck" + (1 !== c ? "or" : "a")
            }, day: function (c) {
                return "dag" + (1 !== c ? "ar" : "")
            }, hour: function (c) {
                return "timm" + (1 !== c ? "ar" : "e")
            }, minute: function (c) {
                return "minut" + (1 !== c ? "er" : "")
            }, second: function (c) {
                return "sekund" + (1 !== c ? "er" : "")
            }, millisecond: function (c) {
                return "millisekund" + (1 !== c ? "er" : "")
            }
        },
        tr: {
            year: "yıl",
            month: "ay",
            week: "hafta",
            day: "gün",
            hour: "saat",
            minute: "dakika",
            second: "saniye",
            millisecond: "milisaniye"
        },
        "zh-CN": {
            year: "年",
            month: "个月",
            week: "周",
            day: "天",
            hour: "小时",
            minute: "分钟",
            second: "秒",
            millisecond: "毫秒"
        },
        "zh-TW": {year: "年", month: "個月", week: "周", day: "天", hour: "小時", minute: "分鐘", second: "秒", millisecond: "毫秒"}
    }, defaultHumanizer = humanizer({});
    humanizeDuration.humanizer = humanizer, humanizeDuration.getSupportedLanguages = getSupportedLanguages, "function" == typeof define && define.amd ? define(function () {
            return humanizeDuration
        }) : "undefined" != typeof module && module.exports ? module.exports = humanizeDuration : this.humanizeDuration = humanizeDuration
}();
var timerModule = angular.module("timer", []).directive("timer", ["$compile", function ($compile) {
    return {
        restrict: "EA",
        replace: !1,
        scope: {
            interval: "=interval",
            startTimeAttr: "=startTime",
            endTimeAttr: "=endTime",
            countdownattr: "=countdown",
            finishCallback: "&finishCallback",
            autoStart: "&autoStart",
            language: "@?",
            fallback: "@?",
            maxTimeUnit: "=",
            seconds: "=?",
            minutes: "=?",
            hours: "=?",
            days: "=?",
            months: "=?",
            years: "=?",
            secondsS: "=?",
            minutesS: "=?",
            hoursS: "=?",
            daysS: "=?",
            monthsS: "=?",
            yearsS: "=?"
        },
        controller: ["$scope", "$element", "$attrs", "$timeout", "I18nService", "$interpolate", "progressBarService", function ($scope, $element, $attrs, $timeout, I18nService, $interpolate, progressBarService) {
            function resetTimeout() {
                $scope.timeoutId && clearTimeout($scope.timeoutId)
            }

            function calculateTimeUnits() {
                var timeUnits = {};
                void 0 !== $attrs.startTime && ($scope.millis = moment().diff(moment($scope.startTimeAttr))), timeUnits = i18nService.getTimeUnits($scope.millis), $scope.maxTimeUnit && "day" !== $scope.maxTimeUnit ? "second" === $scope.maxTimeUnit ? ($scope.seconds = Math.floor($scope.millis / 1e3), $scope.minutes = 0, $scope.hours = 0, $scope.days = 0, $scope.months = 0, $scope.years = 0) : "minute" === $scope.maxTimeUnit ? ($scope.seconds = Math.floor($scope.millis / 1e3 % 60), $scope.minutes = Math.floor($scope.millis / 6e4), $scope.hours = 0, $scope.days = 0, $scope.months = 0, $scope.years = 0) : "hour" === $scope.maxTimeUnit ? ($scope.seconds = Math.floor($scope.millis / 1e3 % 60), $scope.minutes = Math.floor($scope.millis / 6e4 % 60), $scope.hours = Math.floor($scope.millis / 36e5), $scope.days = 0, $scope.months = 0, $scope.years = 0) : "month" === $scope.maxTimeUnit ? ($scope.seconds = Math.floor($scope.millis / 1e3 % 60), $scope.minutes = Math.floor($scope.millis / 6e4 % 60), $scope.hours = Math.floor($scope.millis / 36e5 % 24), $scope.days = Math.floor($scope.millis / 36e5 / 24 % 30), $scope.months = Math.floor($scope.millis / 36e5 / 24 / 30), $scope.years = 0) : "year" === $scope.maxTimeUnit && ($scope.seconds = Math.floor($scope.millis / 1e3 % 60), $scope.minutes = Math.floor($scope.millis / 6e4 % 60), $scope.hours = Math.floor($scope.millis / 36e5 % 24), $scope.days = Math.floor($scope.millis / 36e5 / 24 % 30), $scope.months = Math.floor($scope.millis / 36e5 / 24 / 30 % 12), $scope.years = Math.floor($scope.millis / 36e5 / 24 / 365)) : ($scope.seconds = Math.floor($scope.millis / 1e3 % 60), $scope.minutes = Math.floor($scope.millis / 6e4 % 60), $scope.hours = Math.floor($scope.millis / 36e5 % 24), $scope.days = Math.floor($scope.millis / 36e5 / 24), $scope.months = 0, $scope.years = 0), $scope.secondsS = 1 === $scope.seconds ? "" : "s", $scope.minutesS = 1 === $scope.minutes ? "" : "s", $scope.hoursS = 1 === $scope.hours ? "" : "s", $scope.daysS = 1 === $scope.days ? "" : "s", $scope.monthsS = 1 === $scope.months ? "" : "s", $scope.yearsS = 1 === $scope.years ? "" : "s", $scope.secondUnit = timeUnits.seconds, $scope.minuteUnit = timeUnits.minutes, $scope.hourUnit = timeUnits.hours, $scope.dayUnit = timeUnits.days, $scope.monthUnit = timeUnits.months, $scope.yearUnit = timeUnits.years, $scope.sseconds = $scope.seconds < 10 ? "0" + $scope.seconds : $scope.seconds, $scope.mminutes = $scope.minutes < 10 ? "0" + $scope.minutes : $scope.minutes, $scope.hhours = $scope.hours < 10 ? "0" + $scope.hours : $scope.hours, $scope.ddays = $scope.days < 10 ? "0" + $scope.days : $scope.days, $scope.mmonths = $scope.months < 10 ? "0" + $scope.months : $scope.months, $scope.yyears = $scope.years < 10 ? "0" + $scope.years : $scope.years
            }

            "function" != typeof String.prototype.trim && (String.prototype.trim = function () {
                return this.replace(/^\s+|\s+$/g, "")
            }), $scope.autoStart = $attrs.autoStart || $attrs.autostart, $scope.language = $scope.language || "en", $scope.fallback = $scope.fallback || "en", $scope.$watch("language", function (newVal, oldVal) {
                void 0 !== newVal && i18nService.init(newVal, $scope.fallback)
            });
            var i18nService = new I18nService;
            i18nService.init($scope.language, $scope.fallback), $scope.displayProgressBar = 0, $scope.displayProgressActive = "active", 0 === $element.html().trim().length ? $element.append($compile("<span>" + $interpolate.startSymbol() + "millis" + $interpolate.endSymbol() + "</span>")($scope)) : $element.append($compile($element.contents())($scope)), $scope.startTime = null, $scope.endTime = null, $scope.timeoutId = null, $scope.countdown = angular.isNumber($scope.countdownattr) && parseInt($scope.countdownattr, 10) >= 0 ? parseInt($scope.countdownattr, 10) : void 0, $scope.isRunning = !1, $scope.$on("timer-start", function () {
                $scope.start()
            }), $scope.$on("timer-resume", function () {
                $scope.resume()
            }), $scope.$on("timer-stop", function () {
                $scope.stop()
            }), $scope.$on("timer-clear", function () {
                $scope.clear()
            }), $scope.$on("timer-reset", function () {
                $scope.reset()
            }), $scope.$on("timer-set-countdown", function (e, countdown) {
                $scope.countdown = countdown
            }), $scope.$watch("startTimeAttr", function (newValue, oldValue) {
                newValue !== oldValue && $scope.isRunning && $scope.start()
            }), $scope.$watch("endTimeAttr", function (newValue, oldValue) {
                newValue !== oldValue && $scope.isRunning && $scope.start()
            }), $scope.start = $element[0].start = function () {
                $scope.startTime = $scope.startTimeAttr ? moment($scope.startTimeAttr) : moment(), $scope.endTime = $scope.endTimeAttr ? moment($scope.endTimeAttr) : null, angular.isNumber($scope.countdown) || ($scope.countdown = angular.isNumber($scope.countdownattr) && parseInt($scope.countdownattr, 10) > 0 ? parseInt($scope.countdownattr, 10) : void 0), resetTimeout(), tick(), $scope.isRunning = !0
            }, $scope.resume = $element[0].resume = function () {
                resetTimeout(), $scope.countdownattr && ($scope.countdown += 1), $scope.startTime = moment().diff(moment($scope.stoppedTime).diff(moment($scope.startTime))), tick(), $scope.isRunning = !0
            }, $scope.stop = $scope.pause = $element[0].stop = $element[0].pause = function () {
                var timeoutId = $scope.timeoutId;
                $scope.clear(), $scope.$emit("timer-stopped", {
                    timeoutId: timeoutId,
                    millis: $scope.millis,
                    seconds: $scope.seconds,
                    minutes: $scope.minutes,
                    hours: $scope.hours,
                    days: $scope.days
                })
            }, $scope.clear = $element[0].clear = function () {
                $scope.stoppedTime = moment(), resetTimeout(), $scope.timeoutId = null, $scope.isRunning = !1
            }, $scope.reset = $element[0].reset = function () {
                $scope.startTime = $scope.startTimeAttr ? moment($scope.startTimeAttr) : moment(), $scope.endTime = $scope.endTimeAttr ? moment($scope.endTimeAttr) : null, $scope.countdown = angular.isNumber($scope.countdownattr) && parseInt($scope.countdownattr, 10) > 0 ? parseInt($scope.countdownattr, 10) : void 0, resetTimeout(), tick(), $scope.isRunning = !1, $scope.clear()
            }, $element.bind("$destroy", function () {
                resetTimeout(), $scope.isRunning = !1
            }), $scope.countdownattr ? ($scope.millis = 1e3 * $scope.countdownattr, $scope.addCDSeconds = $element[0].addCDSeconds = function (extraSeconds) {
                    $scope.countdown += extraSeconds, $scope.$digest(), $scope.isRunning || $scope.start()
                }, $scope.$on("timer-add-cd-seconds", function (e, extraSeconds) {
                    $timeout(function () {
                        $scope.addCDSeconds(extraSeconds)
                    })
                }), $scope.$on("timer-set-countdown-seconds", function (e, countdownSeconds) {
                    $scope.isRunning || $scope.clear(), $scope.countdown = countdownSeconds, $scope.millis = 1e3 * countdownSeconds, calculateTimeUnits()
                })) : $scope.millis = 0, calculateTimeUnits();
            var tick = function tick() {
                var typeTimer = null;
                $scope.millis = moment().diff($scope.startTime);
                var adjustment = $scope.millis % 1e3;
                return $scope.endTimeAttr && (typeTimer = $scope.endTimeAttr, $scope.millis = moment($scope.endTime).diff(moment()), adjustment = $scope.interval - $scope.millis % 1e3), $scope.countdownattr && (typeTimer = $scope.countdownattr, $scope.millis = 1e3 * $scope.countdown), $scope.millis < 0 ? ($scope.stop(), $scope.millis = 0, calculateTimeUnits(), void($scope.finishCallback && $scope.$eval($scope.finishCallback))) : (calculateTimeUnits(), $scope.timeoutId = setTimeout(function () {
                        tick(), $scope.$digest()
                    }, $scope.interval - adjustment), $scope.$emit("timer-tick", {
                        timeoutId: $scope.timeoutId,
                        millis: $scope.millis,
                        timerElement: $element[0]
                    }), $scope.countdown > 0 ? $scope.countdown-- : $scope.countdown <= 0 && ($scope.stop(), $scope.finishCallback && $scope.$eval($scope.finishCallback)), void(null !== typeTimer && ($scope.progressBar = progressBarService.calculateProgressBar($scope.startTime, $scope.millis, $scope.endTime, $scope.countdownattr), 100 === $scope.progressBar && ($scope.displayProgressActive = ""))))
            };
            (void 0 === $scope.autoStart || $scope.autoStart === !0) && $scope.start()
        }]
    }
}]);
"undefined" != typeof module && "undefined" != typeof exports && module.exports === exports && (module.exports = timerModule);
var app = angular.module("timer");
app.factory("I18nService", function () {
    var I18nService = function () {
    };
    return I18nService.prototype.language = "en", I18nService.prototype.fallback = "en", I18nService.prototype.timeHumanizer = {}, I18nService.prototype.init = function (lang, fallback) {
        var supported_languages = humanizeDuration.getSupportedLanguages();
        this.fallback = void 0 !== fallback ? fallback : "en", -1 === supported_languages.indexOf(fallback) && (this.fallback = "en"), this.language = lang, -1 === supported_languages.indexOf(lang) && (this.language = this.fallback), moment.locale(this.language), this.timeHumanizer = humanizeDuration.humanizer({
            language: this.language,
            halfUnit: !1
        })
    }, I18nService.prototype.getTimeUnits = function (millis) {
        var diffFromAlarm = 1e3 * Math.round(millis / 1e3), time = {};
        return "undefined" != typeof this.timeHumanizer ? time = {
                millis: this.timeHumanizer(diffFromAlarm, {units: ["milliseconds"]}),
                seconds: this.timeHumanizer(diffFromAlarm, {units: ["seconds"]}),
                minutes: this.timeHumanizer(diffFromAlarm, {units: ["minutes", "seconds"]}),
                hours: this.timeHumanizer(diffFromAlarm, {units: ["hours", "minutes", "seconds"]}),
                days: this.timeHumanizer(diffFromAlarm, {units: ["days", "hours", "minutes", "seconds"]}),
                months: this.timeHumanizer(diffFromAlarm, {units: ["months", "days", "hours", "minutes", "seconds"]}),
                years: this.timeHumanizer(diffFromAlarm, {units: ["years", "months", "days", "hours", "minutes", "seconds"]})
            } : console.error('i18nService has not been initialized. You must call i18nService.init("en") for example'), time
    }, I18nService
});
var app = angular.module("timer");
app.factory("progressBarService", function () {
    var ProgressBarService = function () {
    };
    return ProgressBarService.prototype.calculateProgressBar = function (startValue, remainingTime, endTimeAttr, coutdown) {
        var endTimeValue, initialCountdown, displayProgressBar = 0;
        return remainingTime /= 1e3, null !== endTimeAttr ? (endTimeValue = moment(endTimeAttr), initialCountdown = endTimeValue.diff(startValue, "seconds"), displayProgressBar = 100 * remainingTime / initialCountdown) : displayProgressBar = 100 * remainingTime / coutdown, displayProgressBar = 100 - displayProgressBar, displayProgressBar = Math.round(10 * displayProgressBar) / 10, displayProgressBar > 100 && (displayProgressBar = 100), displayProgressBar
    }, new ProgressBarService
}), function ($, window, document, undefined) {
    function Owl(element, options) {
        this.settings = null, this.options = $.extend({}, Owl.Defaults, options), this.$element = $(element), this._handlers = {}, this._plugins = {}, this._supress = {}, this._current = null, this._speed = null, this._coordinates = [], this._breakpoint = null, this._width = null, this._items = [], this._clones = [], this._mergers = [], this._widths = [], this._invalidated = {}, this._pipe = [], this._drag = {
            time: null,
            target: null,
            pointer: null,
            stage: {start: null, current: null},
            direction: null
        }, this._states = {
            current: {},
            tags: {initializing: ["busy"], animating: ["busy"], dragging: ["interacting"]}
        }, $.each(["onResize", "onThrottledResize"], $.proxy(function (i, handler) {
            this._handlers[handler] = $.proxy(this[handler], this)
        }, this)), $.each(Owl.Plugins, $.proxy(function (key, plugin) {
            this._plugins[key.charAt(0).toLowerCase() + key.slice(1)] = new plugin(this)
        }, this)), $.each(Owl.Workers, $.proxy(function (priority, worker) {
            this._pipe.push({filter: worker.filter, run: $.proxy(worker.run, this)})
        }, this)), this.setup(), this.initialize()
    }

    Owl.Defaults = {
        items: 3,
        loop: !1,
        center: !1,
        rewind: !1,
        mouseDrag: !0,
        touchDrag: !0,
        pullDrag: !0,
        freeDrag: !1,
        margin: 0,
        stagePadding: 0,
        merge: !1,
        mergeFit: !0,
        autoWidth: !1,
        startPosition: 0,
        rtl: !1,
        smartSpeed: 250,
        fluidSpeed: !1,
        dragEndSpeed: !1,
        responsive: {},
        responsiveRefreshRate: 200,
        responsiveBaseElement: window,
        fallbackEasing: "swing",
        info: !1,
        nestedItemSelector: !1,
        itemElement: "div",
        stageElement: "div",
        refreshClass: "owl-refresh",
        loadedClass: "owl-loaded",
        loadingClass: "owl-loading",
        rtlClass: "owl-rtl",
        responsiveClass: "owl-responsive",
        dragClass: "owl-drag",
        itemClass: "owl-item",
        stageClass: "owl-stage",
        stageOuterClass: "owl-stage-outer",
        grabClass: "owl-grab"
    }, Owl.Width = {Default: "default", Inner: "inner", Outer: "outer"}, Owl.Type = {
        Event: "event",
        State: "state"
    }, Owl.Plugins = {}, Owl.Workers = [{
        filter: ["width", "settings"], run: function () {
            this._width = this.$element.width()
        }
    }, {
        filter: ["width", "items", "settings"], run: function (cache) {
            cache.current = this._items && this._items[this.relative(this._current)]
        }
    }, {
        filter: ["items", "settings"], run: function () {
            this.$stage.children(".cloned").remove()
        }
    }, {
        filter: ["width", "items", "settings"], run: function (cache) {
            var margin = this.settings.margin || "", grid = !this.settings.autoWidth, rtl = this.settings.rtl, css = {
                width: "auto",
                "margin-left": rtl ? margin : "",
                "margin-right": rtl ? "" : margin
            };
            !grid && this.$stage.children().css(css), cache.css = css
        }
    }, {
        filter: ["width", "items", "settings"], run: function (cache) {
            var width = (this.width() / this.settings.items).toFixed(3) - this.settings.margin, merge = null, iterator = this._items.length, grid = !this.settings.autoWidth, widths = [];
            for (cache.items = {
                merge: !1,
                width: width
            }; iterator--;)merge = this._mergers[iterator], merge = this.settings.mergeFit && Math.min(merge, this.settings.items) || merge, cache.items.merge = merge > 1 || cache.items.merge, widths[iterator] = grid ? width * merge : this._items[iterator].width();
            this._widths = widths
        }
    }, {
        filter: ["items", "settings"], run: function () {
            var clones = [], items = this._items, settings = this.settings, view = Math.max(2 * settings.items, 4), size = 2 * Math.ceil(items.length / 2), repeat = settings.loop && items.length ? settings.rewind ? view : Math.max(view, size) : 0, append = "", prepend = "";
            for (repeat /= 2; repeat--;)clones.push(this.normalize(clones.length / 2, !0)), append += items[clones[clones.length - 1]][0].outerHTML, clones.push(this.normalize(items.length - 1 - (clones.length - 1) / 2, !0)), prepend = items[clones[clones.length - 1]][0].outerHTML + prepend;
            this._clones = clones, $(append).addClass("cloned").appendTo(this.$stage), $(prepend).addClass("cloned").prependTo(this.$stage)
        }
    }, {
        filter: ["width", "items", "settings"], run: function () {
            for (var rtl = this.settings.rtl ? 1 : -1, size = this._clones.length + this._items.length, iterator = -1, previous = 0, current = 0, coordinates = []; ++iterator < size;)previous = coordinates[iterator - 1] || 0, current = this._widths[this.relative(iterator)] + this.settings.margin, coordinates.push(previous + current * rtl);
            this._coordinates = coordinates
        }
    }, {
        filter: ["width", "items", "settings"], run: function () {
            var padding = this.settings.stagePadding, coordinates = this._coordinates, css = {
                width: Math.ceil(Math.abs(coordinates[coordinates.length - 1])) + 2 * padding,
                "padding-left": padding || "",
                "padding-right": padding || ""
            };
            this.$stage.css(css)
        }
    }, {
        filter: ["width", "items", "settings"], run: function (cache) {
            var iterator = this._coordinates.length, grid = !this.settings.autoWidth, items = this.$stage.children();
            if (grid && cache.items.merge)for (; iterator--;)cache.css.width = this._widths[this.relative(iterator)], items.eq(iterator).css(cache.css); else grid && (cache.css.width = cache.items.width, items.css(cache.css))
        }
    }, {
        filter: ["items"], run: function () {
            this._coordinates.length < 1 && this.$stage.removeAttr("style")
        }
    }, {
        filter: ["width", "items", "settings"], run: function (cache) {
            cache.current = cache.current ? this.$stage.children().index(cache.current) : 0, cache.current = Math.max(this.minimum(), Math.min(this.maximum(), cache.current)), this.reset(cache.current)
        }
    }, {
        filter: ["position"], run: function () {
            this.animate(this.coordinates(this._current))
        }
    }, {
        filter: ["width", "position", "items", "settings"], run: function () {
            var inner, outer, i, n, rtl = this.settings.rtl ? 1 : -1, padding = 2 * this.settings.stagePadding, begin = this.coordinates(this.current()) + padding, end = begin + this.width() * rtl, matches = [];
            for (i = 0, n = this._coordinates.length; n > i; i++)inner = this._coordinates[i - 1] || 0, outer = Math.abs(this._coordinates[i]) + padding * rtl, (this.op(inner, "<=", begin) && this.op(inner, ">", end) || this.op(outer, "<", begin) && this.op(outer, ">", end)) && matches.push(i);
            this.$stage.children(".active").removeClass("active"), this.$stage.children(":eq(" + matches.join("), :eq(") + ")").addClass("active"), this.settings.center && (this.$stage.children(".center").removeClass("center"), this.$stage.children().eq(this.current()).addClass("center"))
        }
    }], Owl.prototype.initialize = function () {
        if (this.enter("initializing"), this.trigger("initialize"), this.$element.toggleClass(this.settings.rtlClass, this.settings.rtl), this.settings.autoWidth && !this.is("pre-loading")) {
            var imgs, nestedSelector, width;
            imgs = this.$element.find("img"), nestedSelector = this.settings.nestedItemSelector ? "." + this.settings.nestedItemSelector : undefined, width = this.$element.children(nestedSelector).width(), imgs.length && 0 >= width && this.preloadAutoWidthImages(imgs)
        }
        this.$element.addClass(this.options.loadingClass), this.$stage = $("<" + this.settings.stageElement + ' class="' + this.settings.stageClass + '"/>').wrap('<div class="' + this.settings.stageOuterClass + '"/>'), this.$element.append(this.$stage.parent()), this.replace(this.$element.children().not(this.$stage.parent())), this.$element.is(":visible") ? this.refresh() : this.invalidate("width"), this.$element.removeClass(this.options.loadingClass).addClass(this.options.loadedClass), this.registerEventHandlers(), this.leave("initializing"), this.trigger("initialized")
    }, Owl.prototype.setup = function () {
        var viewport = this.viewport(), overwrites = this.options.responsive, match = -1, settings = null;
        overwrites ? ($.each(overwrites, function (breakpoint) {
                viewport >= breakpoint && breakpoint > match && (match = Number(breakpoint))
            }), settings = $.extend({}, this.options, overwrites[match]), "function" == typeof settings.stagePadding && (settings.stagePadding = settings.stagePadding()), delete settings.responsive, settings.responsiveClass && this.$element.attr("class", this.$element.attr("class").replace(new RegExp("(" + this.options.responsiveClass + "-)\\S+\\s", "g"), "$1" + match))) : settings = $.extend({}, this.options), this.trigger("change", {
            property: {
                name: "settings",
                value: settings
            }
        }), this._breakpoint = match, this.settings = settings, this.invalidate("settings"), this.trigger("changed", {
            property: {
                name: "settings",
                value: this.settings
            }
        })
    }, Owl.prototype.optionsLogic = function () {
        this.settings.autoWidth && (this.settings.stagePadding = !1, this.settings.merge = !1)
    }, Owl.prototype.prepare = function (item) {
        var event = this.trigger("prepare", {content: item});
        return event.data || (event.data = $("<" + this.settings.itemElement + "/>").addClass(this.options.itemClass).append(item)), this.trigger("prepared", {content: event.data}), event.data
    }, Owl.prototype.update = function () {
        for (var i = 0, n = this._pipe.length, filter = $.proxy(function (p) {
            return this[p]
        }, this._invalidated), cache = {}; n > i;)(this._invalidated.all || $.grep(this._pipe[i].filter, filter).length > 0) && this._pipe[i].run(cache), i++;
        this._invalidated = {}, !this.is("valid") && this.enter("valid")
    }, Owl.prototype.width = function (dimension) {
        switch (dimension = dimension || Owl.Width.Default) {
            case Owl.Width.Inner:
            case Owl.Width.Outer:
                return this._width;
            default:
                return this._width - 2 * this.settings.stagePadding + this.settings.margin
        }
    }, Owl.prototype.refresh = function () {
        this.enter("refreshing"), this.trigger("refresh"), this.setup(), this.optionsLogic(), this.$element.addClass(this.options.refreshClass), this.update(), this.$element.removeClass(this.options.refreshClass), this.leave("refreshing"), this.trigger("refreshed")
    }, Owl.prototype.onThrottledResize = function () {
        window.clearTimeout(this.resizeTimer), this.resizeTimer = window.setTimeout(this._handlers.onResize, this.settings.responsiveRefreshRate)
    }, Owl.prototype.onResize = function () {
        return this._items.length ? this._width === this.$element.width() ? !1 : this.$element.is(":visible") ? (this.enter("resizing"), this.trigger("resize").isDefaultPrevented() ? (this.leave("resizing"), !1) : (this.invalidate("width"), this.refresh(), this.leave("resizing"), void this.trigger("resized"))) : !1 : !1
    }, Owl.prototype.registerEventHandlers = function () {
        $.support.transition && this.$stage.on($.support.transition.end + ".owl.core", $.proxy(this.onTransitionEnd, this)), this.settings.responsive !== !1 && this.on(window, "resize", this._handlers.onThrottledResize), this.settings.mouseDrag && (this.$element.addClass(this.options.dragClass), this.$stage.on("mousedown.owl.core", $.proxy(this.onDragStart, this)), this.$stage.on("dragstart.owl.core selectstart.owl.core", function () {
            return !1
        })), this.settings.touchDrag && (this.$stage.on("touchstart.owl.core", $.proxy(this.onDragStart, this)), this.$stage.on("touchcancel.owl.core", $.proxy(this.onDragEnd, this)))
    }, Owl.prototype.onDragStart = function (event) {
        var stage = null;
        3 !== event.which && ($.support.transform ? (stage = this.$stage.css("transform").replace(/.*\(|\)| /g, "").split(","), stage = {
                x: stage[16 === stage.length ? 12 : 4],
                y: stage[16 === stage.length ? 13 : 5]
            }) : (stage = this.$stage.position(), stage = {
                x: this.settings.rtl ? stage.left + this.$stage.width() - this.width() + this.settings.margin : stage.left,
                y: stage.top
            }), this.is("animating") && ($.support.transform ? this.animate(stage.x) : this.$stage.stop(), this.invalidate("position")), this.$element.toggleClass(this.options.grabClass, "mousedown" === event.type), this.speed(0), this._drag.time = (new Date).getTime(), this._drag.target = $(event.target), this._drag.stage.start = stage, this._drag.stage.current = stage, this._drag.pointer = this.pointer(event), $(document).on("mouseup.owl.core touchend.owl.core", $.proxy(this.onDragEnd, this)), $(document).one("mousemove.owl.core touchmove.owl.core", $.proxy(function (event) {
            var delta = this.difference(this._drag.pointer, this.pointer(event));
            $(document).on("mousemove.owl.core touchmove.owl.core", $.proxy(this.onDragMove, this)), Math.abs(delta.x) < Math.abs(delta.y) && this.is("valid") || (event.preventDefault(), this.enter("dragging"), this.trigger("drag"))
        }, this)))
    }, Owl.prototype.onDragMove = function (event) {
        var minimum = null, maximum = null, pull = null, delta = this.difference(this._drag.pointer, this.pointer(event)), stage = this.difference(this._drag.stage.start, delta);
        this.is("dragging") && (event.preventDefault(), this.settings.loop ? (minimum = this.coordinates(this.minimum()), maximum = this.coordinates(this.maximum() + 1) - minimum, stage.x = ((stage.x - minimum) % maximum + maximum) % maximum + minimum) : (minimum = this.settings.rtl ? this.coordinates(this.maximum()) : this.coordinates(this.minimum()), maximum = this.settings.rtl ? this.coordinates(this.minimum()) : this.coordinates(this.maximum()), pull = this.settings.pullDrag ? -1 * delta.x / 5 : 0, stage.x = Math.max(Math.min(stage.x, minimum + pull), maximum + pull)), this._drag.stage.current = stage, this.animate(stage.x))
    }, Owl.prototype.onDragEnd = function (event) {
        var delta = this.difference(this._drag.pointer, this.pointer(event)), stage = this._drag.stage.current, direction = delta.x > 0 ^ this.settings.rtl ? "left" : "right";
        $(document).off(".owl.core"), this.$element.removeClass(this.options.grabClass), (0 !== delta.x && this.is("dragging") || !this.is("valid")) && (this.speed(this.settings.dragEndSpeed || this.settings.smartSpeed), this.current(this.closest(stage.x, 0 !== delta.x ? direction : this._drag.direction)), this.invalidate("position"), this.update(), this._drag.direction = direction, (Math.abs(delta.x) > 3 || (new Date).getTime() - this._drag.time > 300) && this._drag.target.one("click.owl.core", function () {
            return !1
        })), this.is("dragging") && (this.leave("dragging"), this.trigger("dragged"))
    }, Owl.prototype.closest = function (coordinate, direction) {
        var position = -1, pull = 30, width = this.width(), coordinates = this.coordinates();
        return this.settings.freeDrag || $.each(coordinates, $.proxy(function (index, value) {
            return "left" === direction && coordinate > value - pull && value + pull > coordinate ? position = index : "right" === direction && coordinate > value - width - pull && value - width + pull > coordinate ? position = index + 1 : this.op(coordinate, "<", value) && this.op(coordinate, ">", coordinates[index + 1] || value - width) && (position = "left" === direction ? index + 1 : index), -1 === position
        }, this)), this.settings.loop || (this.op(coordinate, ">", coordinates[this.minimum()]) ? position = coordinate = this.minimum() : this.op(coordinate, "<", coordinates[this.maximum()]) && (position = coordinate = this.maximum())), position
    }, Owl.prototype.animate = function (coordinate) {
        var animate = this.speed() > 0;
        this.is("animating") && this.onTransitionEnd(), animate && (this.enter("animating"), this.trigger("translate")), $.support.transform3d && $.support.transition ? this.$stage.css({
                transform: "translate3d(" + coordinate + "px,0px,0px)",
                transition: this.speed() / 1e3 + "s"
            }) : animate ? this.$stage.animate({left: coordinate + "px"}, this.speed(), this.settings.fallbackEasing, $.proxy(this.onTransitionEnd, this)) : this.$stage.css({left: coordinate + "px"})
    }, Owl.prototype.is = function (state) {
        return this._states.current[state] && this._states.current[state] > 0
    }, Owl.prototype.current = function (position) {
        if (position === undefined)return this._current;
        if (0 === this._items.length)return undefined;
        if (position = this.normalize(position), this._current !== position) {
            var event = this.trigger("change", {property: {name: "position", value: position}});
            event.data !== undefined && (position = this.normalize(event.data)), this._current = position, this.invalidate("position"), this.trigger("changed", {
                property: {
                    name: "position",
                    value: this._current
                }
            })
        }
        return this._current
    }, Owl.prototype.invalidate = function (part) {
        return "string" === $.type(part) && (this._invalidated[part] = !0, this.is("valid") && this.leave("valid")), $.map(this._invalidated, function (v, i) {
            return i
        })
    }, Owl.prototype.reset = function (position) {
        position = this.normalize(position), position !== undefined && (this._speed = 0, this._current = position, this.suppress(["translate", "translated"]), this.animate(this.coordinates(position)), this.release(["translate", "translated"]))
    }, Owl.prototype.normalize = function (position, relative) {
        var n = this._items.length, m = relative ? 0 : this._clones.length;
        return !this.isNumeric(position) || 1 > n ? position = undefined : (0 > position || position >= n + m) && (position = ((position - m / 2) % n + n) % n + m / 2), position
    }, Owl.prototype.relative = function (position) {
        return position -= this._clones.length / 2, this.normalize(position, !0)
    }, Owl.prototype.maximum = function (relative) {
        var iterator, reciprocalItemsWidth, elementWidth, settings = this.settings, maximum = this._coordinates.length;
        if (settings.loop) maximum = this._clones.length / 2 + this._items.length - 1; else if (settings.autoWidth || settings.merge) {
            for (iterator = this._items.length, reciprocalItemsWidth = this._items[--iterator].width(), elementWidth = this.$element.width(); iterator-- && (reciprocalItemsWidth += this._items[iterator].width() + this.settings.margin, !(reciprocalItemsWidth > elementWidth)););
            maximum = iterator + 1
        } else maximum = settings.center ? this._items.length - 1 : this._items.length - settings.items;
        return relative && (maximum -= this._clones.length / 2), Math.max(maximum, 0)
    }, Owl.prototype.minimum = function (relative) {
        return relative ? 0 : this._clones.length / 2
    }, Owl.prototype.items = function (position) {
        return position === undefined ? this._items.slice() : (position = this.normalize(position, !0), this._items[position])
    }, Owl.prototype.mergers = function (position) {
        return position === undefined ? this._mergers.slice() : (position = this.normalize(position, !0), this._mergers[position])
    }, Owl.prototype.clones = function (position) {
        var odd = this._clones.length / 2, even = odd + this._items.length, map = function (index) {
            return index % 2 === 0 ? even + index / 2 : odd - (index + 1) / 2
        };
        return position === undefined ? $.map(this._clones, function (v, i) {
                return map(i)
            }) : $.map(this._clones, function (v, i) {
                return v === position ? map(i) : null
            })
    }, Owl.prototype.speed = function (speed) {
        return speed !== undefined && (this._speed = speed), this._speed
    }, Owl.prototype.coordinates = function (position) {
        var coordinate, multiplier = 1, newPosition = position - 1;
        return position === undefined ? $.map(this._coordinates, $.proxy(function (coordinate, index) {
                return this.coordinates(index)
            }, this)) : (this.settings.center ? (this.settings.rtl && (multiplier = -1, newPosition = position + 1), coordinate = this._coordinates[position], coordinate += (this.width() - coordinate + (this._coordinates[newPosition] || 0)) / 2 * multiplier) : coordinate = this._coordinates[newPosition] || 0, coordinate = Math.ceil(coordinate))
    }, Owl.prototype.duration = function (from, to, factor) {
        return 0 === factor ? 0 : Math.min(Math.max(Math.abs(to - from), 1), 6) * Math.abs(factor || this.settings.smartSpeed)
    }, Owl.prototype.to = function (position, speed) {
        var current = this.current(), revert = null, distance = position - this.relative(current), direction = (distance > 0) - (0 > distance), items = this._items.length, minimum = this.minimum(), maximum = this.maximum();
        this.settings.loop ? (!this.settings.rewind && Math.abs(distance) > items / 2 && (distance += -1 * direction * items), position = current + distance, revert = ((position - minimum) % items + items) % items + minimum, revert !== position && maximum >= revert - distance && revert - distance > 0 && (current = revert - distance, position = revert, this.reset(current))) : this.settings.rewind ? (maximum += 1, position = (position % maximum + maximum) % maximum) : position = Math.max(minimum, Math.min(maximum, position)), this.speed(this.duration(current, position, speed)), this.current(position), this.$element.is(":visible") && this.update()
    }, Owl.prototype.next = function (speed) {
        speed = speed || !1, this.to(this.relative(this.current()) + 1, speed)
    }, Owl.prototype.prev = function (speed) {
        speed = speed || !1, this.to(this.relative(this.current()) - 1, speed)
    }, Owl.prototype.onTransitionEnd = function (event) {
        return event !== undefined && (event.stopPropagation(), (event.target || event.srcElement || event.originalTarget) !== this.$stage.get(0)) ? !1 : (this.leave("animating"), void this.trigger("translated"))
    }, Owl.prototype.viewport = function () {
        var width;
        if (this.options.responsiveBaseElement !== window) width = $(this.options.responsiveBaseElement).width(); else if (window.innerWidth) width = window.innerWidth; else {
            if (!document.documentElement || !document.documentElement.clientWidth)throw"Can not detect viewport width.";
            width = document.documentElement.clientWidth
        }
        return width
    }, Owl.prototype.replace = function (content) {
        this.$stage.empty(), this._items = [], content && (content = content instanceof jQuery ? content : $(content)), this.settings.nestedItemSelector && (content = content.find("." + this.settings.nestedItemSelector)), content.filter(function () {
            return 1 === this.nodeType
        }).each($.proxy(function (index, item) {
            item = this.prepare(item), this.$stage.append(item), this._items.push(item), this._mergers.push(1 * item.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1)
        }, this)), this.reset(this.isNumeric(this.settings.startPosition) ? this.settings.startPosition : 0), this.invalidate("items")
    }, Owl.prototype.add = function (content, position) {
        var current = this.relative(this._current);
        position = position === undefined ? this._items.length : this.normalize(position, !0), content = content instanceof jQuery ? content : $(content), this.trigger("add", {
            content: content,
            position: position
        }), content = this.prepare(content), 0 === this._items.length || position === this._items.length ? (0 === this._items.length && this.$stage.append(content), 0 !== this._items.length && this._items[position - 1].after(content), this._items.push(content), this._mergers.push(1 * content.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1)) : (this._items[position].before(content), this._items.splice(position, 0, content), this._mergers.splice(position, 0, 1 * content.find("[data-merge]").addBack("[data-merge]").attr("data-merge") || 1)), this._items[current] && this.reset(this._items[current].index()), this.invalidate("items"), this.trigger("added", {
            content: content,
            position: position
        })
    }, Owl.prototype.remove = function (position) {
        position = this.normalize(position, !0), position !== undefined && (this.trigger("remove", {
            content: this._items[position],
            position: position
        }), this._items[position].remove(), this._items.splice(position, 1), this._mergers.splice(position, 1), this.invalidate("items"), this.trigger("removed", {
            content: null,
            position: position
        }))
    }, Owl.prototype.preloadAutoWidthImages = function (images) {
        images.each($.proxy(function (i, element) {
            this.enter("pre-loading"), element = $(element), $(new Image).one("load", $.proxy(function (e) {
                element.attr("src", e.target.src), element.css("opacity", 1), this.leave("pre-loading"), !this.is("pre-loading") && !this.is("initializing") && this.refresh()
            }, this)).attr("src", element.attr("src") || element.attr("data-src") || element.attr("data-src-retina"))
        }, this))
    }, Owl.prototype.destroy = function () {
        this.$element.off(".owl.core"), this.$stage.off(".owl.core"), $(document).off(".owl.core"), this.settings.responsive !== !1 && (window.clearTimeout(this.resizeTimer), this.off(window, "resize", this._handlers.onThrottledResize));
        for (var i in this._plugins)this._plugins[i].destroy();
        this.$stage.children(".cloned").remove(), this.$stage.unwrap(), this.$stage.children().contents().unwrap(), this.$stage.children().unwrap(), this.$element.removeClass(this.options.refreshClass).removeClass(this.options.loadingClass).removeClass(this.options.loadedClass).removeClass(this.options.rtlClass).removeClass(this.options.dragClass).removeClass(this.options.grabClass).attr("class", this.$element.attr("class").replace(new RegExp(this.options.responsiveClass + "-\\S+\\s", "g"), "")).removeData("owl.carousel")
    }, Owl.prototype.op = function (a, o, b) {
        var rtl = this.settings.rtl;
        switch (o) {
            case"<":
                return rtl ? a > b : b > a;
            case">":
                return rtl ? b > a : a > b;
            case">=":
                return rtl ? b >= a : a >= b;
            case"<=":
                return rtl ? a >= b : b >= a
        }
    }, Owl.prototype.on = function (element, event, listener, capture) {
        element.addEventListener ? element.addEventListener(event, listener, capture) : element.attachEvent && element.attachEvent("on" + event, listener)
    }, Owl.prototype.off = function (element, event, listener, capture) {
        element.removeEventListener ? element.removeEventListener(event, listener, capture) : element.detachEvent && element.detachEvent("on" + event, listener)
    }, Owl.prototype.trigger = function (name, data, namespace, state, enter) {
        var status = {
            item: {
                count: this._items.length,
                index: this.current()
            }
        }, handler = $.camelCase($.grep(["on", name, namespace], function (v) {
            return v
        }).join("-").toLowerCase()), event = $.Event([name, "owl", namespace || "carousel"].join(".").toLowerCase(), $.extend({relatedTarget: this}, status, data));
        return this._supress[name] || ($.each(this._plugins, function (name, plugin) {
            plugin.onTrigger && plugin.onTrigger(event)
        }), this.register({
            type: Owl.Type.Event,
            name: name
        }), this.$element.trigger(event), this.settings && "function" == typeof this.settings[handler] && this.settings[handler].call(this, event)), event
    }, Owl.prototype.enter = function (name) {
        $.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {
            this._states.current[name] === undefined && (this._states.current[name] = 0), this._states.current[name]++
        }, this))
    }, Owl.prototype.leave = function (name) {
        $.each([name].concat(this._states.tags[name] || []), $.proxy(function (i, name) {
            this._states.current[name]--
        }, this))
    }, Owl.prototype.register = function (object) {
        if (object.type === Owl.Type.Event) {
            if ($.event.special[object.name] || ($.event.special[object.name] = {}), !$.event.special[object.name].owl) {
                var _default = $.event.special[object.name]._default;
                $.event.special[object.name]._default = function (e) {
                    return !_default || !_default.apply || e.namespace && -1 !== e.namespace.indexOf("owl") ? e.namespace && e.namespace.indexOf("owl") > -1 : _default.apply(this, arguments)
                }, $.event.special[object.name].owl = !0
            }
        } else object.type === Owl.Type.State && (this._states.tags[object.name] ? this._states.tags[object.name] = this._states.tags[object.name].concat(object.tags) : this._states.tags[object.name] = object.tags, this._states.tags[object.name] = $.grep(this._states.tags[object.name], $.proxy(function (tag, i) {
            return $.inArray(tag, this._states.tags[object.name]) === i
        }, this)))
    }, Owl.prototype.suppress = function (events) {
        $.each(events, $.proxy(function (index, event) {
            this._supress[event] = !0
        }, this))
    }, Owl.prototype.release = function (events) {
        $.each(events, $.proxy(function (index, event) {
            delete this._supress[event]
        }, this))
    }, Owl.prototype.pointer = function (event) {
        var result = {x: null, y: null};
        return event = event.originalEvent || event || window.event, event = event.touches && event.touches.length ? event.touches[0] : event.changedTouches && event.changedTouches.length ? event.changedTouches[0] : event, event.pageX ? (result.x = event.pageX, result.y = event.pageY) : (result.x = event.clientX, result.y = event.clientY), result
    }, Owl.prototype.isNumeric = function (number) {
        return !isNaN(parseFloat(number))
    }, Owl.prototype.difference = function (first, second) {
        return {x: first.x - second.x, y: first.y - second.y}
    }, $.fn.owlCarousel = function (option) {
        var args = Array.prototype.slice.call(arguments, 1);
        return this.each(function () {
            var $this = $(this), data = $this.data("owl.carousel");
            data || (data = new Owl(this, "object" == typeof option && option), $this.data("owl.carousel", data), $.each(["next", "prev", "to", "destroy", "refresh", "replace", "add", "remove"], function (i, event) {
                data.register({
                    type: Owl.Type.Event,
                    name: event
                }), data.$element.on(event + ".owl.carousel.core", $.proxy(function (e) {
                    e.namespace && e.relatedTarget !== this && (this.suppress([event]), data[event].apply(this, [].slice.call(arguments, 1)), this.release([event]))
                }, data))
            })), "string" == typeof option && "_" !== option.charAt(0) && data[option].apply(data, args)
        })
    }, $.fn.owlCarousel.Constructor = Owl
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
    var AutoRefresh = function (carousel) {
        this._core = carousel, this._interval = null, this._visible = null, this._handlers = {
            "initialized.owl.carousel": $.proxy(function (e) {
                e.namespace && this._core.settings.autoRefresh && this.watch()
            }, this)
        }, this._core.options = $.extend({}, AutoRefresh.Defaults, this._core.options), this._core.$element.on(this._handlers)
    };
    AutoRefresh.Defaults = {autoRefresh: !0, autoRefreshInterval: 500}, AutoRefresh.prototype.watch = function () {
        this._interval || (this._visible = this._core.$element.is(":visible"), this._interval = window.setInterval($.proxy(this.refresh, this), this._core.settings.autoRefreshInterval))
    }, AutoRefresh.prototype.refresh = function () {
        this._core.$element.is(":visible") !== this._visible && (this._visible = !this._visible, this._core.$element.toggleClass("owl-hidden", !this._visible), this._visible && this._core.invalidate("width") && this._core.refresh())
    }, AutoRefresh.prototype.destroy = function () {
        var handler, property;
        window.clearInterval(this._interval);
        for (handler in this._handlers)this._core.$element.off(handler, this._handlers[handler]);
        for (property in Object.getOwnPropertyNames(this))"function" != typeof this[property] && (this[property] = null)
    }, $.fn.owlCarousel.Constructor.Plugins.AutoRefresh = AutoRefresh
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
    var Lazy = function (carousel) {
        this._core = carousel, this._loaded = [], this._handlers = {
            "initialized.owl.carousel change.owl.carousel resized.owl.carousel": $.proxy(function (e) {
                if (e.namespace && this._core.settings && this._core.settings.lazyLoad && (e.property && "position" == e.property.name || "initialized" == e.type))for (var settings = this._core.settings, n = settings.center && Math.ceil(settings.items / 2) || settings.items, i = settings.center && -1 * n || 0, position = (e.property && e.property.value !== undefined ? e.property.value : this._core.current()) + i, clones = this._core.clones().length, load = $.proxy(function (i, v) {
                    this.load(v)
                }, this); i++ < n;)this.load(clones / 2 + this._core.relative(position)), clones && $.each(this._core.clones(this._core.relative(position)), load), position++
            }, this)
        }, this._core.options = $.extend({}, Lazy.Defaults, this._core.options), this._core.$element.on(this._handlers)
    };
    Lazy.Defaults = {lazyLoad: !1}, Lazy.prototype.load = function (position) {
        var $item = this._core.$stage.children().eq(position), $elements = $item && $item.find(".owl-lazy");
        !$elements || $.inArray($item.get(0), this._loaded) > -1 || ($elements.each($.proxy(function (index, element) {
            var image, $element = $(element), url = window.devicePixelRatio > 1 && $element.attr("data-src-retina") || $element.attr("data-src");
            this._core.trigger("load", {
                element: $element,
                url: url
            }, "lazy"), $element.is("img") ? $element.one("load.owl.lazy", $.proxy(function () {
                    $element.css("opacity", 1), this._core.trigger("loaded", {element: $element, url: url}, "lazy")
                }, this)).attr("src", url) : (image = new Image, image.onload = $.proxy(function () {
                    $element.css({
                        "background-image": "url(" + url + ")",
                        opacity: "1"
                    }), this._core.trigger("loaded", {element: $element, url: url}, "lazy")
                }, this), image.src = url)
        }, this)), this._loaded.push($item.get(0)))
    }, Lazy.prototype.destroy = function () {
        var handler, property;
        for (handler in this.handlers)this._core.$element.off(handler, this.handlers[handler]);
        for (property in Object.getOwnPropertyNames(this))"function" != typeof this[property] && (this[property] = null)
    }, $.fn.owlCarousel.Constructor.Plugins.Lazy = Lazy
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
    var AutoHeight = function (carousel) {
        this._core = carousel, this._handlers = {
            "initialized.owl.carousel refreshed.owl.carousel": $.proxy(function (e) {
                e.namespace && this._core.settings.autoHeight && this.update()
            }, this), "changed.owl.carousel": $.proxy(function (e) {
                e.namespace && this._core.settings.autoHeight && "position" == e.property.name && this.update()
            }, this), "loaded.owl.lazy": $.proxy(function (e) {
                e.namespace && this._core.settings.autoHeight && e.element.closest("." + this._core.settings.itemClass).index() === this._core.current() && this.update()
            }, this)
        }, this._core.options = $.extend({}, AutoHeight.Defaults, this._core.options), this._core.$element.on(this._handlers)
    };
    AutoHeight.Defaults = {autoHeight: !1, autoHeightClass: "owl-height"}, AutoHeight.prototype.update = function () {
        var start = this._core._current, end = start + this._core.settings.items, visible = this._core.$stage.children().toArray().slice(start, end), heights = [], maxheight = 0;
        $.each(visible, function (index, item) {
            heights.push($(item).height())
        }), maxheight = Math.max.apply(null, heights), this._core.$stage.parent().height(maxheight).addClass(this._core.settings.autoHeightClass)
    }, AutoHeight.prototype.destroy = function () {
        var handler, property;
        for (handler in this._handlers)this._core.$element.off(handler, this._handlers[handler]);
        for (property in Object.getOwnPropertyNames(this))"function" != typeof this[property] && (this[property] = null)
    }, $.fn.owlCarousel.Constructor.Plugins.AutoHeight = AutoHeight
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
    var Video = function (carousel) {
        this._core = carousel, this._videos = {}, this._playing = null, this._handlers = {
            "initialized.owl.carousel": $.proxy(function (e) {
                e.namespace && this._core.register({type: "state", name: "playing", tags: ["interacting"]})
            }, this), "resize.owl.carousel": $.proxy(function (e) {
                e.namespace && this._core.settings.video && this.isInFullScreen() && e.preventDefault()
            }, this), "refreshed.owl.carousel": $.proxy(function (e) {
                e.namespace && this._core.is("resizing") && this._core.$stage.find(".cloned .owl-video-frame").remove()
            }, this), "changed.owl.carousel": $.proxy(function (e) {
                e.namespace && "position" === e.property.name && this._playing && this.stop()
            }, this), "prepared.owl.carousel": $.proxy(function (e) {
                if (e.namespace) {
                    var $element = $(e.content).find(".owl-video");
                    $element.length && ($element.css("display", "none"), this.fetch($element, $(e.content)))
                }
            }, this)
        }, this._core.options = $.extend({}, Video.Defaults, this._core.options), this._core.$element.on(this._handlers), this._core.$element.on("click.owl.video", ".owl-video-play-icon", $.proxy(function (e) {
            this.play(e)
        }, this))
    };
    Video.Defaults = {video: !1, videoHeight: !1, videoWidth: !1}, Video.prototype.fetch = function (target, item) {
        var type = function () {
            return target.attr("data-vimeo-id") ? "vimeo" : target.attr("data-vzaar-id") ? "vzaar" : "youtube"
        }(), id = target.attr("data-vimeo-id") || target.attr("data-youtube-id") || target.attr("data-vzaar-id"), width = target.attr("data-width") || this._core.settings.videoWidth, height = target.attr("data-height") || this._core.settings.videoHeight, url = target.attr("href");
        if (!url)throw new Error("Missing video URL.");
        if (id = url.match(/(http:|https:|)\/\/(player.|www.|app.)?(vimeo\.com|youtu(be\.com|\.be|be\.googleapis\.com)|vzaar\.com)\/(video\/|videos\/|embed\/|channels\/.+\/|groups\/.+\/|watch\?v=|v\/)?([A-Za-z0-9._%-]*)(\&\S+)?/), id[3].indexOf("youtu") > -1) type = "youtube"; else if (id[3].indexOf("vimeo") > -1) type = "vimeo"; else {
            if (!(id[3].indexOf("vzaar") > -1))throw new Error("Video URL not supported.");
            type = "vzaar"
        }
        id = id[6], this._videos[url] = {
            type: type,
            id: id,
            width: width,
            height: height
        }, item.attr("data-video", url), this.thumbnail(target, this._videos[url])
    }, Video.prototype.thumbnail = function (target, video) {
        var tnLink, icon, path, dimensions = video.width && video.height ? 'style="width:' + video.width + "px;height:" + video.height + 'px;"' : "", customTn = target.find("img"), srcType = "src", lazyClass = "", settings = this._core.settings, create = function (path) {
            icon = '<div class="owl-video-play-icon"></div>', tnLink = settings.lazyLoad ? '<div class="owl-video-tn ' + lazyClass + '" ' + srcType + '="' + path + '"></div>' : '<div class="owl-video-tn" style="opacity:1;background-image:url(' + path + ')"></div>', target.after(tnLink), target.after(icon)
        };
        return target.wrap('<div class="owl-video-wrapper"' + dimensions + "></div>"), this._core.settings.lazyLoad && (srcType = "data-src", lazyClass = "owl-lazy"), customTn.length ? (create(customTn.attr(srcType)), customTn.remove(), !1) : void("youtube" === video.type ? (path = "//img.youtube.com/vi/" + video.id + "/hqdefault.jpg", create(path)) : "vimeo" === video.type ? $.ajax({
                        type: "GET",
                        url: "//vimeo.com/api/v2/video/" + video.id + ".json",
                        jsonp: "callback",
                        dataType: "jsonp",
                        success: function (data) {
                            path = data[0].thumbnail_large, create(path)
                        }
                    }) : "vzaar" === video.type && $.ajax({
                        type: "GET",
                        url: "//vzaar.com/api/videos/" + video.id + ".json",
                        jsonp: "callback",
                        dataType: "jsonp",
                        success: function (data) {
                            path = data.framegrab_url, create(path)
                        }
                    }))
    }, Video.prototype.stop = function () {
        this._core.trigger("stop", null, "video"), this._playing.find(".owl-video-frame").remove(), this._playing.removeClass("owl-video-playing"), this._playing = null, this._core.leave("playing"), this._core.trigger("stopped", null, "video")
    }, Video.prototype.play = function (event) {
        var html, target = $(event.target), item = target.closest("." + this._core.settings.itemClass), video = this._videos[item.attr("data-video")], width = video.width || "100%", height = video.height || this._core.$stage.height();
        this._playing || (this._core.enter("playing"), this._core.trigger("play", null, "video"), item = this._core.items(this._core.relative(item.index())), this._core.reset(item.index()), "youtube" === video.type ? html = '<iframe width="' + width + '" height="' + height + '" src="//www.youtube.com/embed/' + video.id + "?autoplay=1&v=" + video.id + '" frameborder="0" allowfullscreen></iframe>' : "vimeo" === video.type ? html = '<iframe src="//player.vimeo.com/video/' + video.id + '?autoplay=1" width="' + width + '" height="' + height + '" frameborder="0" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>' : "vzaar" === video.type && (html = '<iframe frameborder="0"height="' + height + '"width="' + width + '" allowfullscreen mozallowfullscreen webkitAllowFullScreen src="//view.vzaar.com/' + video.id + '/player?autoplay=true"></iframe>'),
            $('<div class="owl-video-frame">' + html + "</div>").insertAfter(item.find(".owl-video")), this._playing = item.addClass("owl-video-playing"))
    }, Video.prototype.isInFullScreen = function () {
        var element = document.fullscreenElement || document.mozFullScreenElement || document.webkitFullscreenElement;
        return element && $(element).parent().hasClass("owl-video-frame")
    }, Video.prototype.destroy = function () {
        var handler, property;
        this._core.$element.off("click.owl.video");
        for (handler in this._handlers)this._core.$element.off(handler, this._handlers[handler]);
        for (property in Object.getOwnPropertyNames(this))"function" != typeof this[property] && (this[property] = null)
    }, $.fn.owlCarousel.Constructor.Plugins.Video = Video
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
    var Animate = function (scope) {
        this.core = scope, this.core.options = $.extend({}, Animate.Defaults, this.core.options), this.swapping = !0, this.previous = undefined, this.next = undefined, this.handlers = {
            "change.owl.carousel": $.proxy(function (e) {
                e.namespace && "position" == e.property.name && (this.previous = this.core.current(), this.next = e.property.value)
            }, this), "drag.owl.carousel dragged.owl.carousel translated.owl.carousel": $.proxy(function (e) {
                e.namespace && (this.swapping = "translated" == e.type)
            }, this), "translate.owl.carousel": $.proxy(function (e) {
                e.namespace && this.swapping && (this.core.options.animateOut || this.core.options.animateIn) && this.swap()
            }, this)
        }, this.core.$element.on(this.handlers)
    };
    Animate.Defaults = {animateOut: !1, animateIn: !1}, Animate.prototype.swap = function () {
        if (1 === this.core.settings.items && $.support.animation && $.support.transition) {
            this.core.speed(0);
            var left, clear = $.proxy(this.clear, this), previous = this.core.$stage.children().eq(this.previous), next = this.core.$stage.children().eq(this.next), incoming = this.core.settings.animateIn, outgoing = this.core.settings.animateOut;
            this.core.current() !== this.previous && (outgoing && (left = this.core.coordinates(this.previous) - this.core.coordinates(this.next), previous.one($.support.animation.end, clear).css({left: left + "px"}).addClass("animated owl-animated-out").addClass(outgoing)), incoming && next.one($.support.animation.end, clear).addClass("animated owl-animated-in").addClass(incoming))
        }
    }, Animate.prototype.clear = function (e) {
        $(e.target).css({left: ""}).removeClass("animated owl-animated-out owl-animated-in").removeClass(this.core.settings.animateIn).removeClass(this.core.settings.animateOut), this.core.onTransitionEnd()
    }, Animate.prototype.destroy = function () {
        var handler, property;
        for (handler in this.handlers)this.core.$element.off(handler, this.handlers[handler]);
        for (property in Object.getOwnPropertyNames(this))"function" != typeof this[property] && (this[property] = null)
    }, $.fn.owlCarousel.Constructor.Plugins.Animate = Animate
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
    var Autoplay = function (carousel) {
        this._core = carousel, this._timeout = null, this._paused = !1, this._handlers = {
            "changed.owl.carousel": $.proxy(function (e) {
                e.namespace && "settings" === e.property.name ? this._core.settings.autoplay ? this.play() : this.stop() : e.namespace && "position" === e.property.name && this._core.settings.autoplay && this._setAutoPlayInterval()
            }, this), "initialized.owl.carousel": $.proxy(function (e) {
                e.namespace && this._core.settings.autoplay && this.play()
            }, this), "play.owl.autoplay": $.proxy(function (e, t, s) {
                e.namespace && this.play(t, s)
            }, this), "stop.owl.autoplay": $.proxy(function (e) {
                e.namespace && this.stop()
            }, this), "mouseover.owl.autoplay": $.proxy(function () {
                this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.pause()
            }, this), "mouseleave.owl.autoplay": $.proxy(function () {
                this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.play()
            }, this), "touchstart.owl.core": $.proxy(function () {
                this._core.settings.autoplayHoverPause && this._core.is("rotating") && this.pause()
            }, this), "touchend.owl.core": $.proxy(function () {
                this._core.settings.autoplayHoverPause && this.play()
            }, this)
        }, this._core.$element.on(this._handlers), this._core.options = $.extend({}, Autoplay.Defaults, this._core.options)
    };
    Autoplay.Defaults = {
        autoplay: !1,
        autoplayTimeout: 5e3,
        autoplayHoverPause: !1,
        autoplaySpeed: !1
    }, Autoplay.prototype.play = function (timeout, speed) {
        this._paused = !1, this._core.is("rotating") || (this._core.enter("rotating"), this._setAutoPlayInterval())
    }, Autoplay.prototype._getNextTimeout = function (timeout, speed) {
        return this._timeout && window.clearTimeout(this._timeout), window.setTimeout($.proxy(function () {
            this._paused || this._core.is("busy") || this._core.is("interacting") || document.hidden || this._core.next(speed || this._core.settings.autoplaySpeed)
        }, this), timeout || this._core.settings.autoplayTimeout)
    }, Autoplay.prototype._setAutoPlayInterval = function () {
        this._timeout = this._getNextTimeout()
    }, Autoplay.prototype.stop = function () {
        this._core.is("rotating") && (window.clearTimeout(this._timeout), this._core.leave("rotating"))
    }, Autoplay.prototype.pause = function () {
        this._core.is("rotating") && (this._paused = !0)
    }, Autoplay.prototype.destroy = function () {
        var handler, property;
        this.stop();
        for (handler in this._handlers)this._core.$element.off(handler, this._handlers[handler]);
        for (property in Object.getOwnPropertyNames(this))"function" != typeof this[property] && (this[property] = null)
    }, $.fn.owlCarousel.Constructor.Plugins.autoplay = Autoplay
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
    "use strict";
    var Navigation = function (carousel) {
        this._core = carousel, this._initialized = !1, this._pages = [], this._controls = {}, this._templates = [], this.$element = this._core.$element, this._overrides = {
            next: this._core.next,
            prev: this._core.prev,
            to: this._core.to
        }, this._handlers = {
            "prepared.owl.carousel": $.proxy(function (e) {
                e.namespace && this._core.settings.dotsData && this._templates.push('<div class="' + this._core.settings.dotClass + '">' + $(e.content).find("[data-dot]").addBack("[data-dot]").attr("data-dot") + "</div>")
            }, this), "added.owl.carousel": $.proxy(function (e) {
                e.namespace && this._core.settings.dotsData && this._templates.splice(e.position, 0, this._templates.pop())
            }, this), "remove.owl.carousel": $.proxy(function (e) {
                e.namespace && this._core.settings.dotsData && this._templates.splice(e.position, 1)
            }, this), "changed.owl.carousel": $.proxy(function (e) {
                e.namespace && "position" == e.property.name && this.draw()
            }, this), "initialized.owl.carousel": $.proxy(function (e) {
                e.namespace && !this._initialized && (this._core.trigger("initialize", null, "navigation"), this.initialize(), this.update(), this.draw(), this._initialized = !0, this._core.trigger("initialized", null, "navigation"))
            }, this), "refreshed.owl.carousel": $.proxy(function (e) {
                e.namespace && this._initialized && (this._core.trigger("refresh", null, "navigation"), this.update(), this.draw(), this._core.trigger("refreshed", null, "navigation"))
            }, this)
        }, this._core.options = $.extend({}, Navigation.Defaults, this._core.options), this.$element.on(this._handlers)
    };
    Navigation.Defaults = {
        nav: !1,
        navText: ["prev", "next"],
        navSpeed: !1,
        navElement: "div",
        navContainer: !1,
        navContainerClass: "owl-nav",
        navClass: ["owl-prev", "owl-next"],
        slideBy: 1,
        dotClass: "owl-dot",
        dotsClass: "owl-dots",
        dots: !0,
        dotsEach: !1,
        dotsData: !1,
        dotsSpeed: !1,
        dotsContainer: !1
    }, Navigation.prototype.initialize = function () {
        var override, settings = this._core.settings;
        this._controls.$relative = (settings.navContainer ? $(settings.navContainer) : $("<div>").addClass(settings.navContainerClass).appendTo(this.$element)).addClass("disabled"), this._controls.$previous = $("<" + settings.navElement + ">").addClass(settings.navClass[0]).html(settings.navText[0]).prependTo(this._controls.$relative).on("click", $.proxy(function (e) {
            this.prev(settings.navSpeed)
        }, this)), this._controls.$next = $("<" + settings.navElement + ">").addClass(settings.navClass[1]).html(settings.navText[1]).appendTo(this._controls.$relative).on("click", $.proxy(function (e) {
            this.next(settings.navSpeed)
        }, this)), settings.dotsData || (this._templates = [$("<div>").addClass(settings.dotClass).append($("<span>")).prop("outerHTML")]), this._controls.$absolute = (settings.dotsContainer ? $(settings.dotsContainer) : $("<div>").addClass(settings.dotsClass).appendTo(this.$element)).addClass("disabled"), this._controls.$absolute.on("click", "div", $.proxy(function (e) {
            var index = $(e.target).parent().is(this._controls.$absolute) ? $(e.target).index() : $(e.target).parent().index();
            e.preventDefault(), this.to(index, settings.dotsSpeed)
        }, this));
        for (override in this._overrides)this._core[override] = $.proxy(this[override], this)
    }, Navigation.prototype.destroy = function () {
        var handler, control, property, override;
        for (handler in this._handlers)this.$element.off(handler, this._handlers[handler]);
        for (control in this._controls)this._controls[control].remove();
        for (override in this.overides)this._core[override] = this._overrides[override];
        for (property in Object.getOwnPropertyNames(this))"function" != typeof this[property] && (this[property] = null)
    }, Navigation.prototype.update = function () {
        var i, j, k, lower = this._core.clones().length / 2, upper = lower + this._core.items().length, maximum = this._core.maximum(!0), settings = this._core.settings, size = settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items;
        if ("page" !== settings.slideBy && (settings.slideBy = Math.min(settings.slideBy, settings.items)), settings.dots || "page" == settings.slideBy)for (this._pages = [], i = lower, j = 0, k = 0; upper > i; i++) {
            if (j >= size || 0 === j) {
                if (this._pages.push({
                        start: Math.min(maximum, i - lower),
                        end: i - lower + size - 1
                    }), Math.min(maximum, i - lower) === maximum)break;
                j = 0, ++k
            }
            j += this._core.mergers(this._core.relative(i))
        }
    }, Navigation.prototype.draw = function () {
        var difference, settings = this._core.settings, disabled = this._core.items().length <= settings.items, index = this._core.relative(this._core.current()), loop = settings.loop || settings.rewind;
        this._controls.$relative.toggleClass("disabled", !settings.nav || disabled), settings.nav && (this._controls.$previous.toggleClass("disabled", !loop && index <= this._core.minimum(!0)), this._controls.$next.toggleClass("disabled", !loop && index >= this._core.maximum(!0))), this._controls.$absolute.toggleClass("disabled", !settings.dots || disabled), settings.dots && (difference = this._pages.length - this._controls.$absolute.children().length, settings.dotsData && 0 !== difference ? this._controls.$absolute.html(this._templates.join("")) : difference > 0 ? this._controls.$absolute.append(new Array(difference + 1).join(this._templates[0])) : 0 > difference && this._controls.$absolute.children().slice(difference).remove(), this._controls.$absolute.find(".active").removeClass("active"), this._controls.$absolute.children().eq($.inArray(this.current(), this._pages)).addClass("active"))
    }, Navigation.prototype.onTrigger = function (event) {
        var settings = this._core.settings;
        event.page = {
            index: $.inArray(this.current(), this._pages),
            count: this._pages.length,
            size: settings && (settings.center || settings.autoWidth || settings.dotsData ? 1 : settings.dotsEach || settings.items)
        }
    }, Navigation.prototype.current = function () {
        var current = this._core.relative(this._core.current());
        return $.grep(this._pages, $.proxy(function (page, index) {
            return page.start <= current && page.end >= current
        }, this)).pop()
    }, Navigation.prototype.getPosition = function (successor) {
        var position, length, settings = this._core.settings;
        return "page" == settings.slideBy ? (position = $.inArray(this.current(), this._pages), length = this._pages.length, successor ? ++position : --position, position = this._pages[(position % length + length) % length].start) : (position = this._core.relative(this._core.current()), length = this._core.items().length, successor ? position += settings.slideBy : position -= settings.slideBy), position
    }, Navigation.prototype.next = function (speed) {
        $.proxy(this._overrides.to, this._core)(this.getPosition(!0), speed)
    }, Navigation.prototype.prev = function (speed) {
        $.proxy(this._overrides.to, this._core)(this.getPosition(!1), speed)
    }, Navigation.prototype.to = function (position, speed, standard) {
        var length;
        !standard && this._pages.length ? (length = this._pages.length, $.proxy(this._overrides.to, this._core)(this._pages[(position % length + length) % length].start, speed)) : $.proxy(this._overrides.to, this._core)(position, speed)
    }, $.fn.owlCarousel.Constructor.Plugins.Navigation = Navigation
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
    "use strict";
    var Hash = function (carousel) {
        this._core = carousel, this._hashes = {}, this.$element = this._core.$element, this._handlers = {
            "initialized.owl.carousel": $.proxy(function (e) {
                e.namespace && "URLHash" === this._core.settings.startPosition && $(window).trigger("hashchange.owl.navigation")
            }, this), "prepared.owl.carousel": $.proxy(function (e) {
                if (e.namespace) {
                    var hash = $(e.content).find("[data-hash]").addBack("[data-hash]").attr("data-hash");
                    if (!hash)return;
                    this._hashes[hash] = e.content
                }
            }, this), "changed.owl.carousel": $.proxy(function (e) {
                if (e.namespace && "position" === e.property.name) {
                    var current = this._core.items(this._core.relative(this._core.current())), hash = $.map(this._hashes, function (item, hash) {
                        return item === current ? hash : null
                    }).join();
                    if (!hash || window.location.hash.slice(1) === hash)return;
                    window.location.hash = hash
                }
            }, this)
        }, this._core.options = $.extend({}, Hash.Defaults, this._core.options), this.$element.on(this._handlers), $(window).on("hashchange.owl.navigation", $.proxy(function (e) {
            var hash = window.location.hash.substring(1), items = this._core.$stage.children(), position = this._hashes[hash] && items.index(this._hashes[hash]);
            position !== undefined && position !== this._core.current() && this._core.to(this._core.relative(position), !1, !0)
        }, this))
    };
    Hash.Defaults = {URLhashListener: !1}, Hash.prototype.destroy = function () {
        var handler, property;
        $(window).off("hashchange.owl.navigation");
        for (handler in this._handlers)this._core.$element.off(handler, this._handlers[handler]);
        for (property in Object.getOwnPropertyNames(this))"function" != typeof this[property] && (this[property] = null)
    }, $.fn.owlCarousel.Constructor.Plugins.Hash = Hash
}(window.Zepto || window.jQuery, window, document), function ($, window, document, undefined) {
    function test(property, prefixed) {
        var result = !1, upper = property.charAt(0).toUpperCase() + property.slice(1);
        return $.each((property + " " + prefixes.join(upper + " ") + upper).split(" "), function (i, property) {
            return style[property] !== undefined ? (result = prefixed ? property : !0, !1) : void 0
        }), result
    }

    function prefixed(property) {
        return test(property, !0)
    }

    var style = $("<support>").get(0).style, prefixes = "Webkit Moz O ms".split(" "), events = {
        transition: {
            end: {
                WebkitTransition: "webkitTransitionEnd",
                MozTransition: "transitionend",
                OTransition: "oTransitionEnd",
                transition: "transitionend"
            }
        },
        animation: {
            end: {
                WebkitAnimation: "webkitAnimationEnd",
                MozAnimation: "animationend",
                OAnimation: "oAnimationEnd",
                animation: "animationend"
            }
        }
    }, tests = {
        csstransforms: function () {
            return !!test("transform")
        }, csstransforms3d: function () {
            return !!test("perspective")
        }, csstransitions: function () {
            return !!test("transition")
        }, cssanimations: function () {
            return !!test("animation")
        }
    };
    tests.csstransitions() && ($.support.transition = new String(prefixed("transition")), $.support.transition.end = events.transition.end[$.support.transition]), tests.cssanimations() && ($.support.animation = new String(prefixed("animation")), $.support.animation.end = events.animation.end[$.support.animation]), tests.csstransforms() && ($.support.transform = new String(prefixed("transform")), $.support.transform3d = tests.csstransforms3d())
}(window.Zepto || window.jQuery, window, document), function () {
    "use strict";
    function addLibraryPlugin(lib) {
        lib.fn.swiper = function (params) {
            var firstInstance;
            return lib(this).each(function () {
                var s = new Swiper(this, params);
                firstInstance || (firstInstance = s)
            }), firstInstance
        }
    }

    var Swiper = function (container, params) {
        function isH() {
            return "horizontal" === s.params.direction
        }

        function autoplay() {
            s.autoplayTimeoutId = setTimeout(function () {
                s.params.loop ? (s.fixLoop(), s._slideNext()) : s.isEnd ? params.autoplayStopOnLast ? s.stopAutoplay() : s._slideTo(0) : s._slideNext()
            }, s.params.autoplay)
        }

        function findElementInEvent(e, selector) {
            var el = $(e.target);
            if (!el.is(selector))if ("string" == typeof selector) el = el.parents(selector); else if (selector.nodeType) {
                var found;
                return el.parents().each(function (index, _el) {
                    _el === selector && (found = selector)
                }), found ? selector : void 0
            }
            return 0 === el.length ? void 0 : el[0]
        }

        function initObserver(target, options) {
            options = options || {};
            var ObserverFunc = window.MutationObserver || window.WebkitMutationObserver, observer = new ObserverFunc(function (mutations) {
                mutations.forEach(function (mutation) {
                    s.onResize(!0), s.emit("onObserverUpdate", s, mutation)
                })
            });
            observer.observe(target, {
                attributes: "undefined" == typeof options.attributes ? !0 : options.attributes,
                childList: "undefined" == typeof options.childList ? !0 : options.childList,
                characterData: "undefined" == typeof options.characterData ? !0 : options.characterData
            }), s.observers.push(observer)
        }

        function handleKeyboard(e) {
            e.originalEvent && (e = e.originalEvent);
            var kc = e.keyCode || e.charCode;
            if (!s.params.allowSwipeToNext && (isH() && 39 === kc || !isH() && 40 === kc))return !1;
            if (!s.params.allowSwipeToPrev && (isH() && 37 === kc || !isH() && 38 === kc))return !1;
            if (!(e.shiftKey || e.altKey || e.ctrlKey || e.metaKey || document.activeElement && document.activeElement.nodeName && ("input" === document.activeElement.nodeName.toLowerCase() || "textarea" === document.activeElement.nodeName.toLowerCase()))) {
                if (37 === kc || 39 === kc || 38 === kc || 40 === kc) {
                    var inView = !1;
                    if (s.container.parents(".swiper-slide").length > 0 && 0 === s.container.parents(".swiper-slide-active").length)return;
                    var windowScroll = {
                        left: window.pageXOffset,
                        top: window.pageYOffset
                    }, windowWidth = window.innerWidth, windowHeight = window.innerHeight, swiperOffset = s.container.offset();
                    s.rtl && (swiperOffset.left = swiperOffset.left - s.container[0].scrollLeft);
                    for (var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + s.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + s.height], [swiperOffset.left + s.width, swiperOffset.top + s.height]], i = 0; i < swiperCoord.length; i++) {
                        var point = swiperCoord[i];
                        point[0] >= windowScroll.left && point[0] <= windowScroll.left + windowWidth && point[1] >= windowScroll.top && point[1] <= windowScroll.top + windowHeight && (inView = !0)
                    }
                    if (!inView)return
                }
                isH() ? ((37 === kc || 39 === kc) && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), (39 === kc && !s.rtl || 37 === kc && s.rtl) && s.slideNext(), (37 === kc && !s.rtl || 39 === kc && s.rtl) && s.slidePrev()) : ((38 === kc || 40 === kc) && (e.preventDefault ? e.preventDefault() : e.returnValue = !1), 40 === kc && s.slideNext(), 38 === kc && s.slidePrev())
            }
        }

        function handleMousewheel(e) {
            e.originalEvent && (e = e.originalEvent);
            var we = s.mousewheel.event, delta = 0;
            if (e.detail) delta = -e.detail; else if ("mousewheel" === we)if (s.params.mousewheelForceToAxis)if (isH()) {
                if (!(Math.abs(e.wheelDeltaX) > Math.abs(e.wheelDeltaY)))return;
                delta = e.wheelDeltaX
            } else {
                if (!(Math.abs(e.wheelDeltaY) > Math.abs(e.wheelDeltaX)))return;
                delta = e.wheelDeltaY
            } else delta = e.wheelDelta; else if ("DOMMouseScroll" === we) delta = -e.detail; else if ("wheel" === we)if (s.params.mousewheelForceToAxis)if (isH()) {
                if (!(Math.abs(e.deltaX) > Math.abs(e.deltaY)))return;
                delta = -e.deltaX
            } else {
                if (!(Math.abs(e.deltaY) > Math.abs(e.deltaX)))return;
                delta = -e.deltaY
            } else delta = Math.abs(e.deltaX) > Math.abs(e.deltaY) ? -e.deltaX : -e.deltaY;
            if (s.params.mousewheelInvert && (delta = -delta), s.params.freeMode) {
                var position = s.getWrapperTranslate() + delta;
                if (position > 0 && (position = 0), position < s.maxTranslate() && (position = s.maxTranslate()), s.setWrapperTransition(0), s.setWrapperTranslate(position), s.updateProgress(), s.updateActiveIndex(), s.params.freeModeSticky && (clearTimeout(s.mousewheel.timeout), s.mousewheel.timeout = setTimeout(function () {
                        s.slideReset()
                    }, 300)), 0 === position || position === s.maxTranslate())return
            } else {
                if ((new window.Date).getTime() - s.mousewheel.lastScrollTime > 60)if (0 > delta)if (s.isEnd) {
                    if (s.params.mousewheelReleaseOnEdges)return !0
                } else s.slideNext(); else if (s.isBeginning) {
                    if (s.params.mousewheelReleaseOnEdges)return !0
                } else s.slidePrev();
                s.mousewheel.lastScrollTime = (new window.Date).getTime()
            }
            return s.params.autoplay && s.stopAutoplay(), e.preventDefault ? e.preventDefault() : e.returnValue = !1, !1
        }

        function setParallaxTransform(el, progress) {
            el = $(el);
            var p, pX, pY;
            p = el.attr("data-swiper-parallax") || "0", pX = el.attr("data-swiper-parallax-x"), pY = el.attr("data-swiper-parallax-y"), pX || pY ? (pX = pX || "0", pY = pY || "0") : isH() ? (pX = p, pY = "0") : (pY = p, pX = "0"), pX = pX.indexOf("%") >= 0 ? parseInt(pX, 10) * progress + "%" : pX * progress + "px", pY = pY.indexOf("%") >= 0 ? parseInt(pY, 10) * progress + "%" : pY * progress + "px", el.transform("translate3d(" + pX + ", " + pY + ",0px)")
        }

        function normalizeEventName(eventName) {
            return 0 !== eventName.indexOf("on") && (eventName = eventName[0] !== eventName[0].toUpperCase() ? "on" + eventName[0].toUpperCase() + eventName.substring(1) : "on" + eventName), eventName
        }

        if (!(this instanceof Swiper))return new Swiper(container, params);
        var defaults = {
            direction: "horizontal",
            touchEventsTarget: "container",
            initialSlide: 0,
            speed: 300,
            autoplay: !1,
            autoplayDisableOnInteraction: !0,
            freeMode: !1,
            freeModeMomentum: !0,
            freeModeMomentumRatio: 1,
            freeModeMomentumBounce: !0,
            freeModeMomentumBounceRatio: 1,
            freeModeSticky: !1,
            setWrapperSize: !1,
            virtualTranslate: !1,
            effect: "slide",
            coverflow: {rotate: 50, stretch: 0, depth: 100, modifier: 1, slideShadows: !0},
            cube: {slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94},
            fade: {crossFade: !1},
            parallax: !1,
            scrollbar: null,
            scrollbarHide: !0,
            keyboardControl: !1,
            mousewheelControl: !1,
            mousewheelReleaseOnEdges: !1,
            mousewheelInvert: !1,
            mousewheelForceToAxis: !1,
            hashnav: !1,
            spaceBetween: 0,
            slidesPerView: 1,
            slidesPerColumn: 1,
            slidesPerColumnFill: "column",
            slidesPerGroup: 1,
            centeredSlides: !1,
            touchRatio: 1,
            touchAngle: 45,
            simulateTouch: !0,
            shortSwipes: !0,
            longSwipes: !0,
            longSwipesRatio: .5,
            longSwipesMs: 300,
            followFinger: !0,
            onlyExternal: !1,
            threshold: 0,
            touchMoveStopPropagation: !0,
            pagination: null,
            paginationClickable: !1,
            paginationHide: !1,
            paginationBulletRender: null,
            resistance: !0,
            resistanceRatio: .85,
            nextButton: null,
            prevButton: null,
            watchSlidesProgress: !1,
            watchSlidesVisibility: !1,
            grabCursor: !1,
            preventClicks: !0,
            preventClicksPropagation: !0,
            slideToClickedSlide: !1,
            lazyLoading: !1,
            lazyLoadingInPrevNext: !1,
            lazyLoadingOnTransitionStart: !1,
            preloadImages: !0,
            updateOnImagesReady: !0,
            loop: !1,
            loopAdditionalSlides: 0,
            loopedSlides: null,
            control: void 0,
            controlInverse: !1,
            allowSwipeToPrev: !0,
            allowSwipeToNext: !0,
            swipeHandler: null,
            noSwiping: !0,
            noSwipingClass: "swiper-no-swiping",
            slideClass: "swiper-slide",
            slideActiveClass: "swiper-slide-active",
            slideVisibleClass: "swiper-slide-visible",
            slideDuplicateClass: "swiper-slide-duplicate",
            slideNextClass: "swiper-slide-next",
            slidePrevClass: "swiper-slide-prev",
            wrapperClass: "swiper-wrapper",
            bulletClass: "swiper-pagination-bullet",
            bulletActiveClass: "swiper-pagination-bullet-active",
            buttonDisabledClass: "swiper-button-disabled",
            paginationHiddenClass: "swiper-pagination-hidden",
            observer: !1,
            observeParents: !1,
            a11y: !1,
            prevSlideMessage: "Previous slide",
            nextSlideMessage: "Next slide",
            firstSlideMessage: "This is the first slide",
            lastSlideMessage: "This is the last slide",
            runCallbacksOnInit: !0
        }, initialVirtualTranslate = params && params.virtualTranslate;
        params = params || {};
        for (var def in defaults)if ("undefined" == typeof params[def]) params[def] = defaults[def]; else if ("object" == typeof params[def])for (var deepDef in defaults[def])"undefined" == typeof params[def][deepDef] && (params[def][deepDef] = defaults[def][deepDef]);
        var s = this;
        s.version = "3.0.8", s.params = params, s.classNames = [];
        var $;
        if ($ = "undefined" == typeof Dom7 ? window.Dom7 || window.Zepto || window.jQuery : Dom7, $ && (s.$ = $, s.container = $(container), 0 !== s.container.length)) {
            if (s.container.length > 1)return void s.container.each(function () {
                new Swiper(this, params)
            });
            s.container[0].swiper = s, s.container.data("swiper", s), s.classNames.push("swiper-container-" + s.params.direction), s.params.freeMode && s.classNames.push("swiper-container-free-mode"), s.support.flexbox || (s.classNames.push("swiper-container-no-flexbox"), s.params.slidesPerColumn = 1), (s.params.parallax || s.params.watchSlidesVisibility) && (s.params.watchSlidesProgress = !0), ["cube", "coverflow"].indexOf(s.params.effect) >= 0 && (s.support.transforms3d ? (s.params.watchSlidesProgress = !0, s.classNames.push("swiper-container-3d")) : s.params.effect = "slide"), "slide" !== s.params.effect && s.classNames.push("swiper-container-" + s.params.effect), "cube" === s.params.effect && (s.params.resistanceRatio = 0, s.params.slidesPerView = 1, s.params.slidesPerColumn = 1, s.params.slidesPerGroup = 1, s.params.centeredSlides = !1, s.params.spaceBetween = 0, s.params.virtualTranslate = !0, s.params.setWrapperSize = !1), "fade" === s.params.effect && (s.params.slidesPerView = 1, s.params.slidesPerColumn = 1, s.params.slidesPerGroup = 1, s.params.watchSlidesProgress = !0, s.params.spaceBetween = 0, "undefined" == typeof initialVirtualTranslate && (s.params.virtualTranslate = !0)), s.params.grabCursor && s.support.touch && (s.params.grabCursor = !1), s.wrapper = s.container.children("." + s.params.wrapperClass), s.params.pagination && (s.paginationContainer = $(s.params.pagination), s.params.paginationClickable && s.paginationContainer.addClass("swiper-pagination-clickable")), s.rtl = isH() && ("rtl" === s.container[0].dir.toLowerCase() || "rtl" === s.container.css("direction")), s.rtl && s.classNames.push("swiper-container-rtl"), s.rtl && (s.wrongRTL = "-webkit-box" === s.wrapper.css("display")), s.params.slidesPerColumn > 1 && s.classNames.push("swiper-container-multirow"), s.device.android && s.classNames.push("swiper-container-android"), s.container.addClass(s.classNames.join(" ")), s.translate = 0, s.progress = 0, s.velocity = 0, s.lockSwipeToNext = function () {
                s.params.allowSwipeToNext = !1
            }, s.lockSwipeToPrev = function () {
                s.params.allowSwipeToPrev = !1
            }, s.lockSwipes = function () {
                s.params.allowSwipeToNext = s.params.allowSwipeToPrev = !1
            }, s.unlockSwipeToNext = function () {
                s.params.allowSwipeToNext = !0
            }, s.unlockSwipeToPrev = function () {
                s.params.allowSwipeToPrev = !0
            }, s.unlockSwipes = function () {
                s.params.allowSwipeToNext = s.params.allowSwipeToPrev = !0
            }, s.params.grabCursor && (s.container[0].style.cursor = "move", s.container[0].style.cursor = "-webkit-grab", s.container[0].style.cursor = "-moz-grab", s.container[0].style.cursor = "grab"), s.imagesToLoad = [], s.imagesLoaded = 0, s.loadImage = function (imgElement, src, checkForComplete, callback) {
                function onReady() {
                    callback && callback()
                }

                var image;
                imgElement.complete && checkForComplete ? onReady() : src ? (image = new window.Image, image.onload = onReady, image.onerror = onReady, image.src = src) : onReady()
            }, s.preloadImages = function () {
                function _onReady() {
                    "undefined" != typeof s && null !== s && (void 0 !== s.imagesLoaded && s.imagesLoaded++, s.imagesLoaded === s.imagesToLoad.length && (s.params.updateOnImagesReady && s.update(), s.emit("onImagesReady", s)))
                }

                s.imagesToLoad = s.container.find("img");
                for (var i = 0; i < s.imagesToLoad.length; i++)s.loadImage(s.imagesToLoad[i], s.imagesToLoad[i].currentSrc || s.imagesToLoad[i].getAttribute("src"), !0, _onReady)
            }, s.autoplayTimeoutId = void 0, s.autoplaying = !1, s.autoplayPaused = !1, s.startAutoplay = function () {
                return "undefined" != typeof s.autoplayTimeoutId ? !1 : s.params.autoplay ? s.autoplaying ? !1 : (s.autoplaying = !0, s.emit("onAutoplayStart", s), void autoplay()) : !1
            }, s.stopAutoplay = function (internal) {
                s.autoplayTimeoutId && (s.autoplayTimeoutId && clearTimeout(s.autoplayTimeoutId), s.autoplaying = !1, s.autoplayTimeoutId = void 0, s.emit("onAutoplayStop", s))
            }, s.pauseAutoplay = function (speed) {
                s.autoplayPaused || (s.autoplayTimeoutId && clearTimeout(s.autoplayTimeoutId), s.autoplayPaused = !0, 0 === speed ? (s.autoplayPaused = !1, autoplay()) : s.wrapper.transitionEnd(function () {
                        s && (s.autoplayPaused = !1, s.autoplaying ? autoplay() : s.stopAutoplay())
                    }))
            }, s.minTranslate = function () {
                return -s.snapGrid[0]
            }, s.maxTranslate = function () {
                return -s.snapGrid[s.snapGrid.length - 1]
            }, s.updateContainerSize = function () {
                var width, height;
                width = "undefined" != typeof s.params.width ? s.params.width : s.container[0].clientWidth, height = "undefined" != typeof s.params.height ? s.params.height : s.container[0].clientHeight, 0 === width && isH() || 0 === height && !isH() || (s.width = width, s.height = height, s.size = isH() ? s.width : s.height)
            }, s.updateSlidesSize = function () {
                s.slides = s.wrapper.children("." + s.params.slideClass), s.snapGrid = [], s.slidesGrid = [], s.slidesSizesGrid = [];
                var i, spaceBetween = s.params.spaceBetween, slidePosition = 0, prevSlideSize = 0, index = 0;
                "string" == typeof spaceBetween && spaceBetween.indexOf("%") >= 0 && (spaceBetween = parseFloat(spaceBetween.replace("%", "")) / 100 * s.size), s.virtualSize = -spaceBetween, s.rtl ? s.slides.css({
                        marginLeft: "",
                        marginTop: ""
                    }) : s.slides.css({marginRight: "", marginBottom: ""});
                var slidesNumberEvenToRows;
                s.params.slidesPerColumn > 1 && (slidesNumberEvenToRows = Math.floor(s.slides.length / s.params.slidesPerColumn) === s.slides.length / s.params.slidesPerColumn ? s.slides.length : Math.ceil(s.slides.length / s.params.slidesPerColumn) * s.params.slidesPerColumn);
                var slideSize, slidesPerColumn = s.params.slidesPerColumn, slidesPerRow = slidesNumberEvenToRows / slidesPerColumn, numFullColumns = slidesPerRow - (s.params.slidesPerColumn * slidesPerRow - s.slides.length);
                for (i = 0; i < s.slides.length; i++) {
                    slideSize = 0;
                    var slide = s.slides.eq(i);
                    if (s.params.slidesPerColumn > 1) {
                        var newSlideOrderIndex, column, row;
                        "column" === s.params.slidesPerColumnFill ? (column = Math.floor(i / slidesPerColumn), row = i - column * slidesPerColumn, (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) && ++row >= slidesPerColumn && (row = 0, column++), newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn, slide.css({
                                "-webkit-box-ordinal-group": newSlideOrderIndex,
                                "-moz-box-ordinal-group": newSlideOrderIndex,
                                "-ms-flex-order": newSlideOrderIndex,
                                "-webkit-order": newSlideOrderIndex,
                                order: newSlideOrderIndex
                            })) : (row = Math.floor(i / slidesPerRow), column = i - row * slidesPerRow), slide.css({"margin-top": 0 !== row && s.params.spaceBetween && s.params.spaceBetween + "px"}).attr("data-swiper-column", column).attr("data-swiper-row", row)
                    }
                    "none" !== slide.css("display") && ("auto" === s.params.slidesPerView ? slideSize = isH() ? slide.outerWidth(!0) : slide.outerHeight(!0) : (slideSize = (s.size - (s.params.slidesPerView - 1) * spaceBetween) / s.params.slidesPerView, isH() ? s.slides[i].style.width = slideSize + "px" : s.slides[i].style.height = slideSize + "px"), s.slides[i].swiperSlideSize = slideSize, s.slidesSizesGrid.push(slideSize), s.params.centeredSlides ? (slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween, 0 === i && (slidePosition = slidePosition - s.size / 2 - spaceBetween), Math.abs(slidePosition) < .001 && (slidePosition = 0), index % s.params.slidesPerGroup === 0 && s.snapGrid.push(slidePosition), s.slidesGrid.push(slidePosition)) : (index % s.params.slidesPerGroup === 0 && s.snapGrid.push(slidePosition), s.slidesGrid.push(slidePosition), slidePosition = slidePosition + slideSize + spaceBetween), s.virtualSize += slideSize + spaceBetween, prevSlideSize = slideSize, index++)
                }
                s.virtualSize = Math.max(s.virtualSize, s.size);
                var newSlidesGrid;
                if (s.rtl && s.wrongRTL && ("slide" === s.params.effect || "coverflow" === s.params.effect) && s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + "px"}), (!s.support.flexbox || s.params.setWrapperSize) && (isH() ? s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + "px"}) : s.wrapper.css({height: s.virtualSize + s.params.spaceBetween + "px"})), s.params.slidesPerColumn > 1 && (s.virtualSize = (slideSize + s.params.spaceBetween) * slidesNumberEvenToRows, s.virtualSize = Math.ceil(s.virtualSize / s.params.slidesPerColumn) - s.params.spaceBetween, s.wrapper.css({width: s.virtualSize + s.params.spaceBetween + "px"}), s.params.centeredSlides)) {
                    for (newSlidesGrid = [], i = 0; i < s.snapGrid.length; i++)s.snapGrid[i] < s.virtualSize + s.snapGrid[0] && newSlidesGrid.push(s.snapGrid[i]);
                    s.snapGrid = newSlidesGrid
                }
                if (!s.params.centeredSlides) {
                    for (newSlidesGrid = [], i = 0; i < s.snapGrid.length; i++)s.snapGrid[i] <= s.virtualSize - s.size && newSlidesGrid.push(s.snapGrid[i]);
                    s.snapGrid = newSlidesGrid, Math.floor(s.virtualSize - s.size) > Math.floor(s.snapGrid[s.snapGrid.length - 1]) && s.snapGrid.push(s.virtualSize - s.size)
                }
                0 === s.snapGrid.length && (s.snapGrid = [0]), 0 !== s.params.spaceBetween && (isH() ? s.rtl ? s.slides.css({marginLeft: spaceBetween + "px"}) : s.slides.css({marginRight: spaceBetween + "px"}) : s.slides.css({marginBottom: spaceBetween + "px"})), s.params.watchSlidesProgress && s.updateSlidesOffset()
            }, s.updateSlidesOffset = function () {
                for (var i = 0; i < s.slides.length; i++)s.slides[i].swiperSlideOffset = isH() ? s.slides[i].offsetLeft : s.slides[i].offsetTop
            }, s.updateSlidesProgress = function (translate) {
                if ("undefined" == typeof translate && (translate = s.translate || 0), 0 !== s.slides.length) {
                    "undefined" == typeof s.slides[0].swiperSlideOffset && s.updateSlidesOffset();
                    var offsetCenter = s.params.centeredSlides ? -translate + s.size / 2 : -translate;
                    s.rtl && (offsetCenter = s.params.centeredSlides ? translate - s.size / 2 : translate);
                    s.container[0].getBoundingClientRect(), isH() ? "left" : "top", isH() ? "right" : "bottom";
                    s.slides.removeClass(s.params.slideVisibleClass);
                    for (var i = 0; i < s.slides.length; i++) {
                        var slide = s.slides[i], slideCenterOffset = s.params.centeredSlides === !0 ? slide.swiperSlideSize / 2 : 0, slideProgress = (offsetCenter - slide.swiperSlideOffset - slideCenterOffset) / (slide.swiperSlideSize + s.params.spaceBetween);
                        if (s.params.watchSlidesVisibility) {
                            var slideBefore = -(offsetCenter - slide.swiperSlideOffset - slideCenterOffset), slideAfter = slideBefore + s.slidesSizesGrid[i], isVisible = slideBefore >= 0 && slideBefore < s.size || slideAfter > 0 && slideAfter <= s.size || 0 >= slideBefore && slideAfter >= s.size;
                            isVisible && s.slides.eq(i).addClass(s.params.slideVisibleClass)
                        }
                        slide.progress = s.rtl ? -slideProgress : slideProgress
                    }
                }
            }, s.updateProgress = function (translate) {
                "undefined" == typeof translate && (translate = s.translate || 0);
                var translatesDiff = s.maxTranslate() - s.minTranslate();
                0 === translatesDiff ? (s.progress = 0, s.isBeginning = s.isEnd = !0) : (s.progress = (translate - s.minTranslate()) / translatesDiff, s.isBeginning = s.progress <= 0, s.isEnd = s.progress >= 1), s.isBeginning && s.emit("onReachBeginning", s), s.isEnd && s.emit("onReachEnd", s), s.params.watchSlidesProgress && s.updateSlidesProgress(translate), s.emit("onProgress", s, s.progress)
            }, s.updateActiveIndex = function () {
                var newActiveIndex, i, snapIndex, translate = s.rtl ? s.translate : -s.translate;
                for (i = 0; i < s.slidesGrid.length; i++)"undefined" != typeof s.slidesGrid[i + 1] ? translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] - (s.slidesGrid[i + 1] - s.slidesGrid[i]) / 2 ? newActiveIndex = i : translate >= s.slidesGrid[i] && translate < s.slidesGrid[i + 1] && (newActiveIndex = i + 1) : translate >= s.slidesGrid[i] && (newActiveIndex = i);
                (0 > newActiveIndex || "undefined" == typeof newActiveIndex) && (newActiveIndex = 0), snapIndex = Math.floor(newActiveIndex / s.params.slidesPerGroup), snapIndex >= s.snapGrid.length && (snapIndex = s.snapGrid.length - 1), newActiveIndex !== s.activeIndex && (s.snapIndex = snapIndex, s.previousIndex = s.activeIndex, s.activeIndex = newActiveIndex, s.updateClasses())
            }, s.updateClasses = function () {
                s.slides.removeClass(s.params.slideActiveClass + " " + s.params.slideNextClass + " " + s.params.slidePrevClass);
                var activeSlide = s.slides.eq(s.activeIndex);
                if (activeSlide.addClass(s.params.slideActiveClass), activeSlide.next("." + s.params.slideClass).addClass(s.params.slideNextClass), activeSlide.prev("." + s.params.slideClass).addClass(s.params.slidePrevClass), s.bullets && s.bullets.length > 0) {
                    s.bullets.removeClass(s.params.bulletActiveClass);
                    var bulletIndex;
                    s.params.loop ? (bulletIndex = Math.ceil(s.activeIndex - s.loopedSlides) / s.params.slidesPerGroup, bulletIndex > s.slides.length - 1 - 2 * s.loopedSlides && (bulletIndex -= s.slides.length - 2 * s.loopedSlides), bulletIndex > s.bullets.length - 1 && (bulletIndex -= s.bullets.length)) : bulletIndex = "undefined" != typeof s.snapIndex ? s.snapIndex : s.activeIndex || 0, s.paginationContainer.length > 1 ? s.bullets.each(function () {
                            $(this).index() === bulletIndex && $(this).addClass(s.params.bulletActiveClass)
                        }) : s.bullets.eq(bulletIndex).addClass(s.params.bulletActiveClass)
                }
                s.params.loop || (s.params.prevButton && (s.isBeginning ? ($(s.params.prevButton).addClass(s.params.buttonDisabledClass), s.params.a11y && s.a11y && s.a11y.disable($(s.params.prevButton))) : ($(s.params.prevButton).removeClass(s.params.buttonDisabledClass), s.params.a11y && s.a11y && s.a11y.enable($(s.params.prevButton)))), s.params.nextButton && (s.isEnd ? ($(s.params.nextButton).addClass(s.params.buttonDisabledClass), s.params.a11y && s.a11y && s.a11y.disable($(s.params.nextButton))) : ($(s.params.nextButton).removeClass(s.params.buttonDisabledClass), s.params.a11y && s.a11y && s.a11y.enable($(s.params.nextButton)))))
            }, s.updatePagination = function () {
                if (s.params.pagination && s.paginationContainer && s.paginationContainer.length > 0) {
                    for (var bulletsHTML = "", numberOfBullets = s.params.loop ? Math.ceil((s.slides.length - 2 * s.loopedSlides) / s.params.slidesPerGroup) : s.snapGrid.length, i = 0; numberOfBullets > i; i++)bulletsHTML += s.params.paginationBulletRender ? s.params.paginationBulletRender(i, s.params.bulletClass) : '<span class="' + s.params.bulletClass + '"></span>';
                    s.paginationContainer.html(bulletsHTML), s.bullets = s.paginationContainer.find("." + s.params.bulletClass)
                }
            }, s.update = function (updateTranslate) {
                function forceSetTranslate() {
                    newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate()), s.setWrapperTranslate(newTranslate), s.updateActiveIndex(), s.updateClasses()
                }

                if (s.updateContainerSize(), s.updateSlidesSize(), s.updateProgress(), s.updatePagination(), s.updateClasses(), s.params.scrollbar && s.scrollbar && s.scrollbar.set(), updateTranslate) {
                    var translated, newTranslate;
                    s.params.freeMode ? forceSetTranslate() : (translated = "auto" === s.params.slidesPerView && s.isEnd && !s.params.centeredSlides ? s.slideTo(s.slides.length - 1, 0, !1, !0) : s.slideTo(s.activeIndex, 0, !1, !0), translated || forceSetTranslate())
                }
            }, s.onResize = function (forceUpdatePagination) {
                if (s.updateContainerSize(), s.updateSlidesSize(), s.updateProgress(), ("auto" === s.params.slidesPerView || s.params.freeMode || forceUpdatePagination) && s.updatePagination(), s.params.scrollbar && s.scrollbar && s.scrollbar.set(), s.params.freeMode) {
                    var newTranslate = Math.min(Math.max(s.translate, s.maxTranslate()), s.minTranslate());
                    s.setWrapperTranslate(newTranslate), s.updateActiveIndex(), s.updateClasses()
                } else s.updateClasses(), "auto" === s.params.slidesPerView && s.isEnd && !s.params.centeredSlides ? s.slideTo(s.slides.length - 1, 0, !1, !0) : s.slideTo(s.activeIndex, 0, !1, !0)
            };
            var desktopEvents = ["mousedown", "mousemove", "mouseup"];
            window.navigator.pointerEnabled ? desktopEvents = ["pointerdown", "pointermove", "pointerup"] : window.navigator.msPointerEnabled && (desktopEvents = ["MSPointerDown", "MSPointerMove", "MSPointerUp"]), s.touchEvents = {
                start: s.support.touch || !s.params.simulateTouch ? "touchstart" : desktopEvents[0],
                move: s.support.touch || !s.params.simulateTouch ? "touchmove" : desktopEvents[1],
                end: s.support.touch || !s.params.simulateTouch ? "touchend" : desktopEvents[2]
            }, (window.navigator.pointerEnabled || window.navigator.msPointerEnabled) && ("container" === s.params.touchEventsTarget ? s.container : s.wrapper).addClass("swiper-wp8-" + s.params.direction), s.initEvents = function (detach) {
                var actionDom = detach ? "off" : "on", action = detach ? "removeEventListener" : "addEventListener", touchEventsTarget = "container" === s.params.touchEventsTarget ? s.container[0] : s.wrapper[0], target = s.support.touch ? touchEventsTarget : document, moveCapture = s.params.nested ? !0 : !1;
                s.browser.ie ? (touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, !1), target[action](s.touchEvents.move, s.onTouchMove, moveCapture), target[action](s.touchEvents.end, s.onTouchEnd, !1)) : (s.support.touch && (touchEventsTarget[action](s.touchEvents.start, s.onTouchStart, !1), touchEventsTarget[action](s.touchEvents.move, s.onTouchMove, moveCapture), touchEventsTarget[action](s.touchEvents.end, s.onTouchEnd, !1)), !params.simulateTouch || s.device.ios || s.device.android || (touchEventsTarget[action]("mousedown", s.onTouchStart, !1), document[action]("mousemove", s.onTouchMove, moveCapture), document[action]("mouseup", s.onTouchEnd, !1))), window[action]("resize", s.onResize), s.params.nextButton && ($(s.params.nextButton)[actionDom]("click", s.onClickNext), s.params.a11y && s.a11y && $(s.params.nextButton)[actionDom]("keydown", s.a11y.onEnterKey)), s.params.prevButton && ($(s.params.prevButton)[actionDom]("click", s.onClickPrev), s.params.a11y && s.a11y && $(s.params.prevButton)[actionDom]("keydown", s.a11y.onEnterKey)), s.params.pagination && s.params.paginationClickable && $(s.paginationContainer)[actionDom]("click", "." + s.params.bulletClass, s.onClickIndex), (s.params.preventClicks || s.params.preventClicksPropagation) && touchEventsTarget[action]("click", s.preventClicks, !0)
            }, s.attachEvents = function (detach) {
                s.initEvents()
            }, s.detachEvents = function () {
                s.initEvents(!0)
            }, s.allowClick = !0, s.preventClicks = function (e) {
                s.allowClick || (s.params.preventClicks && e.preventDefault(), s.params.preventClicksPropagation && s.animating && (e.stopPropagation(), e.stopImmediatePropagation()))
            }, s.onClickNext = function (e) {
                e.preventDefault(), s.slideNext()
            }, s.onClickPrev = function (e) {
                e.preventDefault(), s.slidePrev()
            }, s.onClickIndex = function (e) {
                e.preventDefault();
                var index = $(this).index() * s.params.slidesPerGroup;
                s.params.loop && (index += s.loopedSlides), s.slideTo(index)
            }, s.updateClickedSlide = function (e) {
                var slide = findElementInEvent(e, "." + s.params.slideClass), slideFound = !1;
                if (slide)for (var i = 0; i < s.slides.length; i++)s.slides[i] === slide && (slideFound = !0);
                if (!slide || !slideFound)return s.clickedSlide = void 0, void(s.clickedIndex = void 0);
                if (s.clickedSlide = slide, s.clickedIndex = $(slide).index(), s.params.slideToClickedSlide && void 0 !== s.clickedIndex && s.clickedIndex !== s.activeIndex) {
                    var realIndex, slideToIndex = s.clickedIndex;
                    if (s.params.loop)if (realIndex = $(s.clickedSlide).attr("data-swiper-slide-index"), slideToIndex > s.slides.length - s.params.slidesPerView) s.fixLoop(), slideToIndex = s.wrapper.children("." + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]').eq(0).index(), setTimeout(function () {
                        s.slideTo(slideToIndex)
                    }, 0); else if (slideToIndex < s.params.slidesPerView - 1) {
                        s.fixLoop();
                        var duplicatedSlides = s.wrapper.children("." + s.params.slideClass + '[data-swiper-slide-index="' + realIndex + '"]');
                        slideToIndex = duplicatedSlides.eq(duplicatedSlides.length - 1).index(), setTimeout(function () {
                            s.slideTo(slideToIndex)
                        }, 0)
                    } else s.slideTo(slideToIndex); else s.slideTo(slideToIndex)
                }
            };
            var isTouched, isMoved, touchStartTime, isScrolling, currentTranslate, startTranslate, allowThresholdMove, clickTimeout, allowMomentumBounce, formElements = "input, select, textarea, button", lastClickTime = Date.now(), velocities = [];
            s.animating = !1, s.touches = {startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0};
            var isTouchEvent, startMoving;
            if (s.onTouchStart = function (e) {
                    if (e.originalEvent && (e = e.originalEvent), isTouchEvent = "touchstart" === e.type, isTouchEvent || !("which" in e) || 3 !== e.which) {
                        if (s.params.noSwiping && findElementInEvent(e, "." + s.params.noSwipingClass))return void(s.allowClick = !0);
                        if (!s.params.swipeHandler || findElementInEvent(e, s.params.swipeHandler)) {
                            if (isTouched = !0, isMoved = !1, isScrolling = void 0, startMoving = void 0, s.touches.startX = s.touches.currentX = "touchstart" === e.type ? e.targetTouches[0].pageX : e.pageX, s.touches.startY = s.touches.currentY = "touchstart" === e.type ? e.targetTouches[0].pageY : e.pageY, touchStartTime = Date.now(), s.allowClick = !0, s.updateContainerSize(), s.swipeDirection = void 0, s.params.threshold > 0 && (allowThresholdMove = !1), "touchstart" !== e.type) {
                                var preventDefault = !0;
                                $(e.target).is(formElements) && (preventDefault = !1), document.activeElement && $(document.activeElement).is(formElements) && document.activeElement.blur(), preventDefault && e.preventDefault()
                            }
                            s.emit("onTouchStart", s, e)
                        }
                    }
                }, s.onTouchMove = function (e) {
                    if (e.originalEvent && (e = e.originalEvent), !(isTouchEvent && "mousemove" === e.type || e.preventedByNestedSwiper)) {
                        if (s.params.onlyExternal)return isMoved = !0, void(s.allowClick = !1);
                        if (isTouchEvent && document.activeElement && e.target === document.activeElement && $(e.target).is(formElements))return isMoved = !0, void(s.allowClick = !1);
                        if (s.emit("onTouchMove", s, e), !(e.targetTouches && e.targetTouches.length > 1)) {
                            if (s.touches.currentX = "touchmove" === e.type ? e.targetTouches[0].pageX : e.pageX, s.touches.currentY = "touchmove" === e.type ? e.targetTouches[0].pageY : e.pageY, "undefined" == typeof isScrolling) {
                                var touchAngle = 180 * Math.atan2(Math.abs(s.touches.currentY - s.touches.startY), Math.abs(s.touches.currentX - s.touches.startX)) / Math.PI;
                                isScrolling = isH() ? touchAngle > s.params.touchAngle : 90 - touchAngle > s.params.touchAngle
                            }
                            if (isScrolling && s.emit("onTouchMoveOpposite", s, e), "undefined" == typeof startMoving && s.browser.ieTouch && (s.touches.currentX !== s.touches.startX || s.touches.currentY !== s.touches.startY) && (startMoving = !0), isTouched) {
                                if (isScrolling)return void(isTouched = !1);
                                if (startMoving || !s.browser.ieTouch) {
                                    s.allowClick = !1, s.emit("onSliderMove", s, e), e.preventDefault(), s.params.touchMoveStopPropagation && !s.params.nested && e.stopPropagation(), isMoved || (params.loop && s.fixLoop(), startTranslate = s.getWrapperTranslate(), s.setWrapperTransition(0), s.animating && s.wrapper.trigger("webkitTransitionEnd transitionend oTransitionEnd MSTransitionEnd msTransitionEnd"), s.params.autoplay && s.autoplaying && (s.params.autoplayDisableOnInteraction ? s.stopAutoplay() : s.pauseAutoplay()), allowMomentumBounce = !1, s.params.grabCursor && (s.container[0].style.cursor = "move", s.container[0].style.cursor = "-webkit-grabbing", s.container[0].style.cursor = "-moz-grabbin", s.container[0].style.cursor = "grabbing")), isMoved = !0;
                                    var diff = s.touches.diff = isH() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY;
                                    diff *= s.params.touchRatio, s.rtl && (diff = -diff), s.swipeDirection = diff > 0 ? "prev" : "next", currentTranslate = diff + startTranslate;
                                    var disableParentSwiper = !0;
                                    if (diff > 0 && currentTranslate > s.minTranslate() ? (disableParentSwiper = !1, s.params.resistance && (currentTranslate = s.minTranslate() - 1 + Math.pow(-s.minTranslate() + startTranslate + diff, s.params.resistanceRatio))) : 0 > diff && currentTranslate < s.maxTranslate() && (disableParentSwiper = !1, s.params.resistance && (currentTranslate = s.maxTranslate() + 1 - Math.pow(s.maxTranslate() - startTranslate - diff, s.params.resistanceRatio))), disableParentSwiper && (e.preventedByNestedSwiper = !0), !s.params.allowSwipeToNext && "next" === s.swipeDirection && startTranslate > currentTranslate && (currentTranslate = startTranslate), !s.params.allowSwipeToPrev && "prev" === s.swipeDirection && currentTranslate > startTranslate && (currentTranslate = startTranslate), s.params.followFinger) {
                                        if (s.params.threshold > 0) {
                                            if (!(Math.abs(diff) > s.params.threshold || allowThresholdMove))return void(currentTranslate = startTranslate);
                                            if (!allowThresholdMove)return allowThresholdMove = !0, s.touches.startX = s.touches.currentX, s.touches.startY = s.touches.currentY, currentTranslate = startTranslate, void(s.touches.diff = isH() ? s.touches.currentX - s.touches.startX : s.touches.currentY - s.touches.startY)
                                        }
                                        (s.params.freeMode || s.params.watchSlidesProgress) && s.updateActiveIndex(), s.params.freeMode && (0 === velocities.length && velocities.push({
                                            position: s.touches[isH() ? "startX" : "startY"],
                                            time: touchStartTime
                                        }), velocities.push({
                                            position: s.touches[isH() ? "currentX" : "currentY"],
                                            time: (new window.Date).getTime()
                                        })), s.updateProgress(currentTranslate), s.setWrapperTranslate(currentTranslate)
                                    }
                                }
                            }
                        }
                    }
                }, s.onTouchEnd = function (e) {
                    if (e.originalEvent && (e = e.originalEvent), s.emit("onTouchEnd", s, e), isTouched) {
                        s.params.grabCursor && isMoved && isTouched && (s.container[0].style.cursor = "move", s.container[0].style.cursor = "-webkit-grab", s.container[0].style.cursor = "-moz-grab", s.container[0].style.cursor = "grab");
                        var touchEndTime = Date.now(), timeDiff = touchEndTime - touchStartTime;
                        if (s.allowClick && (s.updateClickedSlide(e), s.emit("onTap", s, e), 300 > timeDiff && touchEndTime - lastClickTime > 300 && (clickTimeout && clearTimeout(clickTimeout), clickTimeout = setTimeout(function () {
                                s && (s.params.paginationHide && s.paginationContainer.length > 0 && !$(e.target).hasClass(s.params.bulletClass) && s.paginationContainer.toggleClass(s.params.paginationHiddenClass), s.emit("onClick", s, e))
                            }, 300)), 300 > timeDiff && 300 > touchEndTime - lastClickTime && (clickTimeout && clearTimeout(clickTimeout), s.emit("onDoubleTap", s, e))), lastClickTime = Date.now(), setTimeout(function () {
                                s && (s.allowClick = !0)
                            }, 0), !isTouched || !isMoved || !s.swipeDirection || 0 === s.touches.diff || currentTranslate === startTranslate)return void(isTouched = isMoved = !1);
                        isTouched = isMoved = !1;
                        var currentPos;
                        if (currentPos = s.params.followFinger ? s.rtl ? s.translate : -s.translate : -currentTranslate, s.params.freeMode) {
                            if (currentPos < -s.minTranslate())return void s.slideTo(s.activeIndex);
                            if (currentPos > -s.maxTranslate())return void(s.slides.length < s.snapGrid.length ? s.slideTo(s.snapGrid.length - 1) : s.slideTo(s.slides.length - 1));
                            if (s.params.freeModeMomentum) {
                                if (velocities.length > 1) {
                                    var lastMoveEvent = velocities.pop(), velocityEvent = velocities.pop(), distance = lastMoveEvent.position - velocityEvent.position, time = lastMoveEvent.time - velocityEvent.time;
                                    s.velocity = distance / time, s.velocity = s.velocity / 2, Math.abs(s.velocity) < .02 && (s.velocity = 0), (time > 150 || (new window.Date).getTime() - lastMoveEvent.time > 300) && (s.velocity = 0)
                                } else s.velocity = 0;
                                velocities.length = 0;
                                var momentumDuration = 1e3 * s.params.freeModeMomentumRatio, momentumDistance = s.velocity * momentumDuration, newPosition = s.translate + momentumDistance;
                                s.rtl && (newPosition = -newPosition);
                                var afterBouncePosition, doBounce = !1, bounceAmount = 20 * Math.abs(s.velocity) * s.params.freeModeMomentumBounceRatio;
                                if (newPosition < s.maxTranslate()) s.params.freeModeMomentumBounce ? (newPosition + s.maxTranslate() < -bounceAmount && (newPosition = s.maxTranslate() - bounceAmount), afterBouncePosition = s.maxTranslate(), doBounce = !0, allowMomentumBounce = !0) : newPosition = s.maxTranslate(); else if (newPosition > s.minTranslate()) s.params.freeModeMomentumBounce ? (newPosition - s.minTranslate() > bounceAmount && (newPosition = s.minTranslate() + bounceAmount), afterBouncePosition = s.minTranslate(), doBounce = !0, allowMomentumBounce = !0) : newPosition = s.minTranslate(); else if (s.params.freeModeSticky) {
                                    var nextSlide, j = 0;
                                    for (j = 0; j < s.snapGrid.length; j += 1)if (s.snapGrid[j] > -newPosition) {
                                        nextSlide = j;
                                        break
                                    }
                                    newPosition = Math.abs(s.snapGrid[nextSlide] - newPosition) < Math.abs(s.snapGrid[nextSlide - 1] - newPosition) || "next" === s.swipeDirection ? s.snapGrid[nextSlide] : s.snapGrid[nextSlide - 1], s.rtl || (newPosition = -newPosition)
                                }
                                if (0 !== s.velocity) momentumDuration = s.rtl ? Math.abs((-newPosition - s.translate) / s.velocity) : Math.abs((newPosition - s.translate) / s.velocity); else if (s.params.freeModeSticky)return void s.slideReset();
                                s.params.freeModeMomentumBounce && doBounce ? (s.updateProgress(afterBouncePosition), s.setWrapperTransition(momentumDuration), s.setWrapperTranslate(newPosition), s.onTransitionStart(), s.animating = !0, s.wrapper.transitionEnd(function () {
                                        s && allowMomentumBounce && (s.emit("onMomentumBounce", s), s.setWrapperTransition(s.params.speed), s.setWrapperTranslate(afterBouncePosition), s.wrapper.transitionEnd(function () {
                                            s && s.onTransitionEnd()
                                        }))
                                    })) : s.velocity ? (s.updateProgress(newPosition), s.setWrapperTransition(momentumDuration), s.setWrapperTranslate(newPosition), s.onTransitionStart(), s.animating || (s.animating = !0, s.wrapper.transitionEnd(function () {
                                            s && s.onTransitionEnd()
                                        }))) : s.updateProgress(newPosition), s.updateActiveIndex()
                            }
                            return void((!s.params.freeModeMomentum || timeDiff >= s.params.longSwipesMs) && (s.updateProgress(), s.updateActiveIndex()))
                        }
                        var i, stopIndex = 0, groupSize = s.slidesSizesGrid[0];
                        for (i = 0; i < s.slidesGrid.length; i += s.params.slidesPerGroup)"undefined" != typeof s.slidesGrid[i + s.params.slidesPerGroup] ? currentPos >= s.slidesGrid[i] && currentPos < s.slidesGrid[i + s.params.slidesPerGroup] && (stopIndex = i, groupSize = s.slidesGrid[i + s.params.slidesPerGroup] - s.slidesGrid[i]) : currentPos >= s.slidesGrid[i] && (stopIndex = i, groupSize = s.slidesGrid[s.slidesGrid.length - 1] - s.slidesGrid[s.slidesGrid.length - 2]);
                        var ratio = (currentPos - s.slidesGrid[stopIndex]) / groupSize;
                        if (timeDiff > s.params.longSwipesMs) {
                            if (!s.params.longSwipes)return void s.slideTo(s.activeIndex);
                            "next" === s.swipeDirection && (ratio >= s.params.longSwipesRatio ? s.slideTo(stopIndex + s.params.slidesPerGroup) : s.slideTo(stopIndex)), "prev" === s.swipeDirection && (ratio > 1 - s.params.longSwipesRatio ? s.slideTo(stopIndex + s.params.slidesPerGroup) : s.slideTo(stopIndex))
                        } else {
                            if (!s.params.shortSwipes)return void s.slideTo(s.activeIndex);
                            "next" === s.swipeDirection && s.slideTo(stopIndex + s.params.slidesPerGroup), "prev" === s.swipeDirection && s.slideTo(stopIndex)
                        }
                    }
                }, s._slideTo = function (slideIndex, speed) {
                    return s.slideTo(slideIndex, speed, !0, !0)
                }, s.slideTo = function (slideIndex, speed, runCallbacks, internal) {
                    "undefined" == typeof runCallbacks && (runCallbacks = !0), "undefined" == typeof slideIndex && (slideIndex = 0), 0 > slideIndex && (slideIndex = 0), s.snapIndex = Math.floor(slideIndex / s.params.slidesPerGroup), s.snapIndex >= s.snapGrid.length && (s.snapIndex = s.snapGrid.length - 1);
                    var translate = -s.snapGrid[s.snapIndex];
                    if (!s.params.allowSwipeToNext && translate < s.translate && translate < s.minTranslate())return !1;
                    if (!s.params.allowSwipeToPrev && translate > s.translate && translate > s.maxTranslate())return !1;
                    s.params.autoplay && s.autoplaying && (internal || !s.params.autoplayDisableOnInteraction ? s.pauseAutoplay(speed) : s.stopAutoplay()), s.updateProgress(translate);
                    for (var i = 0; i < s.slidesGrid.length; i++)-translate >= s.slidesGrid[i] && (slideIndex = i);
                    if ("undefined" == typeof speed && (speed = s.params.speed), s.previousIndex = s.activeIndex || 0, s.activeIndex = slideIndex, translate === s.translate)return s.updateClasses(), !1;
                    s.updateClasses(), s.onTransitionStart(runCallbacks);
                    isH() ? translate : 0, isH() ? 0 : translate;
                    return 0 === speed ? (s.setWrapperTransition(0), s.setWrapperTranslate(translate), s.onTransitionEnd(runCallbacks)) : (s.setWrapperTransition(speed), s.setWrapperTranslate(translate), s.animating || (s.animating = !0, s.wrapper.transitionEnd(function () {
                            s && s.onTransitionEnd(runCallbacks)
                        }))), !0
                }, s.onTransitionStart = function (runCallbacks) {
                    "undefined" == typeof runCallbacks && (runCallbacks = !0), s.lazy && s.lazy.onTransitionStart(), runCallbacks && (s.emit("onTransitionStart", s), s.activeIndex !== s.previousIndex && s.emit("onSlideChangeStart", s))
                }, s.onTransitionEnd = function (runCallbacks) {
                    s.animating = !1, s.setWrapperTransition(0), "undefined" == typeof runCallbacks && (runCallbacks = !0), s.lazy && s.lazy.onTransitionEnd(), runCallbacks && (s.emit("onTransitionEnd", s), s.activeIndex !== s.previousIndex && s.emit("onSlideChangeEnd", s)), s.params.hashnav && s.hashnav && s.hashnav.setHash()
                }, s.slideNext = function (runCallbacks, speed, internal) {
                    if (s.params.loop) {
                        if (s.animating)return !1;
                        s.fixLoop();
                        s.container[0].clientLeft;
                        return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal)
                    }
                    return s.slideTo(s.activeIndex + s.params.slidesPerGroup, speed, runCallbacks, internal)
                }, s._slideNext = function (speed) {
                    return s.slideNext(!0, speed, !0)
                }, s.slidePrev = function (runCallbacks, speed, internal) {
                    if (s.params.loop) {
                        if (s.animating)return !1;
                        s.fixLoop();
                        s.container[0].clientLeft;
                        return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal)
                    }
                    return s.slideTo(s.activeIndex - 1, speed, runCallbacks, internal)
                }, s._slidePrev = function (speed) {
                    return s.slidePrev(!0, speed, !0)
                }, s.slideReset = function (runCallbacks, speed, internal) {
                    return s.slideTo(s.activeIndex, speed, runCallbacks)
                }, s.setWrapperTransition = function (duration, byController) {
                    s.wrapper.transition(duration), "slide" !== s.params.effect && s.effects[s.params.effect] && s.effects[s.params.effect].setTransition(duration), s.params.parallax && s.parallax && s.parallax.setTransition(duration), s.params.scrollbar && s.scrollbar && s.scrollbar.setTransition(duration), s.params.control && s.controller && s.controller.setTransition(duration, byController), s.emit("onSetTransition", s, duration)
                }, s.setWrapperTranslate = function (translate, updateActiveIndex, byController) {
                    var x = 0, y = 0, z = 0;
                    isH() ? x = s.rtl ? -translate : translate : y = translate, s.params.virtualTranslate || (s.support.transforms3d ? s.wrapper.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)") : s.wrapper.transform("translate(" + x + "px, " + y + "px)")), s.translate = isH() ? x : y, updateActiveIndex && s.updateActiveIndex(), "slide" !== s.params.effect && s.effects[s.params.effect] && s.effects[s.params.effect].setTranslate(s.translate), s.params.parallax && s.parallax && s.parallax.setTranslate(s.translate), s.params.scrollbar && s.scrollbar && s.scrollbar.setTranslate(s.translate), s.params.control && s.controller && s.controller.setTranslate(s.translate, byController), s.emit("onSetTranslate", s, s.translate)
                }, s.getTranslate = function (el, axis) {
                    var matrix, curTransform, curStyle, transformMatrix;
                    return "undefined" == typeof axis && (axis = "x"), s.params.virtualTranslate ? s.rtl ? -s.translate : s.translate : (curStyle = window.getComputedStyle(el, null), window.WebKitCSSMatrix ? transformMatrix = new window.WebKitCSSMatrix("none" === curStyle.webkitTransform ? "" : curStyle.webkitTransform) : (transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), matrix = transformMatrix.toString().split(",")), "x" === axis && (curTransform = window.WebKitCSSMatrix ? transformMatrix.m41 : 16 === matrix.length ? parseFloat(matrix[12]) : parseFloat(matrix[4])), "y" === axis && (curTransform = window.WebKitCSSMatrix ? transformMatrix.m42 : 16 === matrix.length ? parseFloat(matrix[13]) : parseFloat(matrix[5])), s.rtl && curTransform && (curTransform = -curTransform), curTransform || 0)
                }, s.getWrapperTranslate = function (axis) {
                    return "undefined" == typeof axis && (axis = isH() ? "x" : "y"), s.getTranslate(s.wrapper[0], axis)
                }, s.observers = [], s.initObservers = function () {
                    if (s.params.observeParents)for (var containerParents = s.container.parents(), i = 0; i < containerParents.length; i++)initObserver(containerParents[i]);
                    initObserver(s.container[0], {childList: !1}), initObserver(s.wrapper[0], {attributes: !1})
                }, s.disconnectObservers = function () {
                    for (var i = 0; i < s.observers.length; i++)s.observers[i].disconnect();
                    s.observers = []
                }, s.createLoop = function () {
                    s.wrapper.children("." + s.params.slideClass + "." + s.params.slideDuplicateClass).remove();
                    var slides = s.wrapper.children("." + s.params.slideClass);
                    s.loopedSlides = parseInt(s.params.loopedSlides || s.params.slidesPerView, 10), s.loopedSlides = s.loopedSlides + s.params.loopAdditionalSlides, s.loopedSlides > slides.length && (s.loopedSlides = slides.length);
                    var i, prependSlides = [], appendSlides = [];
                    for (slides.each(function (index, el) {
                        var slide = $(this);
                        index < s.loopedSlides && appendSlides.push(el), index < slides.length && index >= slides.length - s.loopedSlides && prependSlides.push(el), slide.attr("data-swiper-slide-index", index)
                    }), i = 0; i < appendSlides.length; i++)s.wrapper.append($(appendSlides[i].cloneNode(!0)).addClass(s.params.slideDuplicateClass));
                    for (i = prependSlides.length - 1; i >= 0; i--)s.wrapper.prepend($(prependSlides[i].cloneNode(!0)).addClass(s.params.slideDuplicateClass))
                }, s.destroyLoop = function () {
                    s.wrapper.children("." + s.params.slideClass + "." + s.params.slideDuplicateClass).remove(), s.slides.removeAttr("data-swiper-slide-index")
                }, s.fixLoop = function () {
                    var newIndex;
                    s.activeIndex < s.loopedSlides ? (newIndex = s.slides.length - 3 * s.loopedSlides + s.activeIndex, newIndex += s.loopedSlides, s.slideTo(newIndex, 0, !1, !0)) : ("auto" === s.params.slidesPerView && s.activeIndex >= 2 * s.loopedSlides || s.activeIndex > s.slides.length - 2 * s.params.slidesPerView) && (newIndex = -s.slides.length + s.activeIndex + s.loopedSlides, newIndex += s.loopedSlides, s.slideTo(newIndex, 0, !1, !0))
                }, s.appendSlide = function (slides) {
                    if (s.params.loop && s.destroyLoop(), "object" == typeof slides && slides.length)for (var i = 0; i < slides.length; i++)slides[i] && s.wrapper.append(slides[i]); else s.wrapper.append(slides);
                    s.params.loop && s.createLoop(), s.params.observer && s.support.observer || s.update(!0)
                }, s.prependSlide = function (slides) {
                    s.params.loop && s.destroyLoop();
                    var newActiveIndex = s.activeIndex + 1;
                    if ("object" == typeof slides && slides.length) {
                        for (var i = 0; i < slides.length; i++)slides[i] && s.wrapper.prepend(slides[i]);
                        newActiveIndex = s.activeIndex + slides.length
                    } else s.wrapper.prepend(slides);
                    s.params.loop && s.createLoop(), s.params.observer && s.support.observer || s.update(!0), s.slideTo(newActiveIndex, 0, !1)
                }, s.removeSlide = function (slidesIndexes) {
                    s.params.loop && (s.destroyLoop(), s.slides = s.wrapper.children("." + s.params.slideClass));
                    var indexToRemove, newActiveIndex = s.activeIndex;
                    if ("object" == typeof slidesIndexes && slidesIndexes.length) {
                        for (var i = 0; i < slidesIndexes.length; i++)indexToRemove = slidesIndexes[i], s.slides[indexToRemove] && s.slides.eq(indexToRemove).remove(), newActiveIndex > indexToRemove && newActiveIndex--;
                        newActiveIndex = Math.max(newActiveIndex, 0)
                    } else indexToRemove = slidesIndexes, s.slides[indexToRemove] && s.slides.eq(indexToRemove).remove(), newActiveIndex > indexToRemove && newActiveIndex--, newActiveIndex = Math.max(newActiveIndex, 0);
                    s.params.loop && s.createLoop(), s.params.observer && s.support.observer || s.update(!0), s.params.loop ? s.slideTo(newActiveIndex + s.loopedSlides, 0, !1) : s.slideTo(newActiveIndex, 0, !1)
                }, s.removeAllSlides = function () {
                    for (var slidesIndexes = [], i = 0; i < s.slides.length; i++)slidesIndexes.push(i);
                    s.removeSlide(slidesIndexes)
                }, s.effects = {
                    fade: {
                        setTranslate: function () {
                            for (var i = 0; i < s.slides.length; i++) {
                                var slide = s.slides.eq(i), offset = slide[0].swiperSlideOffset, tx = -offset;
                                s.params.virtualTranslate || (tx -= s.translate);
                                var ty = 0;
                                isH() || (ty = tx, tx = 0);
                                var slideOpacity = s.params.fade.crossFade ? Math.max(1 - Math.abs(slide[0].progress), 0) : 1 + Math.min(Math.max(slide[0].progress, -1), 0);
                                slide.css({opacity: slideOpacity}).transform("translate3d(" + tx + "px, " + ty + "px, 0px)")
                            }
                        }, setTransition: function (duration) {
                            if (s.slides.transition(duration), s.params.virtualTranslate && 0 !== duration) {
                                var eventTriggered = !1;
                                s.slides.transitionEnd(function () {
                                    if (!eventTriggered && s) {
                                        eventTriggered = !0, s.animating = !1;
                                        for (var triggerEvents = ["webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd", "msTransitionEnd"], i = 0; i < triggerEvents.length; i++)s.wrapper.trigger(triggerEvents[i])
                                    }
                                })
                            }
                        }
                    }, cube: {
                        setTranslate: function () {
                            var cubeShadow, wrapperRotate = 0;
                            s.params.cube.shadow && (isH() ? (cubeShadow = s.wrapper.find(".swiper-cube-shadow"), 0 === cubeShadow.length && (cubeShadow = $('<div class="swiper-cube-shadow"></div>'), s.wrapper.append(cubeShadow)), cubeShadow.css({height: s.width + "px"})) : (cubeShadow = s.container.find(".swiper-cube-shadow"), 0 === cubeShadow.length && (cubeShadow = $('<div class="swiper-cube-shadow"></div>'), s.container.append(cubeShadow))));
                            for (var i = 0; i < s.slides.length; i++) {
                                var slide = s.slides.eq(i), slideAngle = 90 * i, round = Math.floor(slideAngle / 360);
                                s.rtl && (slideAngle = -slideAngle, round = Math.floor(-slideAngle / 360));
                                var progress = Math.max(Math.min(slide[0].progress, 1), -1), tx = 0, ty = 0, tz = 0;
                                i % 4 === 0 ? (tx = 4 * -round * s.size, tz = 0) : (i - 1) % 4 === 0 ? (tx = 0, tz = 4 * -round * s.size) : (i - 2) % 4 === 0 ? (tx = s.size + 4 * round * s.size, tz = s.size) : (i - 3) % 4 === 0 && (tx = -s.size, tz = 3 * s.size + 4 * s.size * round), s.rtl && (tx = -tx), isH() || (ty = tx, tx = 0);
                                var transform = "rotateX(" + (isH() ? 0 : -slideAngle) + "deg) rotateY(" + (isH() ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";
                                if (1 >= progress && progress > -1 && (wrapperRotate = 90 * i + 90 * progress, s.rtl && (wrapperRotate = 90 * -i - 90 * progress)), slide.transform(transform), s.params.cube.slideShadows) {
                                    var shadowBefore = isH() ? slide.find(".swiper-slide-shadow-left") : slide.find(".swiper-slide-shadow-top"), shadowAfter = isH() ? slide.find(".swiper-slide-shadow-right") : slide.find(".swiper-slide-shadow-bottom");
                                    0 === shadowBefore.length && (shadowBefore = $('<div class="swiper-slide-shadow-' + (isH() ? "left" : "top") + '"></div>'), slide.append(shadowBefore)), 0 === shadowAfter.length && (shadowAfter = $('<div class="swiper-slide-shadow-' + (isH() ? "right" : "bottom") + '"></div>'), slide.append(shadowAfter));
                                    slide[0].progress;
                                    shadowBefore.length && (shadowBefore[0].style.opacity = -slide[0].progress), shadowAfter.length && (shadowAfter[0].style.opacity = slide[0].progress)
                                }
                            }
                            if (s.wrapper.css({
                                    "-webkit-transform-origin": "50% 50% -" + s.size / 2 + "px",
                                    "-moz-transform-origin": "50% 50% -" + s.size / 2 + "px",
                                    "-ms-transform-origin": "50% 50% -" + s.size / 2 + "px",
                                    "transform-origin": "50% 50% -" + s.size / 2 + "px"
                                }), s.params.cube.shadow)if (isH()) cubeShadow.transform("translate3d(0px, " + (s.width / 2 + s.params.cube.shadowOffset) + "px, " + -s.width / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + s.params.cube.shadowScale + ")"); else {
                                var shadowAngle = Math.abs(wrapperRotate) - 90 * Math.floor(Math.abs(wrapperRotate) / 90), multiplier = 1.5 - (Math.sin(2 * shadowAngle * Math.PI / 360) / 2 + Math.cos(2 * shadowAngle * Math.PI / 360) / 2), scale1 = s.params.cube.shadowScale, scale2 = s.params.cube.shadowScale / multiplier, offset = s.params.cube.shadowOffset;
                                cubeShadow.transform("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + (s.height / 2 + offset) + "px, " + -s.height / 2 / scale2 + "px) rotateX(-90deg)")
                            }
                            var zFactor = s.isSafari || s.isUiWebView ? -s.size / 2 : 0;
                            s.wrapper.transform("translate3d(0px,0," + zFactor + "px) rotateX(" + (isH() ? 0 : wrapperRotate) + "deg) rotateY(" + (isH() ? -wrapperRotate : 0) + "deg)")
                        }, setTransition: function (duration) {
                            s.slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration), s.params.cube.shadow && !isH() && s.container.find(".swiper-cube-shadow").transition(duration)
                        }
                    }, coverflow: {
                        setTranslate: function () {
                            for (var transform = s.translate, center = isH() ? -transform + s.width / 2 : -transform + s.height / 2, rotate = isH() ? s.params.coverflow.rotate : -s.params.coverflow.rotate, translate = s.params.coverflow.depth, i = 0, length = s.slides.length; length > i; i++) {
                                var slide = s.slides.eq(i), slideSize = s.slidesSizesGrid[i], slideOffset = slide[0].swiperSlideOffset, offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * s.params.coverflow.modifier, rotateY = isH() ? rotate * offsetMultiplier : 0, rotateX = isH() ? 0 : rotate * offsetMultiplier, translateZ = -translate * Math.abs(offsetMultiplier), translateY = isH() ? 0 : s.params.coverflow.stretch * offsetMultiplier, translateX = isH() ? s.params.coverflow.stretch * offsetMultiplier : 0;
                                Math.abs(translateX) < .001 && (translateX = 0), Math.abs(translateY) < .001 && (translateY = 0), Math.abs(translateZ) < .001 && (translateZ = 0), Math.abs(rotateY) < .001 && (rotateY = 0), Math.abs(rotateX) < .001 && (rotateX = 0);
                                var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";
                                if (slide.transform(slideTransform), slide[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1, s.params.coverflow.slideShadows) {
                                    var shadowBefore = isH() ? slide.find(".swiper-slide-shadow-left") : slide.find(".swiper-slide-shadow-top"), shadowAfter = isH() ? slide.find(".swiper-slide-shadow-right") : slide.find(".swiper-slide-shadow-bottom");
                                    0 === shadowBefore.length && (shadowBefore = $('<div class="swiper-slide-shadow-' + (isH() ? "left" : "top") + '"></div>'), slide.append(shadowBefore)), 0 === shadowAfter.length && (shadowAfter = $('<div class="swiper-slide-shadow-' + (isH() ? "right" : "bottom") + '"></div>'), slide.append(shadowAfter)), shadowBefore.length && (shadowBefore[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0), shadowAfter.length && (shadowAfter[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0)
                                }
                            }
                            if (s.browser.ie) {
                                var ws = s.wrapper[0].style;
                                ws.perspectiveOrigin = center + "px 50%"
                            }
                        }, setTransition: function (duration) {
                            s.slides.transition(duration).find(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").transition(duration)
                        }
                    }
                }, s.lazy = {
                    initialImageLoaded: !1, loadImageInSlide: function (index, loadInDuplicate) {
                        if ("undefined" != typeof index && ("undefined" == typeof loadInDuplicate && (loadInDuplicate = !0), 0 !== s.slides.length)) {
                            var slide = s.slides.eq(index), img = slide.find(".swiper-lazy:not(.swiper-lazy-loaded):not(.swiper-lazy-loading)");
                            !slide.hasClass("swiper-lazy") || slide.hasClass("swiper-lazy-loaded") || slide.hasClass("swiper-lazy-loading") || img.add(slide[0]), 0 !== img.length && img.each(function () {
                                var _img = $(this);
                                _img.addClass("swiper-lazy-loading");
                                var background = _img.attr("data-background"), src = _img.attr("data-src");
                                s.loadImage(_img[0], src || background, !1, function () {
                                    if (background ? (_img.css("background-image", "url(" + background + ")"), _img.removeAttr("data-background")) : (_img.attr("src", src), _img.removeAttr("data-src")), _img.addClass("swiper-lazy-loaded").removeClass("swiper-lazy-loading"), slide.find(".swiper-lazy-preloader, .preloader").remove(), s.params.loop && loadInDuplicate) {
                                        var slideOriginalIndex = slide.attr("data-swiper-slide-index");
                                        if (slide.hasClass(s.params.slideDuplicateClass)) {
                                            var originalSlide = s.wrapper.children('[data-swiper-slide-index="' + slideOriginalIndex + '"]:not(.' + s.params.slideDuplicateClass + ")");
                                            s.lazy.loadImageInSlide(originalSlide.index(), !1)
                                        } else {
                                            var duplicatedSlide = s.wrapper.children("." + s.params.slideDuplicateClass + '[data-swiper-slide-index="' + slideOriginalIndex + '"]');
                                            s.lazy.loadImageInSlide(duplicatedSlide.index(), !1)
                                        }
                                    }
                                    s.emit("onLazyImageReady", s, slide[0], _img[0])
                                }), s.emit("onLazyImageLoad", s, slide[0], _img[0])
                            })
                        }
                    }, load: function () {
                        var i;
                        if (s.params.watchSlidesVisibility) s.wrapper.children("." + s.params.slideVisibleClass).each(function () {
                            s.lazy.loadImageInSlide($(this).index())
                        }); else if (s.params.slidesPerView > 1)for (i = s.activeIndex; i < s.activeIndex + s.params.slidesPerView; i++)s.slides[i] && s.lazy.loadImageInSlide(i); else s.lazy.loadImageInSlide(s.activeIndex);
                        if (s.params.lazyLoadingInPrevNext)if (s.params.slidesPerView > 1) {
                            for (i = s.activeIndex + s.params.slidesPerView; i < s.activeIndex + s.params.slidesPerView + s.params.slidesPerView; i++)s.slides[i] && s.lazy.loadImageInSlide(i);
                            for (i = s.activeIndex - s.params.slidesPerView; i < s.activeIndex; i++)s.slides[i] && s.lazy.loadImageInSlide(i)
                        } else {
                            var nextSlide = s.wrapper.children("." + s.params.slideNextClass);
                            nextSlide.length > 0 && s.lazy.loadImageInSlide(nextSlide.index());
                            var prevSlide = s.wrapper.children("." + s.params.slidePrevClass);
                            prevSlide.length > 0 && s.lazy.loadImageInSlide(prevSlide.index())
                        }
                    }, onTransitionStart: function () {
                        s.params.lazyLoading && (s.params.lazyLoadingOnTransitionStart || !s.params.lazyLoadingOnTransitionStart && !s.lazy.initialImageLoaded) && s.lazy.load()
                    }, onTransitionEnd: function () {
                        s.params.lazyLoading && !s.params.lazyLoadingOnTransitionStart && s.lazy.load()
                    }
                }, s.scrollbar = {
                    set: function () {
                        if (s.params.scrollbar) {
                            var sb = s.scrollbar;
                            sb.track = $(s.params.scrollbar), sb.drag = sb.track.find(".swiper-scrollbar-drag"), 0 === sb.drag.length && (sb.drag = $('<div class="swiper-scrollbar-drag"></div>'), sb.track.append(sb.drag)), sb.drag[0].style.width = "", sb.drag[0].style.height = "", sb.trackSize = isH() ? sb.track[0].offsetWidth : sb.track[0].offsetHeight, sb.divider = s.size / s.virtualSize, sb.moveDivider = sb.divider * (sb.trackSize / s.size), sb.dragSize = sb.trackSize * sb.divider, isH() ? sb.drag[0].style.width = sb.dragSize + "px" : sb.drag[0].style.height = sb.dragSize + "px", sb.divider >= 1 ? sb.track[0].style.display = "none" : sb.track[0].style.display = "", s.params.scrollbarHide && (sb.track[0].style.opacity = 0)
                        }
                    }, setTranslate: function () {
                        if (s.params.scrollbar) {
                            var newPos, sb = s.scrollbar, newSize = (s.translate || 0, sb.dragSize);
                            newPos = (sb.trackSize - sb.dragSize) * s.progress, s.rtl && isH() ? (newPos = -newPos, newPos > 0 ? (newSize = sb.dragSize - newPos, newPos = 0) : -newPos + sb.dragSize > sb.trackSize && (newSize = sb.trackSize + newPos)) : 0 > newPos ? (newSize = sb.dragSize + newPos, newPos = 0) : newPos + sb.dragSize > sb.trackSize && (newSize = sb.trackSize - newPos), isH() ? (s.support.transforms3d ? sb.drag.transform("translate3d(" + newPos + "px, 0, 0)") : sb.drag.transform("translateX(" + newPos + "px)"), sb.drag[0].style.width = newSize + "px") : (s.support.transforms3d ? sb.drag.transform("translate3d(0px, " + newPos + "px, 0)") : sb.drag.transform("translateY(" + newPos + "px)"), sb.drag[0].style.height = newSize + "px"), s.params.scrollbarHide && (clearTimeout(sb.timeout), sb.track[0].style.opacity = 1, sb.timeout = setTimeout(function () {
                                sb.track[0].style.opacity = 0, sb.track.transition(400)
                            }, 1e3))
                        }
                    }, setTransition: function (duration) {
                        s.params.scrollbar && s.scrollbar.drag.transition(duration)
                    }
                }, s.controller = {
                    setTranslate: function (translate, byController) {
                        function setControlledTranslate(c) {
                            translate = c.rtl && "horizontal" === c.params.direction ? -s.translate : s.translate, multiplier = (c.maxTranslate() - c.minTranslate()) / (s.maxTranslate() - s.minTranslate()), controlledTranslate = (translate - s.minTranslate()) * multiplier + c.minTranslate(), s.params.controlInverse && (controlledTranslate = c.maxTranslate() - controlledTranslate), c.updateProgress(controlledTranslate), c.setWrapperTranslate(controlledTranslate, !1, s), c.updateActiveIndex()
                        }

                        var multiplier, controlledTranslate, controlled = s.params.control;
                        if (s.isArray(controlled))for (var i = 0; i < controlled.length; i++)controlled[i] !== byController && controlled[i] instanceof Swiper && setControlledTranslate(controlled[i]); else controlled instanceof Swiper && byController !== controlled && setControlledTranslate(controlled)
                    }, setTransition: function (duration, byController) {
                        function setControlledTransition(c) {
                            c.setWrapperTransition(duration, s), 0 !== duration && (c.onTransitionStart(), c.wrapper.transitionEnd(function () {
                                controlled && c.onTransitionEnd()
                            }))
                        }

                        var i, controlled = s.params.control;
                        if (s.isArray(controlled))for (i = 0; i < controlled.length; i++)controlled[i] !== byController && controlled[i] instanceof Swiper && setControlledTransition(controlled[i]); else controlled instanceof Swiper && byController !== controlled && setControlledTransition(controlled)
                    }
                }, s.hashnav = {
                    init: function () {
                        if (s.params.hashnav) {
                            s.hashnav.initialized = !0;
                            var hash = document.location.hash.replace("#", "");
                            if (hash)for (var speed = 0, i = 0, length = s.slides.length; length > i; i++) {
                                var slide = s.slides.eq(i), slideHash = slide.attr("data-hash");
                                if (slideHash === hash && !slide.hasClass(s.params.slideDuplicateClass)) {
                                    var index = slide.index();
                                    s.slideTo(index, speed, s.params.runCallbacksOnInit, !0)
                                }
                            }
                        }
                    }, setHash: function () {
                        s.hashnav.initialized && s.params.hashnav && (document.location.hash = s.slides.eq(s.activeIndex).attr("data-hash") || "")
                    }
                }, s.disableKeyboardControl = function () {
                    $(document).off("keydown", handleKeyboard)
                }, s.enableKeyboardControl = function () {
                    $(document).on("keydown", handleKeyboard)
                }, s.mousewheel = {
                    event: !1,
                    lastScrollTime: (new window.Date).getTime()
                }, s.params.mousewheelControl) {
                if (void 0 !== document.onmousewheel && (s.mousewheel.event = "mousewheel"), !s.mousewheel.event)try {
                    new window.WheelEvent("wheel"), s.mousewheel.event = "wheel"
                } catch (e) {
                }
                s.mousewheel.event || (s.mousewheel.event = "DOMMouseScroll")
            }
            s.disableMousewheelControl = function () {
                return s.mousewheel.event ? (s.container.off(s.mousewheel.event, handleMousewheel), !0) : !1
            }, s.enableMousewheelControl = function () {
                return s.mousewheel.event ? (s.container.on(s.mousewheel.event, handleMousewheel), !0) : !1
            }, s.parallax = {
                setTranslate: function () {
                    s.container.children("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function () {
                        setParallaxTransform(this, s.progress)
                    }), s.slides.each(function () {
                        var slide = $(this);
                        slide.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function () {
                            var progress = Math.min(Math.max(slide[0].progress, -1), 1);
                            setParallaxTransform(this, progress)
                        })
                    })
                }, setTransition: function (duration) {
                    "undefined" == typeof duration && (duration = s.params.speed), s.container.find("[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y]").each(function () {
                        var el = $(this), parallaxDuration = parseInt(el.attr("data-swiper-parallax-duration"), 10) || duration;
                        0 === duration && (parallaxDuration = 0), el.transition(parallaxDuration)
                    })
                }
            }, s._plugins = [];
            for (var plugin in s.plugins) {
                var p = s.plugins[plugin](s, s.params[plugin]);
                p && s._plugins.push(p)
            }
            return s.callPlugins = function (eventName) {
                for (var i = 0; i < s._plugins.length; i++)eventName in s._plugins[i] && s._plugins[i][eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5])
            }, s.emitterEventListeners = {}, s.emit = function (eventName) {
                s.params[eventName] && s.params[eventName](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                var i;
                if (s.emitterEventListeners[eventName])for (i = 0; i < s.emitterEventListeners[eventName].length; i++)s.emitterEventListeners[eventName][i](arguments[1], arguments[2], arguments[3], arguments[4], arguments[5]);
                s.callPlugins && s.callPlugins(eventName, arguments[1], arguments[2], arguments[3], arguments[4], arguments[5])
            }, s.on = function (eventName, handler) {
                return eventName = normalizeEventName(eventName), s.emitterEventListeners[eventName] || (s.emitterEventListeners[eventName] = []), s.emitterEventListeners[eventName].push(handler), s
            }, s.off = function (eventName, handler) {
                var i;
                if (eventName = normalizeEventName(eventName), "undefined" == typeof handler)return s.emitterEventListeners[eventName] = [], s;
                if (s.emitterEventListeners[eventName] && 0 !== s.emitterEventListeners[eventName].length) {
                    for (i = 0; i < s.emitterEventListeners[eventName].length; i++)s.emitterEventListeners[eventName][i] === handler && s.emitterEventListeners[eventName].splice(i, 1);
                    return s
                }
            }, s.once = function (eventName, handler) {
                eventName = normalizeEventName(eventName);
                var _handler = function () {
                    handler(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4]), s.off(eventName, _handler)
                };
                return s.on(eventName, _handler), s
            }, s.a11y = {
                makeFocusable: function ($el) {
                    return $el[0].tabIndex = "0", $el
                },
                addRole: function ($el, role) {
                    return $el.attr("role", role), $el
                },
                addLabel: function ($el, label) {
                    return $el.attr("aria-label", label), $el
                },
                disable: function ($el) {
                    return $el.attr("aria-disabled", !0), $el
                },
                enable: function ($el) {
                    return $el.attr("aria-disabled", !1), $el
                },
                onEnterKey: function (event) {
                    13 === event.keyCode && ($(event.target).is(s.params.nextButton) ? (s.onClickNext(event), s.isEnd ? s.a11y.notify(s.params.lastSlideMsg) : s.a11y.notify(s.params.nextSlideMsg)) : $(event.target).is(s.params.prevButton) && (s.onClickPrev(event), s.isBeginning ? s.a11y.notify(s.params.firstSlideMsg) : s.a11y.notify(s.params.prevSlideMsg)))
                },
                liveRegion: $('<span class="swiper-notification" aria-live="assertive" aria-atomic="true"></span>'),
                notify: function (message) {
                    var notification = s.a11y.liveRegion;
                    0 !== notification.length && (notification.html(""), notification.html(message))
                },
                init: function () {
                    if (s.params.nextButton) {
                        var nextButton = $(s.params.nextButton);
                        s.a11y.makeFocusable(nextButton), s.a11y.addRole(nextButton, "button"), s.a11y.addLabel(nextButton, s.params.nextSlideMsg)
                    }
                    if (s.params.prevButton) {
                        var prevButton = $(s.params.prevButton);
                        s.a11y.makeFocusable(prevButton), s.a11y.addRole(prevButton, "button"), s.a11y.addLabel(prevButton, s.params.prevSlideMsg)
                    }
                    $(s.container).append(s.a11y.liveRegion)
                },
                destroy: function () {
                    s.a11y.liveRegion && s.a11y.liveRegion.length > 0 && s.a11y.liveRegion.remove()
                }
            }, s.init = function () {
                s.params.loop && s.createLoop(), s.updateContainerSize(), s.updateSlidesSize(), s.updatePagination(), s.params.scrollbar && s.scrollbar && s.scrollbar.set(), "slide" !== s.params.effect && s.effects[s.params.effect] && (s.params.loop || s.updateProgress(), s.effects[s.params.effect].setTranslate()), s.params.loop ? s.slideTo(s.params.initialSlide + s.loopedSlides, 0, s.params.runCallbacksOnInit) : (s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit), 0 === s.params.initialSlide && (s.parallax && s.params.parallax && s.parallax.setTranslate(), s.lazy && s.params.lazyLoading && (s.lazy.load(), s.lazy.initialImageLoaded = !0))), s.attachEvents(), s.params.observer && s.support.observer && s.initObservers(), s.params.preloadImages && !s.params.lazyLoading && s.preloadImages(), s.params.autoplay && s.startAutoplay(), s.params.keyboardControl && s.enableKeyboardControl && s.enableKeyboardControl(), s.params.mousewheelControl && s.enableMousewheelControl && s.enableMousewheelControl(), s.params.hashnav && s.hashnav && s.hashnav.init(), s.params.a11y && s.a11y && s.a11y.init(), s.emit("onInit", s)
            }, s.cleanupStyles = function () {
                s.container.removeClass(s.classNames.join(" ")).removeAttr("style"), s.wrapper.removeAttr("style"), s.slides && s.slides.length && s.slides.removeClass([s.params.slideVisibleClass, s.params.slideActiveClass, s.params.slideNextClass, s.params.slidePrevClass].join(" ")).removeAttr("style").removeAttr("data-swiper-column").removeAttr("data-swiper-row"), s.paginationContainer && s.paginationContainer.length && s.paginationContainer.removeClass(s.params.paginationHiddenClass), s.bullets && s.bullets.length && s.bullets.removeClass(s.params.bulletActiveClass), s.params.prevButton && $(s.params.prevButton).removeClass(s.params.buttonDisabledClass), s.params.nextButton && $(s.params.nextButton).removeClass(s.params.buttonDisabledClass), s.params.scrollbar && s.scrollbar && (s.scrollbar.track && s.scrollbar.track.length && s.scrollbar.track.removeAttr("style"), s.scrollbar.drag && s.scrollbar.drag.length && s.scrollbar.drag.removeAttr("style"))
            }, s.destroy = function (deleteInstance, cleanupStyles) {
                s.detachEvents(), s.stopAutoplay(), s.params.loop && s.destroyLoop(), cleanupStyles && s.cleanupStyles(), s.disconnectObservers(), s.params.keyboardControl && s.disableKeyboardControl && s.disableKeyboardControl(), s.params.mousewheelControl && s.disableMousewheelControl && s.disableMousewheelControl(), s.params.a11y && s.a11y && s.a11y.destroy(), s.emit("onDestroy"), deleteInstance !== !1 && (s = null)
            }, s.init(), s
        }
    };
    Swiper.prototype = {
        isSafari: function () {
            var ua = navigator.userAgent.toLowerCase();
            return ua.indexOf("safari") >= 0 && ua.indexOf("chrome") < 0 && ua.indexOf("android") < 0
        }(),
        isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(navigator.userAgent),
        isArray: function (arr) {
            return "[object Array]" === Object.prototype.toString.apply(arr)
        },
        browser: {
            ie: window.navigator.pointerEnabled || window.navigator.msPointerEnabled,
            ieTouch: window.navigator.msPointerEnabled && window.navigator.msMaxTouchPoints > 1 || window.navigator.pointerEnabled && window.navigator.maxTouchPoints > 1
        },
        device: function () {
            var ua = navigator.userAgent, android = ua.match(/(Android);?[\s\/]+([\d.]+)?/), ipad = ua.match(/(iPad).*OS\s([\d_]+)/), iphone = (ua.match(/(iPod)(.*OS\s([\d_]+))?/), !ipad && ua.match(/(iPhone\sOS)\s([\d_]+)/));
            return {ios: ipad || iphone || ipad, android: android}
        }(),
        support: {
            touch: window.Modernizr && Modernizr.touch === !0 || function () {
                return !!("ontouchstart" in window || window.DocumentTouch && document instanceof DocumentTouch)
            }(), transforms3d: window.Modernizr && Modernizr.csstransforms3d === !0 || function () {
                var div = document.createElement("div").style;
                return "webkitPerspective" in div || "MozPerspective" in div || "OPerspective" in div || "MsPerspective" in div || "perspective" in div
            }(), flexbox: function () {
                for (var div = document.createElement("div").style, styles = "alignItems webkitAlignItems webkitBoxAlign msFlexAlign mozBoxAlign webkitFlexDirection msFlexDirection mozBoxDirection mozBoxOrient webkitBoxDirection webkitBoxOrient".split(" "), i = 0; i < styles.length; i++)if (styles[i] in div)return !0
            }(), observer: function () {
                return "MutationObserver" in window || "WebkitMutationObserver" in window
            }()
        },
        plugins: {}
    };
    for (var Dom7 = (function () {
        var Dom7 = function (arr) {
            var _this = this, i = 0;
            for (i = 0; i < arr.length; i++)_this[i] = arr[i];
            return _this.length = arr.length, this
        }, $ = function (selector, context) {
            var arr = [], i = 0;
            if (selector && !context && selector instanceof Dom7)return selector;
            if (selector)if ("string" == typeof selector) {
                var els, tempParent, html = selector.trim();
                if (html.indexOf("<") >= 0 && html.indexOf(">") >= 0) {
                    var toCreate = "div";
                    for (0 === html.indexOf("<li") && (toCreate = "ul"), 0 === html.indexOf("<tr") && (toCreate = "tbody"), (0 === html.indexOf("<td") || 0 === html.indexOf("<th")) && (toCreate = "tr"), 0 === html.indexOf("<tbody") && (toCreate = "table"), 0 === html.indexOf("<option") && (toCreate = "select"), tempParent = document.createElement(toCreate), tempParent.innerHTML = selector, i = 0; i < tempParent.childNodes.length; i++)arr.push(tempParent.childNodes[i])
                } else for (els = context || "#" !== selector[0] || selector.match(/[ .<>:~]/) ? (context || document).querySelectorAll(selector) : [document.getElementById(selector.split("#")[1])], i = 0; i < els.length; i++)els[i] && arr.push(els[i])
            } else if (selector.nodeType || selector === window || selector === document) arr.push(selector); else if (selector.length > 0 && selector[0].nodeType)for (i = 0; i < selector.length; i++)arr.push(selector[i]);
            return new Dom7(arr)
        };
        return Dom7.prototype = {
            addClass: function (className) {
                if ("undefined" == typeof className)return this;
                for (var classes = className.split(" "), i = 0; i < classes.length; i++)for (var j = 0; j < this.length; j++)this[j].classList.add(classes[i]);
                return this
            }, removeClass: function (className) {
                for (var classes = className.split(" "), i = 0; i < classes.length; i++)for (var j = 0; j < this.length; j++)this[j].classList.remove(classes[i]);
                return this
            }, hasClass: function (className) {
                return this[0] ? this[0].classList.contains(className) : !1
            }, toggleClass: function (className) {
                for (var classes = className.split(" "), i = 0; i < classes.length; i++)for (var j = 0; j < this.length; j++)this[j].classList.toggle(classes[i]);
                return this
            }, attr: function (attrs, value) {
                if (1 === arguments.length && "string" == typeof attrs)return this[0] ? this[0].getAttribute(attrs) : void 0;
                for (var i = 0; i < this.length; i++)if (2 === arguments.length) this[i].setAttribute(attrs, value); else for (var attrName in attrs)this[i][attrName] = attrs[attrName], this[i].setAttribute(attrName, attrs[attrName]);
                return this
            }, removeAttr: function (attr) {
                for (var i = 0; i < this.length; i++)this[i].removeAttribute(attr);
                return this
            }, data: function (key, value) {
                if ("undefined" == typeof value) {
                    if (this[0]) {
                        var dataKey = this[0].getAttribute("data-" + key);
                        return dataKey ? dataKey : this[0].dom7ElementDataStorage && key in this[0].dom7ElementDataStorage ? this[0].dom7ElementDataStorage[key] : void 0
                    }
                    return void 0
                }
                for (var i = 0; i < this.length; i++) {
                    var el = this[i];
                    el.dom7ElementDataStorage || (el.dom7ElementDataStorage = {}), el.dom7ElementDataStorage[key] = value
                }
                return this
            }, transform: function (transform) {
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform
                }
                return this
            }, transition: function (duration) {
                "string" != typeof duration && (duration += "ms");
                for (var i = 0; i < this.length; i++) {
                    var elStyle = this[i].style;
                    elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration
                }
                return this
            }, on: function (eventName, targetSelector, listener, capture) {
                function handleLiveEvent(e) {
                    var target = e.target;
                    if ($(target).is(targetSelector)) listener.call(target, e); else for (var parents = $(target).parents(), k = 0; k < parents.length; k++)$(parents[k]).is(targetSelector) && listener.call(parents[k], e)
                }

                var i, j, events = eventName.split(" ");
                for (i = 0; i < this.length; i++)if ("function" == typeof targetSelector || targetSelector === !1)for ("function" == typeof targetSelector && (listener = arguments[1], capture = arguments[2] || !1), j = 0; j < events.length; j++)this[i].addEventListener(events[j], listener, capture); else for (j = 0; j < events.length; j++)this[i].dom7LiveListeners || (this[i].dom7LiveListeners = []), this[i].dom7LiveListeners.push({
                    listener: listener,
                    liveListener: handleLiveEvent
                }), this[i].addEventListener(events[j], handleLiveEvent, capture);
                return this
            }, off: function (eventName, targetSelector, listener, capture) {
                for (var events = eventName.split(" "), i = 0; i < events.length; i++)for (var j = 0; j < this.length; j++)if ("function" == typeof targetSelector || targetSelector === !1) "function" == typeof targetSelector && (listener = arguments[1], capture = arguments[2] || !1), this[j].removeEventListener(events[i], listener, capture); else if (this[j].dom7LiveListeners)for (var k = 0; k < this[j].dom7LiveListeners.length; k++)this[j].dom7LiveListeners[k].listener === listener && this[j].removeEventListener(events[i], this[j].dom7LiveListeners[k].liveListener, capture);
                return this
            }, once: function (eventName, targetSelector, listener, capture) {
                function proxy(e) {
                    listener(e), dom.off(eventName, targetSelector, proxy, capture)
                }

                var dom = this;
                "function" == typeof targetSelector && (targetSelector = !1, listener = arguments[1], capture = arguments[2]), dom.on(eventName, targetSelector, proxy, capture)
            }, trigger: function (eventName, eventData) {
                for (var i = 0; i < this.length; i++) {
                    var evt;
                    try {
                        evt = new window.CustomEvent(eventName, {detail: eventData, bubbles: !0, cancelable: !0})
                    } catch (e) {
                        evt = document.createEvent("Event"), evt.initEvent(eventName, !0, !0), evt.detail = eventData
                    }
                    this[i].dispatchEvent(evt)
                }
                return this
            }, transitionEnd: function (callback) {
                function fireCallBack(e) {
                    if (e.target === this)for (callback.call(this, e), i = 0; i < events.length; i++)dom.off(events[i], fireCallBack)
                }

                var i, events = ["webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd", "msTransitionEnd"], dom = this;
                if (callback)for (i = 0; i < events.length; i++)dom.on(events[i], fireCallBack);
                return this
            }, width: function () {
                return this[0] === window ? window.innerWidth : this.length > 0 ? parseFloat(this.css("width")) : null
            }, outerWidth: function (includeMargins) {
                return this.length > 0 ? includeMargins ? this[0].offsetWidth + parseFloat(this.css("margin-right")) + parseFloat(this.css("margin-left")) : this[0].offsetWidth : null
            }, height: function () {
                return this[0] === window ? window.innerHeight : this.length > 0 ? parseFloat(this.css("height")) : null
            }, outerHeight: function (includeMargins) {
                return this.length > 0 ? includeMargins ? this[0].offsetHeight + parseFloat(this.css("margin-top")) + parseFloat(this.css("margin-bottom")) : this[0].offsetHeight : null
            }, offset: function () {
                if (this.length > 0) {
                    var el = this[0], box = el.getBoundingClientRect(), body = document.body, clientTop = el.clientTop || body.clientTop || 0, clientLeft = el.clientLeft || body.clientLeft || 0, scrollTop = window.pageYOffset || el.scrollTop, scrollLeft = window.pageXOffset || el.scrollLeft;
                    return {top: box.top + scrollTop - clientTop, left: box.left + scrollLeft - clientLeft}
                }
                return null
            }, css: function (props, value) {
                var i;
                if (1 === arguments.length) {
                    if ("string" != typeof props) {
                        for (i = 0; i < this.length; i++)for (var prop in props)this[i].style[prop] = props[prop];
                        return this
                    }
                    if (this[0])return window.getComputedStyle(this[0], null).getPropertyValue(props)
                }
                if (2 === arguments.length && "string" == typeof props) {
                    for (i = 0; i < this.length; i++)this[i].style[props] = value;
                    return this
                }
                return this
            }, each: function (callback) {
                for (var i = 0; i < this.length; i++)callback.call(this[i], i, this[i]);
                return this
            }, html: function (html) {
                if ("undefined" == typeof html)return this[0] ? this[0].innerHTML : void 0;
                for (var i = 0; i < this.length; i++)this[i].innerHTML = html;
                return this
            }, is: function (selector) {
                if (!this[0])return !1;
                var compareWith, i;
                if ("string" == typeof selector) {
                    var el = this[0];
                    if (el === document)return selector === document;
                    if (el === window)return selector === window;
                    if (el.matches)return el.matches(selector);
                    if (el.webkitMatchesSelector)return el.webkitMatchesSelector(selector);
                    if (el.mozMatchesSelector)return el.mozMatchesSelector(selector);
                    if (el.msMatchesSelector)return el.msMatchesSelector(selector);
                    for (compareWith = $(selector), i = 0; i < compareWith.length; i++)if (compareWith[i] === this[0])return !0;
                    return !1
                }
                if (selector === document)return this[0] === document;
                if (selector === window)return this[0] === window;
                if (selector.nodeType || selector instanceof Dom7) {
                    for (compareWith = selector.nodeType ? [selector] : selector, i = 0; i < compareWith.length; i++)if (compareWith[i] === this[0])return !0;
                    return !1
                }
                return !1
            }, index: function () {
                if (this[0]) {
                    for (var child = this[0], i = 0; null !== (child = child.previousSibling);)1 === child.nodeType && i++;
                    return i
                }
                return void 0
            }, eq: function (index) {
                if ("undefined" == typeof index)return this;
                var returnIndex, length = this.length;
                return index > length - 1 ? new Dom7([]) : 0 > index ? (returnIndex = length + index, new Dom7(0 > returnIndex ? [] : [this[returnIndex]])) : new Dom7([this[index]])
            }, append: function (newChild) {
                var i, j;
                for (i = 0; i < this.length; i++)if ("string" == typeof newChild) {
                    var tempDiv = document.createElement("div");
                    for (tempDiv.innerHTML = newChild; tempDiv.firstChild;)this[i].appendChild(tempDiv.firstChild)
                } else if (newChild instanceof Dom7)for (j = 0; j < newChild.length; j++)this[i].appendChild(newChild[j]); else this[i].appendChild(newChild);
                return this
            }, prepend: function (newChild) {
                var i, j;
                for (i = 0; i < this.length; i++)if ("string" == typeof newChild) {
                    var tempDiv = document.createElement("div");
                    for (tempDiv.innerHTML = newChild, j = tempDiv.childNodes.length - 1; j >= 0; j--)this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0])
                } else if (newChild instanceof Dom7)for (j = 0; j < newChild.length; j++)this[i].insertBefore(newChild[j], this[i].childNodes[0]); else this[i].insertBefore(newChild, this[i].childNodes[0]);
                return this
            }, insertBefore: function (selector) {
                for (var before = $(selector), i = 0; i < this.length; i++)if (1 === before.length) before[0].parentNode.insertBefore(this[i], before[0]); else if (before.length > 1)for (var j = 0; j < before.length; j++)before[j].parentNode.insertBefore(this[i].cloneNode(!0), before[j])
            }, insertAfter: function (selector) {
                for (var after = $(selector), i = 0; i < this.length; i++)if (1 === after.length) after[0].parentNode.insertBefore(this[i], after[0].nextSibling); else if (after.length > 1)for (var j = 0; j < after.length; j++)after[j].parentNode.insertBefore(this[i].cloneNode(!0), after[j].nextSibling)
            }, next: function (selector) {
                return new Dom7(this.length > 0 ? selector ? this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector) ? [this[0].nextElementSibling] : [] : this[0].nextElementSibling ? [this[0].nextElementSibling] : [] : [])
            }, nextAll: function (selector) {
                var nextEls = [], el = this[0];
                if (!el)return new Dom7([]);
                for (; el.nextElementSibling;) {
                    var next = el.nextElementSibling;
                    selector ? $(next).is(selector) && nextEls.push(next) : nextEls.push(next), el = next
                }
                return new Dom7(nextEls)
            }, prev: function (selector) {
                return new Dom7(this.length > 0 ? selector ? this[0].previousElementSibling && $(this[0].previousElementSibling).is(selector) ? [this[0].previousElementSibling] : [] : this[0].previousElementSibling ? [this[0].previousElementSibling] : [] : [])
            }, prevAll: function (selector) {
                var prevEls = [], el = this[0];
                if (!el)return new Dom7([]);
                for (; el.previousElementSibling;) {
                    var prev = el.previousElementSibling;
                    selector ? $(prev).is(selector) && prevEls.push(prev) : prevEls.push(prev), el = prev
                }
                return new Dom7(prevEls)
            }, parent: function (selector) {
                for (var parents = [], i = 0; i < this.length; i++)selector ? $(this[i].parentNode).is(selector) && parents.push(this[i].parentNode) : parents.push(this[i].parentNode);
                return $($.unique(parents))
            }, parents: function (selector) {
                for (var parents = [], i = 0; i < this.length; i++)for (var parent = this[i].parentNode; parent;)selector ? $(parent).is(selector) && parents.push(parent) : parents.push(parent), parent = parent.parentNode;
                return $($.unique(parents))
            }, find: function (selector) {
                for (var foundElements = [], i = 0; i < this.length; i++)for (var found = this[i].querySelectorAll(selector), j = 0; j < found.length; j++)foundElements.push(found[j]);
                return new Dom7(foundElements)
            }, children: function (selector) {
                for (var children = [], i = 0; i < this.length; i++)for (var childNodes = this[i].childNodes, j = 0; j < childNodes.length; j++)selector ? 1 === childNodes[j].nodeType && $(childNodes[j]).is(selector) && children.push(childNodes[j]) : 1 === childNodes[j].nodeType && children.push(childNodes[j]);
                return new Dom7($.unique(children))
            }, remove: function () {
                for (var i = 0; i < this.length; i++)this[i].parentNode && this[i].parentNode.removeChild(this[i]);
                return this
            }, add: function () {
                var i, j, dom = this;
                for (i = 0; i < arguments.length; i++) {
                    var toAdd = $(arguments[i]);
                    for (j = 0; j < toAdd.length; j++)dom[dom.length] = toAdd[j], dom.length++
                }
                return dom
            }
        }, $.fn = Dom7.prototype, $.unique = function (arr) {
            for (var unique = [], i = 0; i < arr.length; i++)-1 === unique.indexOf(arr[i]) && unique.push(arr[i]);
            return unique
        }, $
    }()), swiperDomPlugins = ["jQuery", "Zepto", "Dom7"], i = 0; i < swiperDomPlugins.length; i++)window[swiperDomPlugins[i]] && addLibraryPlugin(window[swiperDomPlugins[i]]);
    var domLib;
    domLib = "undefined" == typeof Dom7 ? window.Dom7 || window.Zepto || window.jQuery : Dom7, domLib && ("transitionEnd" in domLib.fn || (domLib.fn.transitionEnd = function (callback) {
        function fireCallBack(e) {
            if (e.target === this)for (callback.call(this, e), i = 0; i < events.length; i++)dom.off(events[i], fireCallBack)
        }

        var i, events = ["webkitTransitionEnd", "transitionend", "oTransitionEnd", "MSTransitionEnd", "msTransitionEnd"], dom = this;
        if (callback)for (i = 0; i < events.length; i++)dom.on(events[i], fireCallBack);
        return this
    }), "transform" in domLib.fn || (domLib.fn.transform = function (transform) {
        for (var i = 0; i < this.length; i++) {
            var elStyle = this[i].style;
            elStyle.webkitTransform = elStyle.MsTransform = elStyle.msTransform = elStyle.MozTransform = elStyle.OTransform = elStyle.transform = transform
        }
        return this
    }), "transition" in domLib.fn || (domLib.fn.transition = function (duration) {
        "string" != typeof duration && (duration += "ms");
        for (var i = 0; i < this.length; i++) {
            var elStyle = this[i].style;
            elStyle.webkitTransitionDuration = elStyle.MsTransitionDuration = elStyle.msTransitionDuration = elStyle.MozTransitionDuration = elStyle.OTransitionDuration = elStyle.transitionDuration = duration
        }
        return this
    })), window.Swiper = Swiper
}(), "undefined" != typeof module ? module.exports = window.Swiper : "function" == typeof define && define.amd && define([], function () {
        "use strict";
        return window.Swiper
    });
var Base64Binary = {
    _keyStr: "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    decodeArrayBuffer: function (a) {
        var b = a.length / 4 * 3, c = new ArrayBuffer(b);
        return this.decode(a, c), c
    },
    decode: function (a, b) {
        var c = this._keyStr.indexOf(a.charAt(a.length - 1)), d = this._keyStr.indexOf(a.charAt(a.length - 2)), e = a.length / 4 * 3;
        64 == c && e--, 64 == d && e--;
        var f, g, h, i, j, k, l, m, n = 0, o = 0;
        for (f = new Uint8Array(b ? b : e), a = a.replace(/[^A-Za-z0-9\+\/\=]/g, ""), n = 0; e > n; n += 3)j = this._keyStr.indexOf(a.charAt(o++)), k = this._keyStr.indexOf(a.charAt(o++)), l = this._keyStr.indexOf(a.charAt(o++)), m = this._keyStr.indexOf(a.charAt(o++)), g = j << 2 | k >> 4, h = (15 & k) << 4 | l >> 2, i = (3 & l) << 6 | m, f[n] = g, 64 != l && (f[n + 1] = h), 64 != m && (f[n + 2] = i);
        return f
    }
}, JSONP = function () {
    function a(a, b) {
        var c = document.createElement("script"), d = !1;
        c.src = a, c.async = !0;
        var f = b || h.error;
        "function" == typeof f && (c.onerror = function (b) {
            f({url: a, event: b})
        }), c.onload = c.onreadystatechange = function () {
            d || this.readyState && "loaded" !== this.readyState && "complete" !== this.readyState || (d = !0, c.onload = c.onreadystatechange = null, c && c.parentNode && c.parentNode.removeChild(c))
        }, e || (e = document.getElementsByTagName("head")[0]), e.appendChild(c)
    }

    function b(a) {
        return encodeURIComponent(a)
    }

    function c(c, d, e, i) {
        var j, k = -1 === (c || "").indexOf("?") ? "?" : "&";
        i = i || h.callbackName || "callback";
        var l = i + "_json" + ++f;
        d = d || {};
        for (j in d)d.hasOwnProperty(j) && (k += b(j) + "=" + b(d[j]) + "&");
        return g[l] = function (a) {
            e(a);
            try {
                delete g[l]
            } catch (b) {
            }
            g[l] = null
        }, a(c + k + i + "=" + l), l
    }

    function d(a) {
        h = a
    }

    var e, f = 0, g = this, h = {};
    return {get: c, init: d}
}();
void 0 === XMLHttpRequest.prototype.sendAsBinary && (XMLHttpRequest.prototype.sendAsBinary = function (a) {
    var b = Array.prototype.map.call(a, function (a) {
        return 255 & a.charCodeAt(0)
    });
    this.send(new Uint8Array(b).buffer)
});
var SERVER_URL = "http://lab.layerframe.com/postcard/scripts/";
OrderedMap.prototype.assert = function (a) {
    if (!(a in this.map))throw new Error('key: "' + a + '" does not exist')
}, OrderedMap.prototype.length = function () {
    return this._karray.length
}, OrderedMap.prototype.findFirst = function (a) {
    var b = 0;
    for (b; b < this._zarray.length; b++)if (this._zarray[b] > a)return b;
    return b
}, OrderedMap.prototype.add = function (a, b, c) {
    if (this.exists(a))throw new Error("key already exists");
    if (0 > b)throw new Error("z-index can't be less than 0");
    var d = this.findFirst(b);
    this._karray.splice(d, 0, a), this._zarray.splice(d, 0, b), this.map[a] = c
}, OrderedMap.prototype.remove = function (a) {
    this.assert(a);
    var b = this._karray.indexOf(a);
    this._karray.splice(b, 1), this._zarray.splice(b, 1), delete this.map[a]
}, OrderedMap.prototype.exists = function (a) {
    return a in this.map ? !0 : !1
}, OrderedMap.prototype.get = function (a) {
    return this.assert(a), this.map[a]
}, OrderedMap.prototype.getZindex = function (a) {
    this.assert(a);
    var b = this._karray.indexOf(a);
    return this._zarray[b]
}, OrderedMap.prototype.updateValue = function (a, b) {
    this.assert(a), this.map[a] = b
}, OrderedMap.prototype.changeOrder = function (a, b) {
    if (0 > b)throw new Error("z-index can't be less than 0");
    var c = this.get(a);
    this.remove(a), this.add(a, b, c)
}, OrderedMap.prototype.toStart = function (a) {
    var b = this.get(a);
    this.remove(a), this._karray.splice(0, 0, a), this._zarray.splice(0, 0, 0), this.map[a] = b
}, OrderedMap.prototype.toEnd = function (a) {
    var b = this._zarray[this._zarray.length - 1];
    this.changeOrder(a, b)
}, OrderedMap.prototype.forEach = function (a) {
    for (var b, c, d, e = 0; e < this._karray.length; e++)b = this._karray[e], d = this._zarray[e], c = this.map[b], a(b, d, c)
}, OrderedMap.prototype.filter = function (a) {
    var b = [];
    return this.forEach(function (c, d, e) {
        a.apply(null, [c, d, e]) && b.push(e)
    }), b
}, PostcardObject.prototype.draw = function () {
    this.ctx.save(), this.ctx.fillStyle = this.opts.fill, this.globalAlpha = this.opts.opacity, this.ctx.fillRect(this.x, this.y, this.w, this.h), this.ctx.restore()
}, PostcardObject.prototype.contains = function (a, b) {
    return this.x <= a && this.x + this.w >= a && this.y <= b && this.y + this.h >= b
}, PostcardObject.prototype.update = function (a) {
    this.opts = _extend({}, this.opts, a), this.x = parseInt(this.opts.x, 10), this.y = parseInt(this.opts.y, 10), this.w = parseInt(this.opts.w, 10), this.h = parseInt(this.opts.h, 10), _triggerEvent(this.ctx.canvas, "forcerender")
}, PostcardObject.prototype.show = function () {
    this.opts.opacity = 1, _triggerEvent(this.ctx.canvas, "forcerender")
}, PostcardObject.prototype.hide = function () {
    this.opts.opacity = 0, _triggerEvent(this.ctx.canvas, "forcerender")
}, PostcardImageObject.prototype = new PostcardObject, PostcardImageObject.prototype.constructor = PostcardImageObject, PostcardImageObject.prototype.draw = function () {
    if (this.imageloaded) {
        var a = this.x, b = this.y;
        this.ctx.save(), this.opts.rotation > 0 && (this.ctx.translate(this.x + this.w / 2, this.y + this.h / 2), this.ctx.rotate(this.opts.rotation * Math.PI / 180), a = -this.w / 2, b = -this.h / 2), this.ctx.globalAlpha = this.opts.opacity, this.opts.crop ? this.ctx.drawImage(this.imgElm, cropX, cropY, cropW, cropH, a, b, this.w, this.h) : this.ctx.drawImage(this.imgElm, a, b, this.w, this.h), this.ctx.restore()
    }
}, PostcardImageObject.prototype.revert = function () {
    if (!this.opts.keepOriginal)throw new Error("original image wasn't preserved");
    this._ctx.putImageData(this.origImgData, 0, 0), this.imgElm.src = this._canvas.toDataURL()
}, PostcardImageObject.prototype.getOriginalImageData = function () {
    if (this.imageloaded && this.opts.keepOriginal) {
        var a = this._ctx.createImageData(this.origImgData.width, this.origImgData.height);
        return a.data.set(this.origImgData.data), a
    }
    throw new Error("image not loaded/not saving original")
}, PostcardImageObject.prototype.getCurrentImageData = function () {
    if (this.imageloaded)return this._ctx.getImageData(0, 0, this._canvas.width, this._canvas.height);
    throw new Error("image not loaded")
}, PostcardImageObject.prototype.setImageData = function (a) {
    this._ctx.putImageData(a, 0, 0), this.imgElm.src = this._canvas.toDataURL()
}, PostcardImageObject.prototype.getRotation = function () {
    return this.opts.rotation
}, PostcardImageObject.prototype.setRotation = function (a) {
    this.opts.rotation = a % 360, _triggerEvent(this.ctx.canvas, "forcerender")
}, PostcardImageObject.prototype.onImageLoaded = function (a) {
    this.userImageLoaded = a
}, PostcardTextObject.prototype = new PostcardObject, PostcardTextObject.prototype.constructor = PostcardTextObject, PostcardTextObject.prototype.draw = function () {
    this.ctx.save(), this.ctx.fillStyle = this.opts.fill, this.ctx.font = this.getFont(), this.ctx.fillText(this.text, this.x, this.y), this.ctx.restore()
}, PostcardTextObject.prototype.update = function (a) {
    this.opts = _extend({}, this.opts, a), this.x = parseInt(this.opts.x, 10), this.y = parseInt(this.opts.y, 10), curr._ctx.font = curr.getFont(), this.w = this.opts.w = this._ctx.measureText(this.text).width, this.h = parseInt(this.opts.h, 10)
}, PostcardTextObject.prototype.contains = function (a, b) {
    return this.x <= a && this.x + this.w >= a && this.y >= b && this.y - this.h <= b
}, PostcardTextObject.prototype.changeText = function (a) {
    this.text = a, this.w = this.opts.w = this._ctx.measureText(this.text).width, _triggerEvent(this.ctx.canvas, "forcerender")
}, PostcardTextObject.prototype.getFont = function () {
    return this.opts.style + " normal " + this.opts.weight + " " + this.opts.size + " " + this.opts.family
}, PostcardTextObject.prototype.setFont = function (a) {
    var b = a.split(" ", 4), c = a.slice(a.indexOf("px") + 3);
    this.opts.fill = b[0], this.opts.style = b[1], this.opts.weight = b[2], this.opts.size = b[3], this.opts.family = c, this._ctx.font = this.getFont(), this.w = this.opts.w = this._ctx.measureText(this.text).width, this.h = this.opts.h = parseInt(this.opts.size, 10), _triggerEvent(this.ctx.canvas, "forcerender")
}, Postcard.prototype.clear = function () {
    this.ctx.clearRect(0, 0, this.width, this.height)
}, Postcard.prototype.triggerRefresh = function () {
    this.valid = !1
}, Postcard.prototype.render = function () {
    if (!this.valid) {
        if (this.clear(), this.renderingStack.forEach(function (a, b, c) {
                c.draw()
            }), null != this.selection) {
            this.ctx.strokeStyle = "#CC0000", this.ctx.lineWidth = "2";
            var a = this.selection;
            "text" == a.type ? this.ctx.strokeRect(a.x, a.y - a.h, a.w, a.h) : this.ctx.strokeRect(a.x, a.y, a.w, a.h)
        }
        this.valid = !0
    }
}, Postcard.prototype.get = function (a) {
    return this.renderingStack.get(a)
}, Postcard.prototype.remove = function (a) {
    return this.renderingStack.remove(a)
}, Postcard.prototype.getSome = function (a) {
    return this.renderingStack.filter(a)
}, Postcard.prototype.getSelection = function () {
    return this.selection
}, Postcard.prototype.addObject = function (a, b, c) {
    var d = a, e = this.startingZindex, f = {};
    arguments.length > 2 ? (e = arguments[1], f = arguments[2]) : 2 == arguments.length && ("number" == typeof arguments[1] ? e = arguments[1] : f = arguments[1]);
    var g = new PostcardObject("shape", this.ctx, f);
    return this.renderingStack.add(d, e, g), g
}, Postcard.prototype.addImage = function (a, b, c, d) {
    var e = a, f = b, g = this.startingZindex, h = {};
    if ("string" != typeof arguments[1])throw new Error("no url specified? id: " + e);
    arguments.length > 3 ? (g = arguments[2], h = arguments[3]) : 3 === arguments.length && ("number" == typeof arguments[2] ? g = arguments[2] : h = arguments[2]);
    var i = new PostcardImageObject(f, this.ctx, h);
    return this.renderingStack.add(e, g, i), i
}, Postcard.prototype.addText = function (a, b, c, d) {
    var e = a, f = b, g = this.startingZindex, h = {
        family: this.opts.fontFamily,
        size: this.opts.fontSize,
        fill: this.opts.fontColor,
        style: this.opts.fontStyle,
        weight: this.opts.fontWeight
    };
    if ("string" != typeof arguments[1])throw new Error("no text specified? id: " + e);
    arguments.length > 3 ? (g = arguments[2], h = _extend({}, h, arguments[3])) : 3 === arguments.length && ("number" == typeof arguments[2] ? g = arguments[2] : h = h = _extend({}, h, arguments[2]));
    var i = new PostcardTextObject(f, this.ctx, h);
    return this.renderingStack.add(e, g, i), i
}, Postcard.prototype.save = function (a) {
    (this.browser.isSafari || this.browser.isIE) && (alert("opening a new tab, just gotta [right click > save] the image. not ideal."), a.target.setAttribute("target", "_blank")), a.target.href = this.elm.toDataURL(), a.target.download = this.opts.filename
}, Postcard.prototype["export"] = function () {
    return this.elm.toDataURL()
}, angular.module("ash", []).directive("ngInfiniteScroll", ["$timeout", "Data", "Resource", function ($timeout, Data, Resource) {
    return {
        restrict: "A", scope: {options: "=", items: "="}, link: function ($scope, element) {
            $scope.lastRemain = void 0, $scope.offset = 0, $scope.inProcess = !1, $scope.options = angular.extend({
                limit: 10,
                threshold: 50,
                data: []
            }, $scope.options), $scope.hasItems = !0, $scope.options.resource || Array.isArray($scope.options.data) || ($scope.options.data = [$scope.options.data]), $scope.strategy = $scope.options.resource ? Resource : Data, $scope.strategy.addItems($scope), element.bind("scroll", function () {
                var remain = element[0].scrollHeight - (element[0].clientHeight + element[0].scrollTop);
                remain < $scope.options.threshold && (!$scope.lastRemain || remain - $scope.lastRemain < 0) && $scope.hasItems && !$scope.inProcess && $scope.$apply(function () {
                    $scope.strategy.addItems($scope)
                }), $scope.lastRemain = remain
            })
        }
    }
}]), app.factory("Data", function () {
    return {
        addItems: function ($scope) {
            $scope.inProcess = !0;
            var from = $scope.offset * $scope.options.limit;
            if (from < $scope.options.data.length) {
                var to = from + $scope.options.limit;
                to = to > $scope.options.data.length ? $scope.options.data.length : to;
                for (var i = from; to > i; i++)$scope.items = $scope.items.concat($scope.options.data[i]);
                $scope.offset++
            } else $scope.hasItems = !1;
            $scope.inProcess = !1
        }
    }
}), app.factory("Resource", function () {
    return {
        addItems: function ($scope) {
            $scope.inProcess = !0, $scope.options.resource.query({
                offset: $scope.offset * $scope.options.limit,
                limit: $scope.options.limit
            }, function (data) {
                if (0 == data.models.length) $scope.hasItems = !1; else for (var i = 0; i < data.models.length; i++)$scope.items = $scope.items.concat(data.models[i]);
                $scope.inProcess = !1
            })
        }
    }
}), angular.module("ngProgress.provider", ["ngProgress.directive"]).provider("ngProgress", function () {
    "use strict";
    this.autoStyle = !0, this.count = 0, this.height = "2px", this.color = "firebrick", this.$get = ["$document", "$window", "$compile", "$rootScope", "$timeout", function ($document, $window, $compile, $rootScope, $timeout) {
        var count = this.count, height = this.height, color = this.color, $scope = $rootScope, parent = $document.find("body")[0], progressbarEl = $compile("<ng-progress></ng-progress>")($scope);
        parent.appendChild(progressbarEl[0]), $scope.count = count, void 0 !== height && progressbarEl.eq(0).children().css("height", height), void 0 !== color && (progressbarEl.eq(0).children().css("background-color", color), progressbarEl.eq(0).children().css("color", color));
        var animation, intervalCounterId = 0;
        return {
            start: function () {
                this.show();
                var self = this;
                clearInterval(intervalCounterId), intervalCounterId = setInterval(function () {
                    if (isNaN(count)) clearInterval(intervalCounterId), count = 0, self.hide(); else {
                        var remaining = 100 - count;
                        count += .15 * Math.pow(1 - Math.sqrt(remaining), 2), self.updateCount(count)
                    }
                }, 200)
            }, updateCount: function (new_count) {
                $scope.count = new_count, $scope.$$phase || $scope.$apply()
            }, height: function (new_height) {
                return void 0 !== new_height && (height = new_height, $scope.height = height, $scope.$$phase || $scope.$apply()), height
            }, color: function (new_color) {
                return void 0 !== new_color && (color = new_color, $scope.color = color, $scope.$$phase || $scope.$apply()), color
            }, hide: function () {
                progressbarEl.children().css("opacity", "0");
                var self = this;
                self.animate(function () {
                    progressbarEl.children().css("width", "0%"), self.animate(function () {
                        self.show()
                    }, 500)
                }, 500)
            }, show: function () {
                var self = this;
                self.animate(function () {
                    progressbarEl.children().css("opacity", "1")
                }, 100)
            }, animate: function (fn, time) {
                animation && $timeout.cancel(animation), animation = $timeout(fn, time)
            }, status: function () {
                return count
            }, stop: function () {
                clearInterval(intervalCounterId)
            }, set: function (new_count) {
                return this.show(), this.updateCount(new_count), count = new_count, clearInterval(intervalCounterId), count
            }, css: function (args) {
                return progressbarEl.children().css(args)
            }, reset: function () {
                return clearInterval(intervalCounterId), count = 0, this.updateCount(count), 0
            }, complete: function () {
                count = 100, this.updateCount(count);
                var self = this;
                return clearInterval(intervalCounterId), $timeout(function () {
                    self.hide(), $timeout(function () {
                        count = 0, self.updateCount(count)
                    }, 500)
                }, 1e3), count
            }, setParent: function (newParent) {
                if (null === newParent || void 0 === newParent)throw new Error("Provide a valid parent of type HTMLElement");
                null !== parent && void 0 !== parent && parent.removeChild(progressbarEl[0]), parent = newParent, parent.appendChild(progressbarEl[0])
            }, getDomElement: function () {
                return progressbarEl
            }
        }
    }], this.setColor = function (color) {
        return void 0 !== color && (this.color = color), this.color
    }, this.setHeight = function (height) {
        return void 0 !== height && (this.height = height), this.height
    }
}), angular.module("ngProgress.directive", []).directive("ngProgress", ["$window", "$rootScope", function ($window, $rootScope) {
    var directiveObj = {
        replace: !0, restrict: "E", link: function ($scope, $element, $attrs, $controller) {
            $rootScope.$watch("count", function (newVal) {
                (void 0 !== newVal || null !== newVal) && ($scope.counter = newVal, $element.eq(0).children().css("width", newVal + "%"))
            }), $rootScope.$watch("color", function (newVal) {
                (void 0 !== newVal || null !== newVal) && ($scope.color = newVal, $element.eq(0).children().css("background-color", newVal), $element.eq(0).children().css("color", newVal))
            }), $rootScope.$watch("height", function (newVal) {
                (void 0 !== newVal || null !== newVal) && ($scope.height = newVal, $element.eq(0).children().css("height", newVal))
            })
        }, template: '<div id="ngProgress-container"><div id="ngProgress"></div></div>'
    };
    return directiveObj
}]), angular.module("ngProgress", ["ngProgress.directive", "ngProgress.provider"]);